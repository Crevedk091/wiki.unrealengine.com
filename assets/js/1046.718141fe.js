(window.webpackJsonp=window.webpackJsonp||[]).push([[1046],{1383:function(e,t,s){"use strict";s.r(t);var a=s(28),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("TAssetPtr and Asynchronous Asset Loading - Epic Wiki")]),e._v(" "),s("h1",{attrs:{id:"tassetptr-and-asynchronous-asset-loading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tassetptr-and-asynchronous-asset-loading"}},[e._v("#")]),e._v(" TAssetPtr and Asynchronous Asset Loading")]),e._v(" "),s("h2",{attrs:{id:"contents"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#What_is_a_TAssetPtr"}},[e._v("1 What is a TAssetPtr")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#What_Problem_do_they_Solve"}},[e._v("2 What Problem do they Solve")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#Types"}},[e._v("3 Types")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#Key_Features"}},[e._v("3.1 Key Features")])])])]),e._v(" "),s("li",[s("a",{attrs:{href:"#How_to_use_them"}},[e._v("4 How to use them")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#Asset_Loader"}},[e._v("4.1 Asset Loader")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#Asset_Loading"}},[e._v("4.2 Asset Loading")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#Asset_Using"}},[e._v("4.3 Asset Using")])])])]),e._v(" "),s("li",[s("a",{attrs:{href:"#Further_Reading"}},[e._v("5 Further Reading")])])]),e._v(" "),s("h2",{attrs:{id:"what-is-a-tassetptr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-is-a-tassetptr"}},[e._v("#")]),e._v(" What is a TAssetPtr")]),e._v(" "),s("p",[e._v("Asset Pointers are similar to standard pointers in that they point to something. The difference is that TAssetPtr's point to an asset that may or may not yet be loaded, and if the asset is not loaded it contains the information required to load that asset for use. Where as standard hard pointers (*) load the asset upon creation and has no reference to the asset other than it's memory address.")]),e._v(" "),s("h2",{attrs:{id:"what-problem-do-they-solve"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-problem-do-they-solve"}},[e._v("#")]),e._v(" What Problem do they Solve")]),e._v(" "),s("p",[e._v("The easiest way to reference an asset is to create a UProperty of a hard pointer (*) and populate the asset in the Editor. However the asset will be loaded when the object containing the property is loaded. If you are not careful, you can end up loading 100% of your assets at game startup time. For loading and memory management reason it wouldn't make sense to load all you assets before they are needed, So why not load them asynchronously right before they are needed. Doing this allows you to only load what you need to get the game running, and have all other assets at your beck and call.")]),e._v(" "),s("h2",{attrs:{id:"types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#types"}},[e._v("#")]),e._v(" Types")]),e._v(" "),s("p",[e._v("Variable")]),e._v(" "),s("p",[e._v("Description")]),e._v(" "),s("p",[e._v("TAssetPtr"),s("T")],1),e._v(" "),s("p",[e._v("Points to asset that hasn't been loaded yet, but can be by request")]),e._v(" "),s("p",[e._v("TAssetSubclassOf"),s("T")],1),e._v(" "),s("p",[e._v("Points to a subclass of the defined baseclass that hasn't been loaded yet, but can be by request. Used to point to Blueprints instead of basic components.")]),e._v(" "),s("h3",{attrs:{id:"key-features"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#key-features"}},[e._v("#")]),e._v(" Key Features")]),e._v(" "),s("p",[s("strong",[e._v(".h")])]),e._v(" "),s("p",[e._v("/** Define the Asset Pointer. Don't forget to set a UPROPERTY */\nUPROPERTY(EditAnywhere)\nTAssetPtr<MyClass> MyAssetPointer;\n \n/** Define a subclass version. This will only allow you to select subclasses of the defined type. */\nUPROPERTY(EditAnywhere)\nTAssetSubclassOf<MyBaseClass> MyAssetSubclassOfPointer;")]),e._v(" "),s("p",[s("strong",[e._v(".cpp")])]),e._v(" "),s("p",[e._v("// Call IsValid() to test if the asset pointer points to a live UObject\nMyAssetPointer.IsValid();\n \n// Call Get() to return a pointer to the UObject if one exists\nMyAssetPointer.Get();\n \n/** Special Note about TAssetSubclassOf Get() it returns a UClass pointer!!*/\nMyAssetSubclassOfPointer.Get()\n/** To properly use a UClass pointer you must use GetDefaultObject"),s("T",[e._v("() to get a pointer to the UObject or derived class there of */\nMyAssetSubclassOfPointer.Get()->GetDefaultObject<MyBaseClass>()\n \n// Call ToStringReference() to return the StringAssetReference of the asset you wish to load\n// More on this below\nMyAssetPointer.ToStringReference();")])],1),e._v(" "),s("h2",{attrs:{id:"how-to-use-them"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-to-use-them"}},[e._v("#")]),e._v(" How to use them")]),e._v(" "),s("p",[e._v("Variable")]),e._v(" "),s("p",[e._v("Description")]),e._v(" "),s("p",[e._v("FStreamableManager")]),e._v(" "),s("p",[e._v("The manager that controls the streaming of assets into the game at runtime. This is a user defined object and should be defined on a object such as the GameInstance to allow for easy access.")]),e._v(" "),s("p",[e._v("FStringAssetReference")]),e._v(" "),s("p",[e._v("A struct that contains a string reference to an asset, can be used to make soft references to assets. (ToStringReference() are loaded into these so they can be passed into to FStreamableManager .")]),e._v(" "),s("h4",{attrs:{id:"asset-loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asset-loader"}},[e._v("#")]),e._v(" Asset Loader")]),e._v(" "),s("p",[e._v("The FStreamableManager will be your asset loader for loading assets Asynchronously. This is best put on a persistent object like the GameInstance for two main reasons.")]),e._v(" "),s("ol",[s("li",[e._v("To have easy access to it at all times which makes loading assets when you need them easy.")]),e._v(" "),s("li",[e._v("That it remains persistent since you never want to lose or destroy the reference to the FStreamableManager while loading objects.")])]),e._v(" "),s("p",[e._v("FStreamableManager AssetLoader;")]),e._v(" "),s("p",[e._v("The next major part is choosing how you want to load you're assets. There are two options")]),e._v(" "),s("h4",{attrs:{id:"asset-loading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asset-loading"}},[e._v("#")]),e._v(" Asset Loading")]),e._v(" "),s("p",[s("strong",[e._v("SimpleAsyncLoad")]),e._v(" which allows you to load a single asset that is strongly referenced. This means it will never be garbage collected until you unload it manually using Unload.")]),e._v(" "),s("p",[e._v("// the .h\nTAssetPtr<ABaseItem> MyItem;\n \n// the .cpp\nFStringAssetReference AssetToLoad\nAssetToLoad = MyItem.ToStringReference();\nAssetLoader.SimpleAsyncLoad(AssetToLoad);")]),e._v(" "),s("p",[s("strong",[e._v("RequestAsyncLoad")]),e._v(" loads an array of objects and fires a delegate when completed. This will Unload all the assets once the delegate is called, to ensure garbage collection takes place.")]),e._v(" "),s("p",[e._v("//the .h\nTArray< TAssetPtr<ABaseItem> > MyItems;\n \n// the .cpp\nTArray<FStringAssetReference> AssetsToLoad\nfor(TAssetPtr<ABaseItem>& AssetPtr : MyItems) // C++11 ranged loop\n{\nAssetsToLoad.AddUnique(AssetPtr.ToStringReference());\n}\nAssetLoader.RequestAsyncLoad(AssetsToLoad, FStreamableDelegate::CreateUObject(this, &MyClass::MyFunctionToBeCalledAfterAssetsAreLoaded));")]),e._v(" "),s("h4",{attrs:{id:"asset-using"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asset-using"}},[e._v("#")]),e._v(" Asset Using")]),e._v(" "),s("p",[e._v("After all this your asset(s) are ready to use. Don't forget to Get() them!")]),e._v(" "),s("p",[e._v("MyItem.Get(); // returns a pointer to the LIVE UObject")]),e._v(" "),s("h2",{attrs:{id:"further-reading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#further-reading"}},[e._v("#")]),e._v(" Further Reading")]),e._v(" "),s("p",[e._v("["),s("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/Programming/Assets/AsyncLoading/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Epic's Asynchronous Asset Loading Docs"),s("OutboundLink")],1),e._v("]"),s("br"),e._v(" "),s("a",{attrs:{href:"/Access_Functions_%26_Variables_From_a_TSubclassOf_Variable_in_C%2B%2B",title:"Access Functions & Variables From a TSubclassOf Variable in C++"}},[e._v("Access Functions & Variables From a TSubclassOf Variable in C++")])]),e._v(" "),s("p",[s("a",{attrs:{href:"/User:Oliver_Barraza",title:"User:Oliver Barraza"}},[e._v("Oliver Barraza")]),e._v(" ("),s("a",{attrs:{href:"/User_talk:Oliver_Barraza",title:"User talk:Oliver Barraza"}},[e._v("talk")]),e._v(")")]),e._v(" "),s("p",[e._v('Retrieved from "'),s("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=TAssetPtr_and_Asynchronous_Asset_Loading&oldid=23900",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=TAssetPtr_and_Asynchronous_Asset_Loading&oldid=23900"),s("OutboundLink")],1),e._v('"')]),e._v(" "),s("p",[s("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Categories")]),e._v(":")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])]),e._v(" "),s("li",[s("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=r.exports}}]);