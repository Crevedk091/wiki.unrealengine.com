(window.webpackJsonp=window.webpackJsonp||[]).push([[812],{727:function(e,t,a){"use strict";a.r(t);var r=a(28),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Local Multiplayer Tips - Epic Wiki")]),e._v(" "),a("h1",{attrs:{id:"local-multiplayer-tips"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#local-multiplayer-tips"}},[e._v("#")]),e._v(" Local Multiplayer Tips")]),e._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Spawning_Additional_Players"}},[e._v("2 Spawning Additional Players")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Using_a_Shared_Camera"}},[e._v("3 Using a Shared Camera")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Player_0_.3D_Keyboard.2C_Player_1_.3D_Gamepad_.28C.2B.2B.29"}},[e._v("4 Player 0 = Keyboard, Player 1 = Gamepad (C++)")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Multiple_Players_on_the_Keyboard_.28C.2B.2B.29"}},[e._v("5 Multiple Players on the Keyboard (C++)")])])]),e._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),a("p",[e._v("There are several common issues to solve when creating a local multiplayer game in Unreal. This page is intended to catalog these common issues and the methods you can use to solve them. Tips that involve some C++ are marked with (C++).")]),e._v(" "),a("h2",{attrs:{id:"spawning-additional-players"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spawning-additional-players"}},[e._v("#")]),e._v(" Spawning Additional Players")]),e._v(" "),a("p",[e._v("First, make sure that your level has multiple player starts placed in it. This is because the default behavior avoids spawning a player at a node where it would collide with another player. So you should place enough player starts for the maximal number of players you plan on supporting.")]),e._v(" "),a("p",[e._v("Next, in your Game Mode's Begin Play, use either the Create Player node (if in Blueprint) or "),a("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/API/Runtime/Engine/Kismet/UGameplayStatics/CreatePlayer/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("UGameplayStatics::CreatePlayer"),a("OutboundLink")],1),e._v(" (if in C++) to spawn however many additional players you want. This will spawn the default player controller and (optionally) the default pawn for the player. You can configure these default classes in your Game Mode.")]),e._v(" "),a("h2",{attrs:{id:"using-a-shared-camera"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-a-shared-camera"}},[e._v("#")]),e._v(" Using a Shared Camera")]),e._v(" "),a("p",[e._v("By default, when you spawn additional local players, Unreal will use splitscreen. To disable this, in your Project Settings go to "),a("strong",[e._v("Project>Maps & Modes>Local Multiplayer")]),e._v(" and uncheck "),a("strong",[e._v("Use Splitscreen")]),e._v(".")]),e._v(" "),a("p",[e._v("Once you've disabled splitscreen, you will only see the first player's view. If you want to create a more general shared camera, place a CameraActor instance in your level, and position/orient it however you'd like to. In the properties of your CameraActor instance, set "),a("strong",[e._v("Auto Player Activation")]),e._v(" to "),a("strong",[e._v("Player 0")]),e._v(". This forces the first player to use the CameraActor, and since splitscreen is disabled, it will be the only view that's visible.")]),e._v(" "),a("p",[e._v("For many games, you will want to have custom behavior beyond just a stationary camera. You can make a subclass of CameraActor (either in Blueprint or C++), and add whatever custom behavior you want. For some ideas on what you could do, see "),a("a",{attrs:{href:"/Creating_a_shared_camera_for_multiplayer_games",title:"Creating a shared camera for multiplayer games"}},[e._v("Creating a shared camera for multiplayer games")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"player-0-keyboard-player-1-gamepad-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#player-0-keyboard-player-1-gamepad-c"}},[e._v("#")]),e._v(" Player 0 = Keyboard, Player 1 = Gamepad (C++)")]),e._v(" "),a("p",[e._v("By default, the first controller always maps to player 0. The keyboard also always maps to player 0. Thus, in order to control two local players you are required to have two gamepads. A common request is to allow for player 0 to use the keyboard and player 1 to use the gamepad. Unfortunately, it appears the only way this can be done at this time is via C++ code, and the simplest solution is a bit hacky.")]),e._v(" "),a("p",[e._v("The following will set it up so that the controller is always mapped to the next player index. So player 0 will always be keyboard only, player 1 will use the 1st gamepad, player 2 will use the 2nd gamepad, etc. (Ideally, a better solution would only do this remapping if there are more players than gamepads. Unfortunately, this can't be done without some nontrivial engine-level changes).")]),e._v(" "),a("p",[e._v("Here's how you can implement this:")]),e._v(" "),a("ol",[a("li",[e._v("Change your project's main header file to #include "),a("strong",[e._v('"Engine.h"')]),e._v(' instead of "EngineMinimal.h". Otherwise you will get compile errors later on.')]),e._v(" "),a("li",[e._v("Use "),a("strong",[e._v("File>New C++ Class")]),e._v(', select "Show All Classes" and make a subclass of '),a("strong",[e._v("GameViewportClient")]),e._v(". I called it LocalMPViewportClient.")]),e._v(" "),a("li",[e._v("In your custom viewport client's class declaration, declare overrides of InputKey and InputAxis:")])]),e._v(" "),a("p",[e._v("virtual bool InputKey(FViewport* Viewport, int32 ControllerId, FKey Key, EInputEvent EventType, float AmountDepressed = 1.f, bool bGamepad = false) override;\nvirtual bool InputAxis(FViewport* Viewport, int32 ControllerId, FKey Key, float Delta, float DeltaTime, int32 NumSamples = 1, bool bGamepad = false) override;")]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("Implement these functions as follows in your .cpp:")])]),e._v(" "),a("p",[e._v("bool ULocalMPViewportClient::InputKey(FViewport* Viewport, int32 ControllerId, FKey Key, EInputEvent EventType, float AmountDepressed, bool bGamepad)\n{\nif (bGamepad)\n{\n// Map the gamepad to the next player index (so 1st controller is player index 1, etc.)\nreturn Super::InputKey(Viewport, ControllerId + 1, Key, EventType, AmountDepressed, bGamepad);\n}\nelse\n{\nreturn Super::InputKey(Viewport, ControllerId, Key, EventType, AmountDepressed, bGamepad);\n}\n}\n \nbool ULocalMPViewportClient::InputAxis(FViewport* Viewport, int32 ControllerId, FKey Key, float Delta, float DeltaTime, int32 NumSamples /*= 1*/, bool bGamepad /*= false*/)\n{\nif (bGamepad)\n{\n// Map the gamepad to the next player index (so 1st controller is player index 1, etc.)\nreturn Super::InputAxis(Viewport, ControllerId + 1, Key, Delta, DeltaTime, NumSamples, bGamepad);\n}\nelse\n{\nreturn Super::InputAxis(Viewport, ControllerId, Key, Delta, DeltaTime, NumSamples, bGamepad);\n}\n}")]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("In your project settings, go to "),a("strong",[e._v("Engine>General Settings>Default Classes")]),e._v(" and set "),a("strong",[e._v("Game Viewport Client Class")]),e._v(" to your custom class.")]),e._v(" "),a("li",[e._v("Restart the editor/rebuild your code. It seems like without the restart, the engine won't use your new game viewport client.")])]),e._v(" "),a("h2",{attrs:{id:"multiple-players-on-the-keyboard-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multiple-players-on-the-keyboard-c"}},[e._v("#")]),e._v(" Multiple Players on the Keyboard (C++)")]),e._v(" "),a("p",[e._v("As with the prior item, in order to get this to work properly, you need to override the Game Viewport Client. However, it also requires a bit of trickery with your input mappings.")]),e._v(" "),a("p",[e._v("If you want both multiple players on the keyboard and support for keyboard = 0, gamepad = 1, you can combine this approach with the prior item.")]),e._v(" "),a("ol",[a("li",[e._v("Change your project's main header file to #include "),a("strong",[e._v('"Engine.h"')]),e._v(' instead of "EngineMinimal.h". Otherwise you will get compile errors later on.')]),e._v(" "),a("li",[e._v("Use "),a("strong",[e._v("File>New C++ Class")]),e._v(', select "Show All Classes" and make a subclass of '),a("strong",[e._v("GameViewportClient")]),e._v(". I called it LocalMPViewportClient.")]),e._v(" "),a("li",[e._v("In your custom viewport client's class declaration, declare an override of InputKey:")])]),e._v(" "),a("p",[e._v("virtual bool InputKey(FViewport* Viewport, int32 ControllerId, FKey Key, EInputEvent EventType, float AmountDepressed = 1.f, bool bGamepad = false) override;")]),e._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[e._v("Implement InputKey as follows in your .cpp:")])]),e._v(" "),a("p",[e._v("bool ULocalMPViewportClient::InputKey(FViewport* Viewport, int32 ControllerId, FKey Key, EInputEvent EventType, float AmountDepressed, bool bGamepad)\n{\nif (IgnoreInput() || bGamepad || Key.IsMouseButton())\n{\nreturn Super::InputKey(Viewport, ControllerId, Key, EventType, AmountDepressed, bGamepad);\n}\nelse\n{\n// Propagate keyboard events to all players\nUEngine* const Engine = GetOuterUEngine();\nint32 const NumPlayers = Engine ? Engine->GetNumGamePlayers(this) : 0;\nbool bRetVal = false;\nfor (int32 i = 0; i < NumPlayers; i++)\n{\nbRetVal = Super::InputKey(Viewport, i, Key, EventType, AmountDepressed, bGamepad) || bRetVal;\n}\n \nreturn bRetVal;\n}\n}")]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("In your project settings, go to "),a("strong",[e._v("Engine>General Settings>Default Classes")]),e._v(" and set "),a("strong",[e._v("Game Viewport Client Class")]),e._v(" to your custom class.")]),e._v(" "),a("li",[e._v("Restart the editor/rebuild your code. It seems like without the restart, the engine won't use your new game viewport client.")]),e._v(" "),a("li",[e._v("Go to "),a("strong",[e._v("Engine>Input>Bindings")]),e._v(" in your project settings. You will need to configure different bindings for each player you want to support, like this:"),a("br"),e._v(" "),a("a",{attrs:{href:"/File:LocalMPTipsBindings.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/2/27/LocalMPTipsBindings.png",alt:"LocalMPTipsBindings.png"}})])]),e._v(" "),a("li",[e._v("Finally, in your SetupInputComponent function in your player controller, you need to configure it to use the different mappings based on the player index. For example, if you have MoveForward and MoveRight functions, you would do the following:")])]),e._v(" "),a("p",[e._v('int32 id = GetLocalPlayer()->GetControllerId();\nif (id == 0)\n{\nInputComponent->BindAxis("MoveForward_P1", this, &ALocalMPPlayerController::MoveForward);\nInputComponent->BindAxis("MoveRight_P1", this, &ALocalMPPlayerController::MoveRight);\n}\nelse if (id == 1)\n{\nInputComponent->BindAxis("MoveForward_P2", this, &ALocalMPPlayerController::MoveForward);\nInputComponent->BindAxis("MoveRight_P2", this, &ALocalMPPlayerController::MoveRight);\n}')]),e._v(" "),a("p",[a("a",{attrs:{href:"/User:Chalonverse",title:"User:Chalonverse"}},[e._v("User:Chalonverse")])]),e._v(" "),a("p",[e._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Local_Multiplayer_Tips&oldid=16750",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Local_Multiplayer_Tips&oldid=16750"),a("OutboundLink")],1),e._v('"')]),e._v(" "),a("p",[a("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=o.exports}}]);