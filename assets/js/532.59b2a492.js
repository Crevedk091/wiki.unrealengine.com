(window.webpackJsonp=window.webpackJsonp||[]).push([[532],{940:function(e,t,a){"use strict";a.r(t);var o=a(28),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("Garbage Collection Overview - Epic Wiki")]),e._v(" "),a("h1",{attrs:{id:"garbage-collection-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#garbage-collection-overview"}},[e._v("#")]),e._v(" Garbage Collection Overview")]),e._v(" "),a("p",[e._v("From Epic Wiki")]),e._v(" "),a("p",[e._v("Jump to: "),a("a",{attrs:{href:"#mw-head"}},[e._v("navigation")]),e._v(", "),a("a",{attrs:{href:"#p-search"}},[e._v("search")])]),e._v(" "),a("p",[a("a",{attrs:{href:"/index.php?title=Template:Rating&action=edit&redlink=1",title:"Template:Rating (page does not exist)"}},[e._v("Template:Rating")]),e._v(" Unreal's game-level memory management system uses reflection to implement garbage collection. Working effectively in Unreal requires some understanding of how these two systems interact.")]),e._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#What_is_reflection.3F"}},[e._v("1 What is reflection?")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Garbage_Collection"}},[e._v("2 Garbage Collection")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Structs_vs._Objects"}},[e._v("3 Structs vs. Objects")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Containers"}},[e._v("4 Containers")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#See_Also"}},[e._v("5 See Also")])])]),e._v(" "),a("h1",{attrs:{id:"what-is-reflection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-reflection"}},[e._v("#")]),e._v(" What is reflection?")]),e._v(" "),a("p",[e._v("Read this for a great introduction to Unreal's reflection system and using it: "),a("a",{attrs:{href:"https://www.unrealengine.com/blog/unreal-property-system-reflection",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.unrealengine.com/blog/unreal-property-system-reflection"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Reflection allows the engine to determine if objects are still referenced by other objects, making garbage collection a viable strategy for managing memory.")]),e._v(" "),a("h1",{attrs:{id:"garbage-collection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#garbage-collection"}},[e._v("#")]),e._v(" Garbage Collection")]),e._v(" "),a("p",[e._v("One of the most important tasks within a game engine is managing memory. Unreal’s approach to solve this problem is the usage of garbage collection. In this approach, the engine will automatically delete objects when they are no longer needed. An object is no longer needed when it is no longer referenced by any other object. More general information on garbage collection can be found here: "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Unreal uses the reflection system to drive garbage collection. Because the engine knows about your objects and properties, it can recognize when an object is no longer needed and automatically delete it.")]),e._v(" "),a("p",[e._v("While this automatic memory management does significantly reduce the mental workload to working in the engine, it is important to understand at a high level how it works, as it can only work well when you follow the “rules.” IMPORTANT: There are always exceptions to the rules, but be sure to know what you are doing if you break the rules!")]),e._v(" "),a("ul",[a("li",[e._v("Every member of a class should be declared as a UPROPERTY\n"),a("ul",[a("li",[e._v("If an member is left “naked,” unreal will not know about it. So, an object you are pointing at could get deleted out from under you! It is safe to leave value types such as an int or a bool “naked” although they could not be saved, replicated, or appear in the editor.")])])]),e._v(" "),a("li",[e._v("Member pointers should only point at UObject or UObject-derived objects\n"),a("ul",[a("li",[e._v("The garbage collector is only smart enough to recognize relationships to an object, so the object could get deleted out from under your pointer.")])])]),e._v(" "),a("li",[e._v("Any non-UObject pointer must be pointing to something “global” in the engine, or something within its own UObject\n"),a("ul",[a("li",[e._v("The garbage collector could delete the object that owns what you are pointing at.")])])]),e._v(" "),a("li",[e._v("The only container that is safe to have UObject or UObject-derived pointers in is a TArray")])]),e._v(" "),a("p",[e._v("NOTE: UObject-derived pointers/objects would be any object, component, or actor.")]),e._v(" "),a("p",[a("strong",[e._v("Remember, the garbage collector relies on reflection data!")])]),e._v(" "),a("h1",{attrs:{id:"structs-vs-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#structs-vs-objects"}},[e._v("#")]),e._v(" Structs vs. Objects")]),e._v(" "),a("p",[e._v("Structs are intended to be used as “value” types. They are best used for small bits of data that are to be reused within objects and actors. For example, FVector, FRotator, FQuat. They are not garbage collected, so they must always exist within a UObject.")]),e._v(" "),a("p",[e._v("One advantage of a UStruct is that it is very small. While a UObject must carry book-keeping data in addition to your data, UStructs (technically UScriptStructs) are only as large as the data you put in them. The garabage collector does not need to do as much work to maintain them.")]),e._v(" "),a("p",[e._v("However, UStructs do have limitations. Pointing to another object’s member struct directly is not safe.")]),e._v(" "),a("p",[e._v("UObjects are garbage-collected. While they are heavier, it is generally safe to to point at them. Bear in mind that every UObject is one more thing for the garbage collector to keep track of. Although the engine can handily deal with thousands of objects, this capability should be used carefully. If your project requires thousands of instances of something, and UStructs are acceptable, they will generally be more performant than UObjects.")]),e._v(" "),a("h1",{attrs:{id:"containers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#containers"}},[e._v("#")]),e._v(" Containers")]),e._v(" "),a("p",[e._v("For the garbage collector to do its work of determining what is safe to delete, it must traverse every field of every object. While Unreal provides several types of containers (TArray, TMap, …) the garbage collector only considers pointers in TArray")]),e._v(" "),a("h1",{attrs:{id:"see-also"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#see-also"}},[e._v("#")]),e._v(" See Also")]),e._v(" "),a("p",[e._v("Some more specifics and code examples related to memory management, see "),a("a",{attrs:{href:"/index.php?title=Garbage_Collection_%26_Dynamic_Memory_Allocation",title:"Garbage Collection & Dynamic Memory Allocation"}},[e._v("Garbage_Collection_&_Dynamic_Memory_Allocation")])]),e._v(" "),a("p",[e._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Garbage_Collection_Overview&oldid=251",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Garbage_Collection_Overview&oldid=251"),a("OutboundLink")],1),e._v('"')]),e._v(" "),a("p",[a("a",{attrs:{href:"/index.php?title=Special:Categories",title:"Special:Categories"}},[e._v("Categories")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/index.php?title=Category:Tutorials&action=edit&redlink=1",title:"Category:Tutorials (page does not exist)"}},[e._v("Tutorials")])]),e._v(" "),a("li",[a("a",{attrs:{href:"/index.php?title=Category:Community_Created_Content",title:"Category:Community Created Content"}},[e._v("Community Created Content")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);