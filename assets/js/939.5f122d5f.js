(window.webpackJsonp=window.webpackJsonp||[]).push([[939],{1459:function(t,e,a){"use strict";a.r(e);var n=a(28),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("RESTRICT, Keyword for Low-Level Pointer Efficiency - Epic Wiki")]),t._v(" "),a("h1",{attrs:{id:"restrict-keyword-for-low-level-pointer-efficiency"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restrict-keyword-for-low-level-pointer-efficiency"}},[t._v("#")]),t._v(" RESTRICT, Keyword for Low-Level Pointer Efficiency")]),t._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[t._v("#")]),t._v(" Contents")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Overview"}},[t._v("1 Overview")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Pointer_Aliasing"}},[t._v("2 Pointer Aliasing")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Unique_Memory_Strips"}},[t._v("3 Unique Memory Strips")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Pointer_Restriction"}},[t._v("4 Pointer Restriction")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#UE4_RESTRICT_Macro"}},[t._v("5 UE4 RESTRICT Macro")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#My_Own_UObject_Pointer_RESTRICT_Example"}},[t._v("6 My Own UObject Pointer RESTRICT Example")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Avoid_Aliasing_in_the_First_Place"}},[t._v("7 Avoid Aliasing in the First Place")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Network_Code"}},[t._v("8 Network Code")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Link:_Extensive_Information_on_restrict_in_C.2B.2B"}},[t._v("9 Link: Extensive Information on _restrict in C++")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Conclusion"}},[t._v("10 Conclusion")])])]),t._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),a("p",[a("em",[t._v("Original Author:")]),t._v(" "),a("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),a("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),a("p",[t._v("Dear Community,")]),t._v(" "),a("p",[t._v("In this wiki tutorial, I discuss a pointer-only optimization technique that can improve low level code involving multiple pointers that have the same data type.")]),t._v(" "),a("p",[t._v("The special keyword involved ( "),a("strong",[t._v("_restrict")]),t._v(" ) helps the compiler produce more efficient code whenever multiple pointers of the same data type are used within the same context.")]),t._v(" "),a("p",[t._v("If you search the UE4 code base you will see examples of this optimization ("),a("strong",[t._v("RESTRICT and _restrict")]),t._v(") in use!")]),t._v(" "),a("h2",{attrs:{id:"pointer-aliasing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pointer-aliasing"}},[t._v("#")]),t._v(" Pointer Aliasing")]),t._v(" "),a("p",[t._v("Pointer Aliasing means 2+ pointers are pointing to the same memory address, in the same context.")]),t._v(" "),a("p",[t._v("The compiler cannot ever assume aliasing is "),a("strong",[t._v("not")]),t._v(" occurring if multiple pointers in the same context have the same data type:")]),t._v(" "),a("p",[t._v("SomeContext\n{\nfloat* Ptr1;\nfloat* Ptr2;\nfloat* Ptr3;\n}")]),t._v(" "),a("p",[t._v("When the compiler sees 3 pointers of the same data type in the same context, it cannot assume that these pointes are not aliases of each other.")]),t._v(" "),a("p",[t._v("for example:")]),t._v(" "),a("p",[t._v("SomeContext\n{\nfloat TheData\nfloat* Ptr1 = &TheData;\nfloat* Ptr2 = &TheData;\nfloat* Ptr3 = &TheData;\nÂ \n//All 3 pointers are aliases of each other! They all point to the same data\n}")]),t._v(" "),a("h2",{attrs:{id:"unique-memory-strips"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unique-memory-strips"}},[t._v("#")]),t._v(" Unique Memory Strips")]),t._v(" "),a("p",[t._v("When 3 pointers are pointing to unique memory strips, and are not aliasing each other, the compiler could perform some optimization if it knew this was the case:")]),t._v(" "),a("p",[t._v("SomeContext\n{\nfloat Time;\nfloat Space;\nfloat Stars;\nÂ \nfloat* Ptr1 = &Time;\nfloat* Ptr2 = &Space;\nfloat* Ptr3 = &Stars;\nÂ \n//All 3 pointers point to unique memory strips, but the compiler cannot assume this\n}")]),t._v(" "),a("h2",{attrs:{id:"pointer-restriction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pointer-restriction"}},[t._v("#")]),t._v(" Pointer Restriction")]),t._v(" "),a("p",[t._v("The c++ keyword "),a("strong",[t._v("_restrict")]),t._v(" enables you to tell the compiler that you are quite positive that each of the pointers have unique access to their respective memory strips.")]),t._v(" "),a("p",[a("strong",[t._v("This keyword should only be used if you are absolutely sure that the pointers do actually have unique access to their memory location, within their context!")])]),t._v(" "),a("p",[t._v("Use of _restrict example:")]),t._v(" "),a("p",[t._v("SomeContext\n{\nfloat Time;\nfloat Space;\nfloat Stars;\nÂ \nfloat* __restrict Ptr1 = &Time;\nfloat* __restrict Ptr2 = &Space;\nfloat* __restrict Ptr3 = &Stars;\nÂ \n//All 3 pointers point to unique memory strips,\n//\tAND THE COMPILER KNOWS IT!\n//\t\tOptimization can now occur.\n}")]),t._v(" "),a("h2",{attrs:{id:"ue4-restrict-macro"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ue4-restrict-macro"}},[t._v("#")]),t._v(" UE4 RESTRICT Macro")]),t._v(" "),a("p",[t._v("If you search the code base you will find")]),t._v(" "),a("p",[t._v("#define RESTRICT _restrict")]),t._v(" "),a("p",[t._v("in a couple of placesÂ ðŸ˜ƒ")]),t._v(" "),a("p",[t._v("SomeContext\n{\nfloat Time;\nfloat Space;\nfloat Stars;\nÂ \n//The UE4 Way\nfloat* RESTRICT Ptr1 = &Time;\nfloat* RESTRICT Ptr2 = &Space;\nfloat* RESTRICT Ptr3 = &Stars;\nÂ \n//All 3 pointers point to unique memory strips,\n//\tAND THE COMPILER KNOWS IT!\n//\t\tOptimization can now occur.\n}")]),t._v(" "),a("h2",{attrs:{id:"my-own-uobject-pointer-restrict-example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#my-own-uobject-pointer-restrict-example"}},[t._v("#")]),t._v(" My Own UObject Pointer RESTRICT Example")]),t._v(" "),a("p",[t._v("In this code sample, I have two pointers of the same data type, passed into the same function context.")]),t._v(" "),a("p",[t._v("In my code below, the compiler knows that "),a("strong",[t._v("OldCharacter")]),t._v(" and "),a("em",[t._v("NewCharacter")]),t._v(" are distinct entities with distinct memory strips, and can optimize actions performed to these memory addresses.")]),t._v(" "),a("p",[t._v("void AMyPC::SwitchCharacters(\nAMyCharacter* RESTRICT OldCharacter,\nAMyCharacter* RESTRICT NewCharacter\n){\nif(!OldCharacter || !NewCharacter)\n{\nreturn;\n}\nÂ \n//Hide Old Character\nOldCharacter->SetActorHiddenInGame(true);\nÂ \n//Remove Collision Old Char\nOldCharacter->SetActorEnableCollision(false);\nÂ \n//Show New Character\nNewCharacter->SetActorHiddenInGame(false);\nÂ \nNewCharacter->SetActorEnableCollision(true);\nÂ \nNewCharacter->CharacterMovement->GravityScale = NewCharacter->VictoryGravityScale;\nÂ \n}")]),t._v(" "),a("h2",{attrs:{id:"avoid-aliasing-in-the-first-place"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#avoid-aliasing-in-the-first-place"}},[t._v("#")]),t._v(" Avoid Aliasing in the First Place")]),t._v(" "),a("p",[t._v("You can avoid needing to use the RESTRICT keyword in many places if you simply only define your pointers at the narrowest possible scope")]),t._v(" "),a("p",[t._v("//Global\nfloat TheData;\n//float* DataPtr; // not good!\n//float* DataPtr2;\n//float* DataPtr3;\nÂ \nÂ \n//function context\nSome Function\n{\n//do other stuff\nÂ \nfor loop\n{\nfloat* LocalPtr = &TheData; //pointer only exists in smallest context, no aliasing\n*LocalPtr += 5;\n}\n}\nÂ \n//function context\nSome Function2\n{\n//do other stuff\nÂ \nfor loop\n{\nfloat* LocalPtr2 = &TheData; //pointer only exists in smallest context, no aliasing\n*LocalPtr += 12;\n}\n}\nÂ \n//function context\nSome Function3\n{\n//do other stuff\nÂ \nfor loop\n{\nfloat* LocalPtr3 = &TheData; //pointer only exists in smallest context, no aliasing\n*LocalPtr += 9000;\n}\n}")]),t._v(" "),a("p",[t._v("In the above case, you can avoid a lot of aliasing concerns by not having global pointers to the same data type.")]),t._v(" "),a("p",[t._v("Instead, in each function where you need the pointer, declare it locally and only for as long as it is needed.")]),t._v(" "),a("p",[t._v("This avoids ever needing the RESTRICT keywordÂ ðŸ˜ƒ")]),t._v(" "),a("h2",{attrs:{id:"network-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#network-code"}},[t._v("#")]),t._v(" Network Code")]),t._v(" "),a("p",[t._v("RESTRICT does not currently work with Server/Client function parameters.")]),t._v(" "),a("h2",{attrs:{id:"link-extensive-information-on-restrict-in-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#link-extensive-information-on-restrict-in-c"}},[t._v("#")]),t._v(" Link: Extensive Information on _restrict in C++")]),t._v(" "),a("p",[a("strong",[a("a",{attrs:{href:"http://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Demystifying _restrict keyword"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),a("p",[t._v("Use the UE4 macro RESTRICT any time you are absolutely sure that multiple pointers of the same data type, in the same context, are always pointing to unique memory strips.")]),t._v(" "),a("p",[t._v("Doing this improves performance, especially for low level code that is writing/reading to long memory strips, like saving and loading binary arrays, image data processing, etc.")]),t._v(" "),a("p",[t._v("Enjoy!")]),t._v(" "),a("p",[a("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),a("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),a("p",[t._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=RESTRICT,_Keyword_for_Low-Level_Pointer_Efficiency&oldid=7970",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://wiki.unrealengine.com/index.php?title=RESTRICT,_Keyword_for_Low-Level_Pointer_Efficiency&oldid=7970"),a("OutboundLink")],1),t._v('"')]),t._v(" "),a("p",[a("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[t._v("Category")]),t._v(":")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[t._v("Code")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);e.default=r.exports}}]);