(window.webpackJsonp=window.webpackJsonp||[]).push([[937],{670:function(e,t,n){"use strict";n.r(t);var o=n(28),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Quest Framework - Epic Wiki")]),e._v(" "),n("h1",{attrs:{id:"quest-framework"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#quest-framework"}},[e._v("#")]),e._v(" Quest Framework")]),e._v(" "),n("p",[n("strong",[e._v("Rate this Article:")])]),e._v(" "),n("p",[e._v("5.00")]),e._v(" "),n("p",[n("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),n("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),n("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),n("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),n("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),e._v(" (2 votes)")]),e._v(" "),n("p",[e._v("Approved for Versions:4.8")]),e._v(" "),n("p",[n("a",{attrs:{href:"http://enjoy-game-programming.blogspot.com/2016/02/unreal-engine-4-quest-framework-c-part-1.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Original Content"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Lately, I have been working on a simple horror game in UE4 that has a very simple Objective system that drives the gameplay. After looking at the code, I realized it could serve as the basis of a framework for a generic questing system. Today I will share all of that code and explain each class as it pertains to the framework.")]),e._v(" "),n("p",[e._v("The following classes to get started on a simple quest framework would are AQuest and AObjective, using the UE4 naming conventions for classes. AObjective is metadata about the quest as well the actual worker when it comes to completing parts of a quest. AQuest is a container of objectives and does group management of objectives. Both classes are derived from AInfo as they are purely classes of information and do not need to have a transform or collision within the world.")]),e._v(" "),n("h2",{attrs:{id:"objectives"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#objectives"}},[e._v("#")]),e._v(" Objectives")]),e._v(" "),n("p",[e._v("Since it is the foundation for a quest, I will first layout and explain AObjective. The header of AObjective goes as follows:")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Info.h"\n#include "Objective.generated.h"\n \nUCLASS()\nclass QUESTGAME_API AObjective : public AInfo\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this actor\'s properties\nAObjective();\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "O" )\nFText Description;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "O" )\nFName ObjectiveName;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "O" )\nbool MustBeCompletedToAdvance;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "O" )\nint32 TotalProgressNeeded;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "O" )\nint32 CurrentProgress;\n \nUFUNCTION( BlueprintCallable, Category = "O" )\nvoid Update( int32 Progress );\n \nUFUNCTION( BlueprintCallable, Category = "O" )\nvirtual bool IsComplete( ) const;\n \nUFUNCTION( BlueprintCallable, Category = "O" )\nvirtual float GetProgress( ) const;\n \n \n \n};')]),e._v(" "),n("p",[e._v("Not that bad of a deal. The only responsibilities of an AObjective is to track the completion of the sub-portion of an AQuest and offer some idea of what the player must do.")]),e._v(" "),n("p",[e._v("The objective is tracked by the CurrentProgress and TotalProgressNeeded properties. Added by the supplied helper functions, Update, IsComplete, and GetProgress, we can get a reasonable amount of data about just this tiny portion of a quest. These functions give you all the functionality needed to start a questing framework for your UE4 game.")]),e._v(" "),n("p",[e._v("There is one boolean property that has not been mentioned: MustBeCompletedToAdvance. Depending on the use case, this could be used to ensure a sequential order in objectives or having required and optional objectives. I will implement it as the first in this tutorial. Only minor changes later on would be needed to use it as an indicator or optional or required quests. Or, you could just add a new property to support both.")]),e._v(" "),n("p",[e._v('There are two more properties that help us out with AObjective management: ObjectiveName and Description. ObjectiveName can be thought of as a unique identifier for the implemented AObjective. The ObjectiveName\'s purpose is for player feedback. For instance, the FText value could be (in simple string terms) "Get a rock". It is nothing specific to the game, it is only something to be used as a hint in either a UI or other visual element to let the player know that they need to do something in order to complete the objective.')]),e._v(" "),n("p",[e._v("Next, we can look at the small amount of code that is used to define AObjective.")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "QuestGame.h"\n#include "Objective.h"\n \n \n// Sets default values\nAObjective::AObjective( ) :\nDescription( ),\nObjectiveName( NAME_None ),\nTotalProgressNeeded( 1 ),\nCurrentProgress( 0 ),\nMustBeCompletedToAdvance( true )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n}\n \n// Called when the game starts or when spawned\nvoid AObjective::BeginPlay()\n{\nSuper::BeginPlay();\n}\n \n// Called every frame\nvoid AObjective::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \nvoid AObjective::Update( int32 Progress )\n{\nCurrentProgress += Progress;\n}\n \nbool AObjective::IsComplete( ) const\n{\nreturn CurrentProgress >= TotalProgressNeeded;\n}\n \nfloat AObjective::GetProgress( ) const\n{\ncheck( TotalProgressNeeded != 0 )\nreturn (float)CurrentProgress / (float)TotalProgressNeeded;\n}')]),e._v(" "),n("p",[e._v('Again, you will be hard pressed to say "that is a lot of code". Indeed, the most complex code is the division in the GetProgress function.')]),e._v(" "),n("p",[e._v("Wait, why do we call / override BeginPlay or Tick? Well, that is an extreme implementation detail. For instance, what if, while an AObjective is active, you want to tick a countdown for a time trialed AObjective.")]),e._v(" "),n("p",[e._v("For BeingPlay we could implement various other details such as activating certain items in the world, spawning enemies, and so on and so forth. You are only limited by your code skills and imagination.")]),e._v(" "),n("p",[e._v("Right, so how do we manage all of these objectives and make sure only relevant AObjectives are available? Well, we implement an AQuest class in which it acts as an AObjective manager.")]),e._v(" "),n("h2",{attrs:{id:"quests"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#quests"}},[e._v("#")]),e._v(" Quests")]),e._v(" "),n("p",[e._v("Here is the declaration of an AQuest to get you started:")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Info.h"\n#include "Quest.generated.h"\n \nUCLASS()\nclass QUESTGAME_API AQuest : public AInfo\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this actor\'s properties\nAQuest();\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \npublic:\nUPROPERTY( EditDefaultsOnly, BlueprintReadWrite, Category = "Q" )\nTArray<class AObjective*> CurrentObjectives;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadWrite, Category = "Q" )\nTArray<TSubclassOf<AObjective>> Objectives;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "Q" )\nUSoundCue* QuestStartSoundCue;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "Q" )\nFName QuestName;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "Q" )\nFText QuestStartDescription;\n \nUPROPERTY( EditDefaultsOnly, BlueprintReadOnly, Category = "Q" )\nFText QuestEndDescription;\n \nUFUNCTION( BlueprintCallable, Category = "Q" )\nbool IsQuestComplete( ) const;\n \nUFUNCTION( BlueprintCallable, Category = "Q" )\nbool CanUpdate( FName Objective );\n \nUFUNCTION( BlueprintCallable, Category = "Q" )\nvoid Update( FName Objective, int32 Progress );\n \nUFUNCTION( BlueprintCallable, Category = "Q" )\nbool TryUpdate( FName Objective, int32 Progress );\n \nUFUNCTION( BlueprintCallable, Category = "Q" )\nfloat QuestCompletion( ) const;\n \n};')]),e._v(" "),n("p",[e._v("Not much bigger that the AObjective class is it? This is because all AQuest does is wrap around a collection of AObjective's and provides some utility functions to help manage them.")]),e._v(" "),n("p",[e._v("The Objectives property is a simple way to configure an AQuest's objectives via the Blueprints Editor. And the CurrentObjectives is a collection of all live AObjective's that are configured for the given AQuest.")]),e._v(" "),n("p",[e._v("There are several user friendly properties such as a USoundCue, FName, and FText types that help give audio visual feedback to the player. For instance, when a player starts a quest, a nice sound plays - like a chime - and the QuestStartDescription text is written to the player's HUD and a journal implementation. Then, when a player completes a quest, a get is called for the QuestEndDescription property and writes it to a journal implementation. But those are all specific implementation details related to your game and is limited only by coding skills and imagination.")]),e._v(" "),n("p",[e._v("All of the functions for AQuest are wrappers to operate on collections of AObjectives to update and query for completion. All AObjectives in the AQuest are referenced and found by FName property types. This allows for updating different instances of AObjectives that are essentially the same, but differ at the data level. It also allows the removal of managing pointers. As another argument, it decouples knowledge of what an AObjective object is from other classes, so completing quests via other class implementations only requires the knowledge of an AQuest - or the container for the AQuest - object and default types supplied by the engine such as int32 and FName.")]),e._v(" "),n("p",[e._v("How does this all work, well, just like before, here is the definition of AQuest:")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "QuestGame.h"\n#include "Objective.h"\n#include "Quest.h"\n \n \nAQuest::AQuest() :\nQuestName( NAME_None ),\nCurrentObjectives( ),\nQuestStartDescription( ),\nQuestEndDescription( )\n{\n}\n \nvoid AQuest::BeginPlay()\n{\nSuper::BeginPlay();\nUWorld* World = GetWorld();\nif ( World )\n{\nfor ( auto Objective : Objectives )\n{\nCurrentObjectives.Add(World->SpawnActor(Objective));\n}\n}\n}\n \n// Called every frame\nvoid AQuest::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \nbool AQuest::IsQuestComplete() const\n{\nbool result = true;\nfor ( auto Objective : CurrentObjectives )\n{\nresult &= Objective->IsComplete();\n}\nreturn result;\n}\n \nbool AQuest::CanUpdate( FName Objective )\n{\nbool PreviousIsComplete = true;\nfor ( auto Obj : CurrentObjectives )\n{\nif ( PreviousIsComplete )\n{\nif ( Objective == Obj->ObjectiveName )\nreturn true;\nelse\nPreviousIsComplete = Obj->IsComplete() |\n!Obj->MustBeCompletedToAdvance;\n}\nelse\n{\nreturn false;\n}\n}\nreturn true;\n}\n \nvoid AQuest::Update( FName Objective, int32 Progress )\n{\nfor ( auto Obj : CurrentObjectives )\n{\nif ( Obj->ObjectiveName == Objective )\n{\nObj->Update( Progress );\nreturn;\n}\n}\n}\n \nbool AQuest::TryUpdate( FName Objective, int32 Progress )\n{\nbool result = CanUpdate( Objective );\nif ( result )\n{\nUpdate( Objective, Progress );\n}\nreturn result;\n}\n \nfloat AQuest::QuestCompletion( ) const\n{\nint32 NumObjectives = CurrentObjectives.Num( );\nif( NumObjectives == 0 ) return 1.0f;\n \nfloat AggregateCompletion = 0.0f;\nfor( auto Objective : CurrentObjectives )\n{\nAggregateCompletion += Objective->GetProgress( );\n}\nreturn AggregateCompletion / (float)NumObjectives;\n}')]),e._v(" "),n("p",[e._v("Probably the most complex code out of all of this is the CanUpdate method. It checks to see, sequentially (so order of AObjective configuration matters), if an AObjective is completed and if it is required to complete any other AObjectives after it. This is where the bitwise OR comes in. So basicly, we cannot advance to the requested AObjective if any of the previous AObjectives are not complete and are set to MustBeCompletedToAdvance (or as the listeral code says you CAN advance if the previous AObjective IS complete OR it does not required to be completed in order to advance).")]),e._v(" "),n("p",[e._v("The IsComplete function is just and aggregate check to see if all AObjectives are complete - defining a completed AQuest. The QuestCompletion method is a simple averaging of all AObjective completion percentages.")]),e._v(" "),n("p",[e._v("Also, the AQuest class has a simple function to wrap up the CanUpdate and Update calls into one neat little function called TryUpdate. This allows a check for the ability to update before applying the requested progress update and returns an indicator of success or failure. This is useful when code outside of AQuest wants to attempt AObjective updates without caring about much else.")]),e._v(" "),n("p",[e._v("Finally, for the same reason of AObjective's BeginPlay and Tick functions, AQuest also overrides these to allow your coding skills and imagination to fly.")]),e._v(" "),n("p",[e._v("Hopefully, this was a good introduction into the groundwork of designing a questing framework for your Unreal Engine 4 game. If you did enjoy it, comment or like it. If there is enough interest I will continue on-wards with Part II: Nesting Quests and Objectives. That part will be a tutorial just like this, with full code samples, explaining how to structure the framework to nest multiple AObjectives into an AObjective to create a structure of sub-objectives as well as the same pattern applied to AQuest to supply sub-quests.")]),e._v(" "),n("p",[e._v('Retrieved from "'),n("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Quest_Framework&oldid=19141",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Quest_Framework&oldid=19141"),n("OutboundLink")],1),e._v('"')]),e._v(" "),n("p",[n("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Categories")]),e._v(":")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"/Category:Templates",title:"Category:Templates"}},[e._v("Templates")])]),e._v(" "),n("li",[n("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])]),e._v(" "),n("li",[n("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])]),e._v(" "),n("li",[n("a",{attrs:{href:"/Category:Community_Created_Content",title:"Category:Community Created Content"}},[e._v("Community Created Content")])])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=a.exports}}]);