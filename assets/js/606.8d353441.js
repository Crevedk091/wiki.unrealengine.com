(window.webpackJsonp=window.webpackJsonp||[]).push([[606],{739:function(e,t,r){"use strict";r.r(t);var a=r(28),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Interfaces in C++ - Epic Wiki")]),e._v(" "),r("h1",{attrs:{id:"interfaces-in-c"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interfaces-in-c"}},[e._v("#")]),e._v(" Interfaces in C++")]),e._v(" "),r("p",[e._v("From Epic Wiki")]),e._v(" "),r("p",[e._v("(Redirected from "),r("a",{attrs:{href:"/index.php?title=Interfaces_in_UE4_C%2B%2B&redirect=no",title:"Interfaces in UE4 C++"}},[e._v("Interfaces in UE4 C++")]),e._v(")")]),e._v(" "),r("p",[e._v("Jump to: "),r("a",{attrs:{href:"#mw-navigation"}},[e._v("navigation")]),e._v(", "),r("a",{attrs:{href:"#p-search"}},[e._v("search")])]),e._v(" "),r("p",[r("strong",[e._v("Rate this Article:")])]),e._v(" "),r("p",[e._v("3.00")]),e._v(" "),r("p",[r("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}}),e._v(" (one vote)")]),e._v(" "),r("p",[e._v("Approved for Versions:(please verify)")]),e._v(" "),r("h2",{attrs:{id:"contents"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#The_Interface"}},[e._v("2 The Interface")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#IToStringInterface::"}},[e._v("2.1 IToStringInterface::")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Multiple_Class_Inheritance"}},[e._v("3 Multiple Class Inheritance")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#InterfaceCast"}},[e._v("4 InterfaceCast")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Determining_If_a_Given_Actor_Has_The_Interface"}},[e._v("4.1 Determining If a Given Actor Has The Interface")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#The_Magic_of_InterfaceCast_and_UE4_C.2B.2B_Interfaces"}},[e._v("4.2 The Magic of InterfaceCast and UE4 C++ Interfaces")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Creating_Global_Events"}},[e._v("5 Creating Global Events")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Object_Iterator_Vs_Actor_Iterator"}},[e._v("5.1 Object Iterator Vs Actor Iterator")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Object_Iterator_to_Trigger_Global_Event"}},[e._v("5.2 Object Iterator to Trigger Global Event")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Actor_Iterator_to_Trigger_Global_Event"}},[e._v("5.3 Actor Iterator to Trigger Global Event")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Minimizing_Iterator_Time"}},[e._v("5.4 Minimizing Iterator Time")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Narrowed_Actor_Iterator_Search"}},[e._v("6 Narrowed Actor Iterator Search")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Narrowed_Object_Iterator_Search"}},[e._v("7 Narrowed Object Iterator Search")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Summary"}},[e._v("8 Summary")])])]),e._v(" "),r("h2",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),r("p",[r("em",[e._v("Original Author")]),e._v(" "),r("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[e._v("Rama")]),e._v(" ("),r("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[e._v("talk")]),e._v(")")]),e._v(" "),r("p",[e._v("Dear Community,")]),e._v(" "),r("p",[e._v("Here's a tutorial on using "),r("strong",[e._v("UE4 C++ Interfaces")]),e._v(" to trigger global custom game events directly in C++ or via the level blueprint (or anywhere really).")]),e._v(" "),r("p",[e._v("This tutorial enables you to have a custom event like TheSunReachedHighNoon, and have a bunch of actors respond to this event differently, each with their own implementation of the event.")]),e._v(" "),r("p",[e._v("So flowers could override TheSunReachedHighNoon to open blossoms completely,")]),e._v(" "),r("p",[e._v("frogs could use override TheSunReachedHighNoon to hide under rocks")]),e._v(" "),r("p",[e._v("etc etc")]),e._v(" "),r("p",[e._v("And you can trigger the event via a blueprintcallable function used in a static blueprint library if you want!")]),e._v(" "),r("p",[e._v("This means you can trigger global actor events from your level blueprint and ask actors to do specific things,")]),e._v(" "),r("p",[e._v("without having to iterate over the actors in the level blueprint itself.")]),e._v(" "),r("p",[e._v("I also show you how you can "),r("strong",[e._v("easily determine whether any given actor has the interface or not.")])]),e._v(" "),r("h2",{attrs:{id:"the-interface"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#the-interface"}},[e._v("#")]),e._v(" The Interface")]),e._v(" "),r("p",[e._v("As a really simple example, I wrote a ToString() interface.")]),e._v(" "),r("p",[e._v("I will discuss how to turn this into a global event below.")]),e._v(" "),r("p",[e._v("In the overall theme of making a global event you'd replace ToString() with TheSunReachedHighNoon()")]),e._v(" "),r("p",[e._v("but to make sure you can actually test the code I am using ToString() instead.")]),e._v(" "),r("p",[e._v(".h")]),e._v(" "),r("p",[e._v('// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\nÂ \n#pragma once\nÂ \n#include "ToStringInterface.generated.h"\nÂ \n/** Class needed to support InterfaceCast'),r("IToStringInterface",[e._v("(Object) */\nUINTERFACE(MinimalAPI)\nclass UToStringInterface : public UInterface\n{\nGENERATED_UINTERFACE_BODY()\n};\nÂ \nclass IToStringInterface\n{\nGENERATED_IINTERFACE_BODY()\nÂ \nvirtual FString ToString();\n};")])],1),e._v(" "),r("p",[e._v(".cpp")]),e._v(" "),r("p",[e._v('// Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.\nÂ \n#include "VictoryGame.h"\nÂ \n//////////////////////////////////////////////////////////////////////////\n// ToStringInterface\nÂ \nUToStringInterface::UToStringInterface(const class FPostConstructInitializeProperties& PCIP)\n: Super(PCIP)\n{\nÂ \n}\nÂ \n//This is required for compiling, would also let you know if somehow you called\n//the base event/function rather than the over-rided version\nFString IToStringInterface::ToString()\n{\nreturn "IToStringInterface::ToString()";\n}')]),e._v(" "),r("h3",{attrs:{id:"itostringinterface"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#itostringinterface"}},[e._v("#")]),e._v(" IToStringInterface::")]),e._v(" "),r("p",[e._v("note that it is IToStringInterface::ToString(), not UToStringInterface::ToString()")]),e._v(" "),r("h2",{attrs:{id:"multiple-class-inheritance"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#multiple-class-inheritance"}},[e._v("#")]),e._v(" Multiple Class Inheritance")]),e._v(" "),r("p",[e._v("You have to use "),r("strong",[e._v("multiple inheritance")]),e._v(", and only the IToStringInterface part.")]),e._v(" "),r("p",[e._v("The first inherited class will be anything you want, relative to your project, I just used ASkeletalMeshActor as an example.")]),e._v(" "),r("p",[e._v(".h")]),e._v(" "),r("p",[e._v("UCLASS(placeable)\nclass AFlower : public ASkeletalMeshActor,  public IToStringInterface\n{\nGENERATED_UCLASS_BODY()\nÂ \nFLinearColor FlowerColor;\nÂ \nFVector FlowerScale3D;\nÂ \nvoid OpenBlossom();\nvoid CloseUpForTheNight();\nÂ \n//IToStringInterface\npublic:\nÂ \nvirtual FString ToString() OVERRIDE;\nÂ \n};")]),e._v(" "),r("p",[e._v(".cpp")]),e._v(" "),r("p",[e._v('//other flower code\nÂ \n//IToStringInterface\nFString AFlower::ToString()\n{\nreturn "Flower!";\n}')]),e._v(" "),r("p",[e._v("Any number of classes can implement this Event now, using similar format")]),e._v(" "),r("p",[e._v(".h")]),e._v(" "),r("p",[e._v("UCLASS(placeable)\nclass AFrog : public ACharacter,  public IToStringInterface\n{\nGENERATED_UCLASS_BODY()\nÂ \nFLinearColor FrogBaseColor;\nÂ \nFVector FrogScale3D;\nÂ \nvoid HopAround();\nvoid HideUnderRockCauseSunIsTooHot();\nÂ \n//IToStringInterface\npublic:\nÂ \nvirtual FString ToString() OVERRIDE;\nÂ \n};")]),e._v(" "),r("p",[e._v(".cpp")]),e._v(" "),r("p",[e._v('//other Frog code\nÂ \n//IToStringInterface\nFString AFrog::ToString()\n{\nreturn "Frog!!!!";\n}')]),e._v(" "),r("h2",{attrs:{id:"interfacecast"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interfacecast"}},[e._v("#")]),e._v(" InterfaceCast")]),e._v(" "),r("h3",{attrs:{id:"determining-if-a-given-actor-has-the-interface"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#determining-if-a-given-actor-has-the-interface"}},[e._v("#")]),e._v(" Determining If a Given Actor Has The Interface")]),e._v(" "),r("p",[r("strong",[e._v("NOTE: Using C++ interfaces in Blueprint objects requires a different approach. "),r("a",{attrs:{href:"https://wiki.unrealengine.com/Interfaces_And_Blueprints",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/Interfaces_And_Blueprints"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("You use InterfaceCast to determine if a object is using your interface, if it returns NULL then the object is not using it.")]),e._v(" "),r("p",[e._v("If the InterfaceCast returns your Interface type, then calling it's function will use the subclassed version specific to the object you called it on.")]),e._v(" "),r("p",[e._v("See below for what I mean, it's really really cool actuallyÂ ðŸ˜ƒ")]),e._v(" "),r("p",[e._v('//Example: somewhere in your Player Controller class code you have instances of a frog and a flower and a tree\nÂ \n//spawned and set somewhere in player controller code (for use of ClientMessage)\n//can really do this anywhere you want, this is just a test you can easily do\nAFrog* MyFrog;\nAFlower* MyFlower;\nATree* HappyTree;\nÂ \n//....\nÂ \n//Check Frog\nIToStringInterface* TheInterface = InterfaceCast<IToStringInterface>(MyFrog);\nÂ \nif(TheInterface)\n{\nClientMessage("Frog Uses Interface");\nClientMessage(TheInterface->ToString());\n}\nÂ \n//Check Flower\nTheInterface = InterfaceCast<IToStringInterface>(MyFlower);\nÂ \nif(TheInterface)\n{\nClientMessage("Flower Uses Interface");\nClientMessage(TheInterface->ToString());\n}\nÂ \n//Check HappyTree\nTheInterface = InterfaceCast<IToStringInterface>(HappyTree);\nÂ \nif(TheInterface)\n{\nClientMessage("Flower Uses Interface");\nClientMessage(TheInterface->ToString());\n}\nelse ClientMessage("HappyTree Does Not Use Interface");\nÂ \n//end of code segment')]),e._v(" "),r("h3",{attrs:{id:"the-magic-of-interfacecast-and-ue4-c-interfaces"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#the-magic-of-interfacecast-and-ue4-c-interfaces"}},[e._v("#")]),e._v(" The Magic of InterfaceCast and UE4 C++ Interfaces")]),e._v(" "),r("p",[e._v("From the above code you can see that I am always calling")]),e._v(" "),r("p",[e._v("TheInterface->ToString()")]),e._v(" "),r("p",[e._v("and the type of TheInterface never changes, it is always IToStringInterface* and I only create it once at the very top.")]),e._v(" "),r("p",[e._v("So why would calling")]),e._v(" "),r("p",[e._v("TheInterface->ToString()")]),e._v(" "),r("p",[e._v("produce different results for each use of TheInterface with different Objects?")]),e._v(" "),r("p",[e._v('Because C++ fundamentals include a feature called "polymorphism", that\'s whyÂ ðŸ˜ƒ')]),e._v(" "),r("p",[e._v("InterfaceCasting each type of object returns the subclassed version of the ToString() function!")]),e._v(" "),r("h2",{attrs:{id:"creating-global-events"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#creating-global-events"}},[e._v("#")]),e._v(" Creating Global Events")]),e._v(" "),r("p",[e._v("Now you have all the tools you need to create a global event!")]),e._v(" "),r("p",[e._v("Whenever you want to create a global event, simply")]),e._v(" "),r("p",[e._v("1. iterate over all actors in the world")]),e._v(" "),r("p",[e._v("2. check if that actor implements your custom event interface")]),e._v(" "),r("p",[e._v("3. run the custom event for that actor.")]),e._v(" "),r("h3",{attrs:{id:"object-iterator-vs-actor-iterator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-iterator-vs-actor-iterator"}},[e._v("#")]),e._v(" Object Iterator Vs Actor Iterator")]),e._v(" "),r("p",[e._v("If you are wanting to use a blueprintcallable function in a custom blueprint library,")]),e._v(" "),r("p",[e._v("you must use the Object Iterator, not the Actor Iterator, since static classes can't use GetWorld() (as far as I know)")]),e._v(" "),r("h3",{attrs:{id:"object-iterator-to-trigger-global-event"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#object-iterator-to-trigger-global-event"}},[e._v("#")]),e._v(" Object Iterator to Trigger Global Event")]),e._v(" "),r("p",[e._v("You can use this anywhere, but in PIE it will detect objects in the pre-PIE world as well as the game world, in an unspecified order.")]),e._v(" "),r("p",[e._v("IToStringInterface* TheInterface = NULL;\nfor ( TObjectIterator<AActor> It; It; ++It )\n{\n//Try InterFaceCasting\nTheInterface = InterfaceCast<IToStringInterface>(*It);\nÂ \n//Run the Event specific to the actor, if the actor has the interface\nif(TheInterface) ClientMessage(TheInterface->ToString());\n}")]),e._v(" "),r("p",[e._v('Again in this simple case, the "Event" is just the ToString() function, but I wanted something you could try out before doing fancier things and get fast feedback via ClientMessage in as non-project-specific a way as possible')]),e._v(" "),r("h3",{attrs:{id:"actor-iterator-to-trigger-global-event"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#actor-iterator-to-trigger-global-event"}},[e._v("#")]),e._v(" Actor Iterator to Trigger Global Event")]),e._v(" "),r("p",[e._v("If you dont need to trigger the event from a static function in a blueprint library,")]),e._v(" "),r("p",[e._v("and can call the function with a blueprintcallable or regular function somewhere else in an Actor class.")]),e._v(" "),r("p",[e._v("Then you can use the actor iterator (My personal favorite!)")]),e._v(" "),r("p",[e._v("IToStringInterface* TheInterface = NULL;\nTActorIterator< AActor > ActorItr(GetWorld());\nwhile (ActorItr)\n{\n//Try InterFaceCasting\nTheInterface = InterfaceCast<IToStringInterface>(*ActorItr);\nÂ \n//Run the Event specific to the actor, if the actor has the interface\nif(TheInterface) ClientMessage(TheInterface->ToString());\nÂ \n//\n++ActorItr;  //dont forget this or game will hang due to while loop\n//could use a for loop instead\n}")]),e._v(" "),r("h3",{attrs:{id:"minimizing-iterator-time"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#minimizing-iterator-time"}},[e._v("#")]),e._v(" Minimizing Iterator Time")]),e._v(" "),r("p",[e._v("If you know only certain subclasses of Actor have any chance of using your event")]),e._v(" "),r("p",[e._v("like only StaticMeshActors or only Characters, than you can specify a different class for the Actor or Object Iterator")]),e._v(" "),r("h2",{attrs:{id:"narrowed-actor-iterator-search"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#narrowed-actor-iterator-search"}},[e._v("#")]),e._v(" Narrowed Actor Iterator Search")]),e._v(" "),r("p",[e._v("IToStringInterface* TheInterface = NULL;\nTActorIterator< AStaticMeshActor > ActorItr(GetWorld());\nwhile (ActorItr)\n{\n//Try InterFaceCasting\nTheInterface = InterfaceCast<IToStringInterface>(*ActorItr);\nÂ \n//Run the Event specific to the actor, if the actor has the interface\nif(TheInterface) ClientMessage(TheInterface->ToString());\nÂ \n//\n++ActorItr;  //dont forget this or game will hang due to while loop\n//could use a for loop instead\n}")]),e._v(" "),r("h2",{attrs:{id:"narrowed-object-iterator-search"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#narrowed-object-iterator-search"}},[e._v("#")]),e._v(" Narrowed Object Iterator Search")]),e._v(" "),r("p",[e._v("(You can use this anywhere, but in PIE it will detect all sorts of things)")]),e._v(" "),r("p",[e._v("IToStringInterface* TheInterface = NULL;\nfor ( TObjectIterator<ACharacter> It; It; ++It )\n{\n//Try InterFaceCasting\nTheInterface = InterfaceCast<IToStringInterface>(*It);\nÂ \n//Run the Event specific to the actor, if the actor has the interface\nif(TheInterface) ClientMessage(TheInterface->ToString());\n}")]),e._v(" "),r("h2",{attrs:{id:"summary"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),r("p",[e._v("Now you can trigger global events that only certain actors will respond to, and you can have each actor respond in their own unique way, while keeping the code very simple!")]),e._v(" "),r("p",[e._v("Yay!")]),e._v(" "),r("p",[r("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[e._v("Rama")]),e._v(" ("),r("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[e._v("talk")]),e._v(")")]),e._v(" "),r("p",[e._v('Retrieved from "'),r("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Interfaces_in_C%2B%2B&oldid=8283",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Interfaces_in_C%2B%2B&oldid=8283"),r("OutboundLink")],1),e._v('"')]),e._v(" "),r("p",[r("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Categories")]),e._v(":")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])]),e._v(" "),r("li",[r("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])]),e._v(" "),r("li",[r("a",{attrs:{href:"/Category:Community_Created_Content",title:"Category:Community Created Content"}},[e._v("Community Created Content")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);