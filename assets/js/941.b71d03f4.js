(window.webpackJsonp=window.webpackJsonp||[]).push([[941],{664:function(e,a,n){"use strict";n.r(a);var t=n(28),o=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("RTS Camera - Epic Wiki")]),e._v(" "),n("h1",{attrs:{id:"rts-camera"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rts-camera"}},[e._v("#")]),e._v(" RTS Camera")]),e._v(" "),n("h2",{attrs:{id:"contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#RTS_Camera_Code"}},[e._v("1 RTS Camera Code")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Details"}},[e._v("2 Details")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#FESpectatorPawn.h"}},[e._v("3 FESpectatorPawn.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#FESpectatorPawn.cpp"}},[e._v("4 FESpectatorPawn.cpp")])])]),e._v(" "),n("h2",{attrs:{id:"rts-camera-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rts-camera-code"}},[e._v("#")]),e._v(" RTS Camera Code")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:RTSCamera.png"}},[n("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/e/ea/RTSCamera.png",alt:"RTSCamera.png"}})])]),e._v(" "),n("h1",{attrs:{id:"details"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#details"}},[e._v("#")]),e._v(" Details")]),e._v(" "),n("p",[e._v("I will add more details to this page when I have time, just thought I would share my code for an RTS Camera for those of you who need a place to start! Let me know if you have any questions or suggestions to improve my code! The cursor is not locked into the viewport, I am still looking for a way to do this.")]),e._v(" "),n("p",[e._v("Also, for zooming with the mouse wheel, add the inputs for mouse wheel up and down with the names:")]),e._v(" "),n("p",[e._v("WheelMouseUp")]),e._v(" "),n("p",[e._v("WheelMouseDown")]),e._v(" "),n("p",[e._v("Hope this helps!")]),e._v(" "),n("p",[e._v("Connor Brewster")]),e._v(" "),n("h1",{attrs:{id:"fespectatorpawn-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fespectatorpawn-h"}},[e._v("#")]),e._v(" FESpectatorPawn.h")]),e._v(" "),n("p",[e._v('#pragma once\n \n#include "GameFramework/SpectatorPawn.h"\n#include "FESpectatorPawn.generated.h"\n \n/** AFESpectatorPawn\n* This Pawn Will Move Like An RTS Camera\n*/\nUCLASS()\nclass FE_API AFESpectatorPawn : public ASpectatorPawn\n{\nGENERATED_UCLASS_BODY()\n \npublic:\n/** Camera Component */\nUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera)\nTSubobjectPtr<class UCameraComponent> CameraComponent;\n \n/** Camera Z Angle */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraZAnlge;\n \n/** Camera Radius From Pawn Position */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraRadius;\n \n/** Camera Height Angle */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraHeightAngle;\n \n/** Camera Zoom Speed */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraZoomSpeed;\n \n/** Camera Radius Max */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraRadiusMax;\n \n/** Camera Radius Min */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraRadiusMin;\n \n/** Camera Movement Speed */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraMovementSpeed;\n \n/** Camera Scroll Boundary */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nfloat CameraScrollBoundary;\n \n/** Should the camera move? */\nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera)\nbool bCanMoveCamera;\n \nprivate:\n/** Sets up player inputs\n*    @param InputComponent - Input Component\n*/\nvoid SetupPlayerInputComponent(class UInputComponent* InputComponent);\n \npublic:\n/** Zooms In The Camera */\nUFUNCTION()\nvoid ZoomIn();\n \n/** Zooms Out The Camera */\nUFUNCTION()\nvoid ZoomOut();\n \n/** Gets the roatation of the camera with only the yaw value\n* @return - returns a rotator that is (0, yaw, 0) of the Camera\n*/\nUFUNCTION()\nFRotator GetIsolatedCameraYaw();\n \n/** Moves the camera forward\n* @param direcation - (1.0 for forward, -1.0 for backward)\n*/\nUFUNCTION()\nvoid MoveCameraForward(float direction);\n \n/** Moves the camera forward\n* @param direcation - (1.0 for right, -1.0 for left)\n*/\nUFUNCTION()\nvoid MoveCameraRight(float direction);\n \n/** Repositions The Camera */\nUFUNCTION()\nvoid RepositionCamera();\n \n/** Tick Function, Called Every Frame */\nUFUNCTION()\nvirtual void Tick(float deltaSeconds) override;\n};')]),e._v(" "),n("h1",{attrs:{id:"fespectatorpawn-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fespectatorpawn-cpp"}},[e._v("#")]),e._v(" FESpectatorPawn.cpp")]),e._v(" "),n("p",[e._v('#include "FE.h"\n#include "FESpectatorPawn.h"\n \n \nAFESpectatorPawn::AFESpectatorPawn(const class FPostConstructInitializeProperties& PCIP)\n: Super(PCIP)\n{\n//Disable Standard WASD Movement\nbAddDefaultMovementBindings = false;\n \n//Set Default Camera Values\nCameraRadius = 1000.0f;\nCameraZAnlge = 0.0f;\nCameraHeightAngle = 70.0f;\nCameraZoomSpeed = 32.0f;\nCameraRadiusMin = 750.0f;\nCameraRadiusMax = 2000.0f;\nCameraMovementSpeed = 2000.0f;\nCameraScrollBoundary = 25.0f;\n//TODO: While selecting units, the camera CANNOT move!\nbCanMoveCamera = true;\n \n//Intialize The Camera\nCameraComponent = PCIP.CreateDefaultSubobject<UCameraComponent>(this, TEXT("RTS Camera"));\nCameraComponent->AttachParent = this->GetRootComponent();\nCameraComponent->bUsePawnControlRotation = false;\nRepositionCamera();\n \n//Enable Tick function\nPrimaryActorTick.bCanEverTick = true;\n}\n \nvoid AFESpectatorPawn::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\ncheck(InputComponent);\n \n//Bind Mouse Wheel Zooming Actions\nInputComponent->BindAction("WheelMouseUp", IE_Pressed, this, &AFESpectatorPawn::ZoomIn);\nInputComponent->BindAction("WheelMouseDown", IE_Pressed, this, &AFESpectatorPawn::ZoomOut);\n \n//Bind WASD Movement\n//FOR TESTING PURPOSES ONLY!!!\n//InputComponent->BindAxis("MoveForward", this, &AFESpectatorPawn::MoveCameraForward);\n//InputComponent->BindAxis("MoveRight", this, &AFESpectatorPawn::MoveCameraRight);\n}\n \nvoid AFESpectatorPawn::ZoomIn()\n{\n//Don\'t execute any further if the camera can\'t move\nif (!bCanMoveCamera)\nreturn;\n \n//Decrease the CameraRadius but clamp it between the min and max radii\nCameraRadius = FMath::Clamp(CameraRadius - CameraZoomSpeed, CameraRadiusMin, CameraRadiusMax);\n \n//Reposition the camera in the local space\nRepositionCamera();\n}\n \nvoid AFESpectatorPawn::ZoomOut()\n{\n//Don\'t execute any further if the camera can\'t move\nif (!bCanMoveCamera)\nreturn;\n \n//Increase the CameraRadius but clamp it between the min and max radii\nCameraRadius = FMath::Clamp(CameraRadius + CameraZoomSpeed, CameraRadiusMin, CameraRadiusMax);\n \n//Reposition the camera in the local space\nRepositionCamera();\n}\n \nFRotator AFESpectatorPawn::GetIsolatedCameraYaw()\n{\n//Return a FRotator containing (0, CameraYaw, 0)\nreturn FRotator(0.0f, CameraComponent->ComponentToWorld.Rotator().Yaw, 0.0f);\n}\n \nvoid AFESpectatorPawn::MoveCameraForward(float direction)\n{\n//Don\'t execute any further if the camera can\'t move\nif (!bCanMoveCamera)\nreturn;\n \n//Calculate how much to move the camera by\nfloat movementValue = direction * CameraMovementSpeed;\n \n//Create a delta vector that moves by the movementValue in the direction of the camera\'s yaw\nFVector deltaMovement = movementValue * GetIsolatedCameraYaw().Vector();\n \n//Add the delta to a new vector\nFVector newLocation = this->GetActorLocation() + deltaMovement;\n \n//Set the new location of the pawn\nSetActorLocation(newLocation);\n}\n \nvoid AFESpectatorPawn::MoveCameraRight(float direction)\n{\n//Don\'t execute any further if the camera can\'t move\nif (!bCanMoveCamera)\nreturn;\n \n//Calculate how much to move the camera by\nfloat movementValue = direction * CameraMovementSpeed;\n \n//Create a delta vector that moves by the movementValue in the direction of the right of the camera\'s yaw\nFVector deltaMovement = movementValue * (FRotator(0.0f,90.0f,0.0f) + GetIsolatedCameraYaw()).Vector();\n \n//Add the delta to a new vector\nFVector newLocation = this->GetActorLocation() + deltaMovement;\n \n//Set the new location of the pawn\nSetActorLocation(newLocation);\n}\n \nvoid AFESpectatorPawn::RepositionCamera()\n{\n//Create variables to hold the new values\nFVector newLocation(0.0f, 0.0f, 0.0f);\nFRotator newRotation(0.0f, 0.0f, 0.0f);\n \n//Find Cos and Sin of the Camera Z Angle\nfloat sinCameraZAngle = FMath::Sin(FMath::DegreesToRadians(CameraZAnlge));\nfloat cosCameraZAngle = FMath::Cos(FMath::DegreesToRadians(CameraZAnlge));\n \n//Find the Cos and Sin of the Camera Height Angle\nfloat sinCameraHeightAngle = FMath::Sin(FMath::DegreesToRadians(CameraHeightAngle));\nfloat cosCameraHeightAngle = FMath::Cos(FMath::DegreesToRadians(CameraHeightAngle));\n \n//Set newLocation X to cosCameraZAngle * sinCameraHeightAngle * CameraRadius\nnewLocation.X = cosCameraZAngle * cosCameraHeightAngle * CameraRadius;\n \n//Set newLocation Y to sinCameraZangle * sinCameraHeightAngle * CameraRadius\nnewLocation.Y = sinCameraZAngle * cosCameraHeightAngle * CameraRadius;\n \n//Set newLocation Z to cosCameraHeightAngle * CameraRadius\nnewLocation.Z = sinCameraHeightAngle * CameraRadius;\n \n//Set the new rotations\nnewRotation = (FVector(0.0f,0.0f,0.0f) - newLocation).Rotation();\n \n \n//Set the camera\'s location and rotation to the new values\nCameraComponent->SetRelativeLocation(newLocation);\nCameraComponent->SetRelativeRotation(newRotation);\n}\n \nvoid AFESpectatorPawn::Tick(float deltaSeconds)\n{\nSuper::Tick(deltaSeconds);\n \n//Create variables to hold mouse position and screen size\nFVector2D mousePosition;\nFVector2D viewportSize;\n \n//Get mouse position and screen size\nUGameViewportClient* gameViewport = GEngine->GameViewport;\n \n//Make sure viewport exists\ncheck(gameViewport);\ngameViewport->GetViewportSize(viewportSize);\n \n//Make sure the viewport has focus(contains the mouse)\nif (gameViewport->IsFocused(gameViewport->Viewport) && gameViewport->GetMousePosition(mousePosition) && bCanMoveCamera)\n{\n//Check if the mouse is at the left or right edge of the screen and move accordingly\nif (mousePosition.X < CameraScrollBoundary)\n{\nMoveCameraRight(-1.0f * deltaSeconds);\n}\nelse if (viewportSize.X - mousePosition.X < CameraScrollBoundary)\n{\nMoveCameraRight(1.0f * deltaSeconds);\n}\n \n//Check if the mouse is at the top or bottom edge of the screen and move accordingly\nif (mousePosition.Y < CameraScrollBoundary)\n{\nMoveCameraForward(1.0f * deltaSeconds);\n}\nelse if (viewportSize.Y - mousePosition.Y < CameraScrollBoundary)\n{\nMoveCameraForward(-1.0f * deltaSeconds);\n}\n}\n}')]),e._v(" "),n("p",[e._v('Retrieved from "'),n("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=RTS_Camera&oldid=9763",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=RTS_Camera&oldid=9763"),n("OutboundLink")],1),e._v('"')]),e._v(" "),n("p",[n("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);a.default=o.exports}}]);