(window.webpackJsonp=window.webpackJsonp||[]).push([[570],{760:function(e,t,a){"use strict";a.r(t);var n=a(28),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("How To Make C++ Interfaces Implementable By Blueprints(Tutorial) - Epic Wiki")]),e._v(" "),a("h1",{attrs:{id:"how-to-make-c-interfaces-implementable-by-blueprints-tutorial"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-make-c-interfaces-implementable-by-blueprints-tutorial"}},[e._v("#")]),e._v(" How To Make C++ Interfaces Implementable By Blueprints(Tutorial)")]),e._v(" "),a("p",[a("strong",[e._v("Rate this Tutorial:")])]),e._v(" "),a("p",[e._v("5.00")]),e._v(" "),a("p",[a("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),a("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),a("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),a("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),a("img",{attrs:{src:"/extensions/VoteNY/images/star_on.gif",alt:""}}),e._v(" (one vote)")]),e._v(" "),a("p",[e._v("Approved for Versions:4.10")]),e._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Getting_Started"}},[e._v("2 Getting Started")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#How_to_implement_an_Interface"}},[e._v("2.1 How to implement an Interface")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Creating_an_Actor_which_inherits_from_this_Interface"}},[e._v("2.2 Creating an Actor which inherits from this Interface")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Let_it_grow"}},[e._v("2.3 Let it grow")])])])])]),e._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),a("p",[e._v("Hello Ladies and Gentlemen,")]),e._v(" "),a("p",[e._v("I recently came to the conclusion that it is a bit tricky to make C++ Interfaces also implementable by Blueprints. Because of the lack of Information I could get from the Search Engine I used, I had to gather all this knowledge little by little. So lets beginÂ ðŸ˜ƒ")]),e._v(" "),a("h2",{attrs:{id:"getting-started"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getting-started"}},[e._v("#")]),e._v(" Getting Started")]),e._v(" "),a("p",[e._v("At first we have to implement our Interface: Unreal Engine has a special way to handle Interfaces so this part was a bit confusing at first. But in the End it was all clear (for me >_>)")]),e._v(" "),a("p",[e._v("I assume that you know how to do basic stuff like creating projects and new c++ classes etc.")]),e._v(" "),a("h3",{attrs:{id:"how-to-implement-an-interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-implement-an-interface"}},[e._v("#")]),e._v(" How to implement an Interface")]),e._v(" "),a("p",[e._v('Our first step is to create a new C++ Class and let it inherit from our beloved Base Class UObject. Unfortunately one cannot simply inherit from UInterface directly so we have to do it ourselves. Lets call the Interface "Lookable".')]),e._v(" "),a("p",[e._v("Let's make a code example to better visualize:")]),e._v(" "),a("p",[a("strong",[e._v("Interface Header File")])]),e._v(" "),a("p",[e._v('#pragma once\nÂ \n#include "Object.h"\n#include "Lookable.generated.h"\nÂ \n//Instead of UCLASS() we use UINTERFACE()\nUINTERFACE()\nclass IAWESOME_API ULookable: public UInterface\n{\n//Dont forget to use this makro.\nGENERATED_UINTERFACE_BODY()\nÂ \n};\nÂ \n//Create a new class ILookable and use GENERATED_IINTERFACE_BODY() Makro in class body\nclass ILookable\n{\nGENERATED_IINTERFACE_BODY()\nÂ \npublic:\nUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Gameplay)\nvoid ProcessEvent(FName TestParamName, float TestParamFloat);\n};')]),e._v(" "),a("p",[e._v("Here you can see that I'm using a BlueprintNativeEvent. This tells Unreal internally that we want to implement this function in Blueprint and/or C++.")]),e._v(" "),a("p",[a("strong",[e._v("Interface Source File")])]),e._v(" "),a("p",[e._v('#include "IAwesome.h"\n#include "Lookable.h"\nÂ \n//This constructor is predeclared so you dont have to declare it in your .header file\n//Don\'t forget to define this constructor so no compiler errors are thrown\nULookable::ULookable(const FObjectInitializer& ObjectInitializer)\n:Super(ObjectInitializer)\n{\nÂ \n}\nÂ \n//This is the C++ part of our Event. Just let the Body empty if you don\'t want to do stuff in your Base Interface'),a("br"),e._v("\n//ðŸ˜‰Â !!!Do not forget the _Implementation suffix!!!\nvoid ILookable::ProcessEvent_Implementation(FName TestParamName, float TestParamFloat)\n{\nÂ \n}")]),e._v(" "),a("h3",{attrs:{id:"creating-an-actor-which-inherits-from-this-interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-an-actor-which-inherits-from-this-interface"}},[e._v("#")]),e._v(" Creating an Actor which inherits from this Interface")]),e._v(" "),a("p",[e._v('So far so good. Let\'s create a new C++ Class which inherits from AActor. Lets call him LookableActor. In addition to that, we have to let our new LookableActorinherit from ILookable(NOT ULookable) right after we included "Lookable.h".')]),e._v(" "),a("p",[a("strong",[e._v("Actor Header File")])]),e._v(" "),a("p",[e._v('#pragma once\nÂ \n#include "GameFramework/Actor.h"\n#include "Lookable.h"\n#include "LookableActor.generated.h"\nÂ \nUCLASS()\nclass IAWESOME_API ALookableActor: public AActor, public ILookable\n{\nGENERATED_BODY()\nÂ \npublic:\nALookableActor();\nÂ \nvirtual void BeginPlay() override;\nÂ \nvirtual void Tick(float DeltaTime) override;\nÂ \nvirtual void ProcessEvent_Implementation(FName Name, float Float) override;\n};')]),e._v(" "),a("p",[e._v("Make sure to override ProcessEvent_Implementation Function. Unfortunately all methods which are provided of our Interface "),a("strong",[e._v("HAVE TO")]),e._v(" be overridden. The Compiler makes sure to tell you if you forget it.")]),e._v(" "),a("p",[a("strong",[e._v("Actor Header File")])]),e._v(" "),a("p",[e._v('#include "IAwesome.h"\n#include "LookableActor.h"\nÂ \nALookableActor::ALookableActor()\n{\nPrimaryActorTick.bCanEverTick = true;\nRootComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("LookAtMe"));\n}\nÂ \nvoid ALookableActor::BeginPlay()\n{\nSuper::BeginPlay();\n}\nÂ \nvoid ALookableActor::Tick(float DeltaTime)\n{\nSuper::Tick(DeltaTime);\n}\nÂ \nvoid ALookableActor::ProcessEvent_Implementation(FName Name, float Float)\n{\nUE_LOG(LogTemp, Warning, TEXT("Parameter (FName)Â :Â %s \\nParameter (float)Â :Â %f"), *Name.ToString(), Float);\nÂ \nSetActorScale3D(FVector(GetActorScale.X * 1.05f));\n}')]),e._v(" "),a("p",[e._v("This ProcessEvent defines that everytime this is called on our Actor he grows by 5%.")]),e._v(" "),a("h3",{attrs:{id:"let-it-grow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-it-grow"}},[e._v("#")]),e._v(" Let it grow")]),e._v(" "),a("p",[e._v("So now we have an Actor which gets bigger and bigger. Unfortunately there isn't an Actor which calls our ProcessEvent Function so our Actor stays smallÂ ðŸ˜¦ BUT WAIT (Dramatic Sound Playing) We can do that ourselves because we have hands which create whole new "),a("strong",[e._v("Worlds")]),e._v(" and "),a("strong",[e._v("Universes")]),e._v(" by writing cool "),a("strong",[e._v("Letters")]),e._v(".Â ;D For the ones who think I'm weird and I should begin to just write a Tutorial without making stupid jokes. I can't.")]),e._v(" "),a("p",[e._v("Let's go on by quickly creating a new Actor which calls our ProcessEvent Function.")]),e._v(" "),a("p",[e._v('#pragma once\nÂ \n#include "GameFramework/Actor.h"\n#include "LineTraceActor.generated.h"\nÂ \nUCLASS()\nclass IAWESOME_API ALineTraceActor: public AActor\n{\nGENERATED_BODY()\nÂ \npublic:\t\n// Sets default values for this actor\'s properties\nALineTraceActor();\nÂ \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\nÂ \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\nÂ \nUFUNCTION()\nvoid NotifyEvent();\nÂ \n/*\nThis Function creates a Raycast and fills the given HitResult\n@param Hit: This Variable will be filled with the Information one needs.\n@return bool value which specifies IF something was hit\n*/\nbool LineTraceFromCamera(FHitResult& Hit);\nÂ \nprivate:\n//A Reference to the Player Camera\nAPlayerController* PC;\nÂ \nÂ \n};')]),e._v(" "),a("p",[e._v("At first I create 2 Methods NotifyEvent and LineTraceFromCamera I would say that the names describe their functions pretty wellÂ ðŸ˜ƒ The next step is to fill our source file:")]),e._v(" "),a("p",[e._v('#include "IAwesome.h"\n#include "Interfaced.h"\n#include "LineTraceActor.h"\nÂ \nÂ \n// Sets default values\nALineTraceActor::ALineTraceActor()\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = false;\n}\nÂ \n// Called when the game starts or when spawned\nvoid ALineTraceActor::BeginPlay()\n{\nSuper::BeginPlay();\n}\nÂ \nvoid ALineTraceActor::Tick(float DeltaTime)\n{\nSuper::Tick(DeltaTime);\nNotifyEvent();\n}\nÂ \nbool ALineTraceActor::LineTraceFromCamera(FHitResult& Hit)\n{\nauto PlayerCameraManager = PC->PlayerCameraManager;\nÂ \nFName TraceTag = Text("Draw");\nGetWorld()->DebugDrawTraceTag = TraceTag;\nÂ \nif (PlayerCameraManager)\n{\nFVector CameraForwardVector = PlayerCameraManager->GetActorForwardVector();\nÂ \nFVector LineStart = PlayerCameraManager->GetCameraLocation();\nFVector LineEnd = LineStart + CameraForwardVector * 1024;\nÂ \nFCollisionQueryParams Params;\nParams.bTraceComplex = true;\nParams.bReturnPhysicalMaterial = false;\nParams.bReturnFaceIndex = false;\nParams.TraceTag = TraceTag;\nÂ \nreturn GetWorld()->LineTraceSingleByChannel(Hit, LineStart, LineEnd, ECollisionChannel::ECC_Visibility, Params);\n}\nÂ \nÂ \nUE_LOG(LogTemp, Error, TEXT("PlayerCameraManager is null"));\nreturn false;\n}')]),e._v(" "),a("p",[e._v("Our Tick method just calls NotifyEvent which will be defined next.")]),e._v(" "),a("p",[e._v('The LineTraceFromCamera method just generates a LineTrace from the Cameras View. This setting for now should only be used for Ego Perspective games. To see our LineTrace we override the DebugDrawTraceTag of our World to "Draw". (I don\'t know if there a predefined Names for it, but just changing it to any Name should give you the expected result) Our next step is to calculate the LineStart and LineEnd of our Trace. In our case the LineStart begins at the WorldLocation of our Camera. The LineEnd should be calculated by using the Forward Vector of the Camera Multiplied by the length of the line PLUS our LineStart. Simple Vector calculationÂ ðŸ˜ƒ Our next step is to fill the collision parameters for our linetrace. Make sure to let the TraceTag of your parameter having the same value as the worlds TraceTag.')]),e._v(" "),a("p",[e._v("Our next method is NotifyEvent which is the key to notify not only c++ Interactables but also Blueprint's.")]),e._v(" "),a("p",[e._v("void ALineTraceActor::NotfiyEvent()\n{\nFHitResult Hit;\nif (LineTraceFromCamera(Hit))\n{\nif(Hit.GetActor()->Implements<ULookable>())\n{\nILookable::Execute_ProcessEvent(Hit.GetActor(), Hit.GetActor()->GetFName(), Hit.Distance);\n}\n}\n}")]),e._v(" "),a("p",[e._v("Let's go through this: We create a new variable of type FHitResult which we will fill by giving it into our LineTrace Method. If something was hit we have to check first if the Actor from our Hit Result Implements "),a("strong",[e._v("ULookable")]),e._v(" not ILookable. Please make sure to not forget thatÂ ðŸ˜ƒ Fortunately the Compiler throws an error if we give ILookable into the template because its not of type UObjectÂ ðŸ˜›")]),e._v(" "),a("p",[e._v("Now we use a static method from our ILookable Interface which was generated by Unreal itself. The Parameters are the Actor and the parameters we specified ourselves in our ProcessEvent FunctionÂ ðŸ˜ƒ (FName and float)")]),e._v(" "),a("p",[e._v("Our last step is testing this Interface in either C++ and Blueprint")]),e._v(" "),a("p",[e._v("Let's place our LineTrace Actor in the Scene. Also our Lookabel Actor should be placed somewhere. Don't forget to give our LookableActor a visual representation by just editing the StaticMesh Value of our Root StaticMeshComponent.")]),e._v(" "),a("p",[e._v('Next we will create a Blueprint Actor which also implements from Lookable. You just have to open the Blueprint Editor and go to Class Settings to Add our cool Interface. Then go to the Event Graph and Right Click on an empty spot. Then search "Event ProcessEvent" and define a funny behaviour to see your result. Don\'t forget to add a Static Mesh to this ActorÂ ðŸ˜ƒ')]),e._v(" "),a("p",[e._v("Now let's place this Blueprint Actor next to our LookableActor in World. Just hit 'Play' and see the result of our hard workÂ ðŸ˜„")]),e._v(" "),a("p",[e._v("I hope you enjoyed this tutorial. I try to edit this further to give more visual examples of the final resultÂ ðŸ˜‰")]),e._v(" "),a("p",[e._v("Thanks and have fun")]),e._v(" "),a("p",[e._v("Greetings Cloudy")]),e._v(" "),a("p",[e._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=How_To_Make_C%2B%2B_Interfaces_Implementable_By_Blueprints(Tutorial)&oldid=22091",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=How_To_Make_C%2B%2B_Interfaces_Implementable_By_Blueprints(Tutorial)&oldid=22091"),a("OutboundLink")],1),e._v('"')]),e._v(" "),a("p",[a("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])])]),e._v(" "),a("p",[e._v("Hidden category:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Templates",title:"Category:Templates"}},[e._v("Templates")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=r.exports}}]);