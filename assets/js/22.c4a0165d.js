(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{307:function(t,e,o){"use strict";o.r(e);var a=o(28),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("AI Dodge, Rotate Vector Along Axis By Angle - Epic Wiki")]),t._v(" "),o("h1",{attrs:{id:"ai-dodge-rotate-vector-along-axis-by-angle"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ai-dodge-rotate-vector-along-axis-by-angle"}},[t._v("#")]),t._v(" AI Dodge, Rotate Vector Along Axis By Angle")]),t._v(" "),o("h2",{attrs:{id:"contents"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[t._v("#")]),t._v(" Contents")]),t._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"#Overview"}},[t._v("1 Overview")])]),t._v(" "),o("li",[o("a",{attrs:{href:"#Rotate_Vector_On_Axis_By_Angle"}},[t._v("2 Rotate Vector On Axis By Angle")])]),t._v(" "),o("li",[o("a",{attrs:{href:"#AI_Dodge"}},[t._v("3 AI Dodge")])]),t._v(" "),o("li",[o("a",{attrs:{href:"#Get_Safe_Normal"}},[t._v("4 Get Safe Normal")])]),t._v(" "),o("li",[o("a",{attrs:{href:"#Picking_Dodge_Direction"}},[t._v("5 Picking Dodge Direction")])]),t._v(" "),o("li",[o("a",{attrs:{href:"#Working_With_UE4_Nav_Mesh_System"}},[t._v("6 Working With UE4 Nav Mesh System")]),t._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"#UE4_Nav_Mesh_Projection"}},[t._v("6.1 UE4 Nav Mesh Projection")])])])]),t._v(" "),o("li",[o("a",{attrs:{href:"#Conclusion"}},[t._v("7 Conclusion")])])]),t._v(" "),o("h2",{attrs:{id:"overview"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),o("p",[o("strong",[t._v("Author")]),t._v(" "),o("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),o("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),o("p",[t._v("Dear Community,")]),t._v(" "),o("p",[t._v("In this wiki I show you a simple way to create an AI dodge mechanic where the unit moves along the peridicular of the direction to its target.")]),t._v(" "),o("p",[t._v('The direction from the AI unit to its target is a what I call a "direction vector" because it is an FVector that is storing normalized direction data.')]),t._v(" "),o("p",[t._v('"Normalized" means the length of the vector is 1, which makes it easy to multiply with a float to create a total distance you want to move along a direction vector.')]),t._v(" "),o("h2",{attrs:{id:"rotate-vector-on-axis-by-angle"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rotate-vector-on-axis-by-angle"}},[t._v("#")]),t._v(" Rotate Vector On Axis By Angle")]),t._v(" "),o("p",[t._v("If you want to rotate a direction vector around an axis quickly and easily you can use this handy function found in Vector.h")]),t._v(" "),o("p",[t._v("/**\n* Rotates around Axis (assumes Axis.Size() == 1).\n*\n* @param Angle Angle to rotate (in degrees).\n* @param Axis Axis to rotate around.\n* @return Rotated Vector.\n*/\nFVector RotateAngleAxis( const float AngleDeg, const FVector& Axis ) const;")]),t._v(" "),o("h2",{attrs:{id:"ai-dodge"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ai-dodge"}},[t._v("#")]),t._v(" AI Dodge")]),t._v(" "),o("p",[t._v("void AIDodge(bool DodgeRight=true, float Distance=256); //.h\nÂ \nvoid AYourAIClass::AIDodge(bool DodgeRight, float Distance)\n{\n//Location of unit who wants to dodge sideways, presumed to be facing target already\nFVector UnitLocation = GetActorLocation();\nFVector DirectionToActor = (OtherActor->GetActorLocation() - UnitLocation ).GetSafeNormal();\nÂ \n//Optional, remove Z value for ground-based play, ensure UE4 Nav mesh point will be found.\nDirectionToActor.Z = 0;\nÂ \n//Rotate the direction by 90 to get perpendicular of direction to actor\nFVector Perpendicular = DirectionToActor.RotateAngleAxis(90,FVector(0,0,1));\nÂ \n//Dodging to relative Left or Right?\nPerpendicular *= (DodgeRight) ? 1 : -1;\nÂ \n//Tell Unit to move 256 units along this perpendicular\nFVector GoalLocation = UnitLocation + Perpendicular * Distance;\nÂ \n//Tell unit to move to this location\nAAIController* AIControl = Cast<AAIController>(GetController());\nif(AIControl)\n{\nAIControl->MoveToLocation(GoalLocation,0); //Optional Acceptance Radius\n}\n}")]),t._v(" "),o("p",[t._v("Note that by using FVector::RotateAngleAxis you can implement an AI dodge function in just a few lines of code!")]),t._v(" "),o("p",[t._v("//Rotate the direction by 90 to get perpendicular of direction to actor\nFVector Perpendicular = DirectionToActor.RotateAngleAxis(90,FVector(0,0,1));")]),t._v(" "),o("p",[t._v("The reason the axis is FVector(0,0,1) is because that's the vertical axis, so you can imagine a vertical pole that the direction vector is rotating around.")]),t._v(" "),o("p",[t._v("You could just as easily use any axis of your own choosing, for your own game's needsÂ ðŸ˜ƒ")]),t._v(" "),o("h2",{attrs:{id:"get-safe-normal"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#get-safe-normal"}},[t._v("#")]),t._v(" Get Safe Normal")]),t._v(" "),o("p",[t._v("Notice I am using GetSafeNormal() to remove all length/distance information from the vector between the AI unit and its target. This ensures that I can the multiply by the Distance parameter later and get a vector of exactly the desired length.")]),t._v(" "),o("p",[t._v("//Location of unit who wants to dodge sideways, presumed to be facing target already\nFVector UnitLocation = GetActorLocation();\nFVector DirectionToActor = (OtherActor->GetActorLocation() - UnitLocation ).GetSafeNormal();")]),t._v(" "),o("h2",{attrs:{id:"picking-dodge-direction"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#picking-dodge-direction"}},[t._v("#")]),t._v(" Picking Dodge Direction")]),t._v(" "),o("p",[t._v("Notice I am using the ternary operatorÂ ?Â : to switch dodge directions based on input parameter:")]),t._v(" "),o("p",[t._v("//Dodging to relative Left or Right?\nPerpendicular *= (DodgeRight) ? 1 : -1;")]),t._v(" "),o("h2",{attrs:{id:"working-with-ue4-nav-mesh-system"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#working-with-ue4-nav-mesh-system"}},[t._v("#")]),t._v(" Working With UE4 Nav Mesh System")]),t._v(" "),o("p",[t._v("To ensure that the final dodge point will be easy for the UE4 Navigation system to find, I remove all Z information of the direction of AI unit to its target:")]),t._v(" "),o("p",[t._v("//Optional, remove Z value for ground-based play, ensure UE4 Nav mesh point will be found.\nDirectionToActor.Z = 0;")]),t._v(" "),o("p",[t._v("Imagine the AI unit wants to dodge a target that 45 degrees above the AI unit on a ledge. If you rotate that vector with z value intact, the final goal may be beneath the ground, or in the case of AI unit being above target, then the goal will be in the air somewhere.")]),t._v(" "),o("p",[t._v("By removing Z information I ensure that the AI unit is querying the UE4 navigation system for a point that is on its own level.")]),t._v(" "),o("h3",{attrs:{id:"ue4-nav-mesh-projection"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#ue4-nav-mesh-projection"}},[t._v("#")]),t._v(" UE4 Nav Mesh Projection")]),t._v(" "),o("p",[t._v("Alternatively, if you dont want to remove the Z information, you can use UE4 function ProjectPointToNav with an appropriate extent if you want to make absolutely sure the dodge point is going to be found on the nav mesh.")]),t._v(" "),o("p",[t._v('The "Extent" defines the shape of the trace that is performed, so an Extent with a Z of 512 will find destinations on the nav mesh above and below the queried location by 512.')]),t._v(" "),o("p",[t._v("Keep in mind Extent is the half-size of the final trace, because it goes in both directions along the axis.")]),t._v(" "),o("p",[t._v("//NavigationSystem.h\nbool ProjectPointToNavigation(const FVector& Point, FNavLocation& OutLocation, const FVector& Extent = INVALID_NAVEXTENT, const FNavAgentProperties* AgentProperties = NULL, TSharedPtr<const FNavigationQueryFilter> QueryFilter = NULL)\n{\nreturn ProjectPointToNavigation(Point, OutLocation, Extent, AgentProperties != NULL ? GetNavDataForProps(*AgentProperties) : GetMainNavData(FNavigationSystem::DontCreate), QueryFilter);\n}\nÂ \nbool ProjectPointToNavigation(const FVector& Point, FNavLocation& OutLocation, const FVector& Extent = INVALID_NAVEXTENT, const ANavigationData* NavData = NULL, TSharedPtr<const FNavigationQueryFilter> QueryFilter = NULL) const;")]),t._v(" "),o("p",[t._v("This projection functionality is also built into the AIController MoveTo function, if you set that parameter to true!")]),t._v(" "),o("p",[t._v('/** Makes AI go toward specified Dest location\n*  @param AcceptanceRadius - finish move if pawn gets close enough\n*  @param bStopOnOverlap - add pawn\'s radius to AcceptanceRadius\n*  @param bUsePathfinding - use navigation data to calculate path (otherwise it will go in straight line)\n*  @param bProjectDestinationToNavigation - project location on navigation data before using it\n*  @param bCanStrafe - set focus related flag: bAllowStrafe\n*  @param FilterClass - navigation filter for pathfinding adjustments\n*  @param bAllowPartialPath - use incomplete path when goal can\'t be reached\n*\t@note AcceptanceRadius has default value or -1 due to Header Parser not being able to recognize UPathFollowingComponent::DefaultAcceptanceRadius\n*/\nUFUNCTION(BlueprintCallable, Category = "AI|Navigation", Meta = (AdvancedDisplay = "bStopOnOverlap,bCanStrafe,bAllowPartialPath"))\nEPathFollowingRequestResult::Type MoveToLocation(const FVector& Dest, float AcceptanceRadius = -1, bool bStopOnOverlap = true,\nbool bUsePathfinding = true, bool bProjectDestinationToNavigation = false, bool bCanStrafe = true,\nTSubclassOf<UNavigationQueryFilter> FilterClass = NULL, bool bAllowPartialPath = true);')]),t._v(" "),o("h2",{attrs:{id:"conclusion"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),o("p",[t._v("In just a few lines of code I've shown you a way to tell your AI unit to move perpendicular to the direction to its target, thus implementing a dodge mechanic that you can use no matter how the AI unit and its target are positioned in world space.")]),t._v(" "),o("p",[t._v("Enjoy!")]),t._v(" "),o("p",[t._v("Rama")]),t._v(" "),o("p",[t._v('Retrieved from "'),o("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=AI_Dodge,_Rotate_Vector_Along_Axis_By_Angle&oldid=15144",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://wiki.unrealengine.com/index.php?title=AI_Dodge,_Rotate_Vector_Along_Axis_By_Angle&oldid=15144"),o("OutboundLink")],1),t._v('"')]),t._v(" "),o("p",[o("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[t._v("Category")]),t._v(":")]),t._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[t._v("Code")])])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);e.default=n.exports}}]);