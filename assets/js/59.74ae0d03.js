(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{915:function(t,e,r){"use strict";r.r(e);var a=r(28),i=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("Algorithm Analysis: Create Directory Recursively - Epic Wiki")]),t._v(" "),r("h1",{attrs:{id:"algorithm-analysis-create-directory-recursively"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-analysis-create-directory-recursively"}},[t._v("#")]),t._v(" Algorithm Analysis: Create Directory Recursively")]),t._v(" "),r("h2",{attrs:{id:"contents"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[t._v("#")]),t._v(" Contents")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Overview"}},[t._v("1 Overview")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Standard_Create_Directory"}},[t._v("2 Standard Create Directory")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#The_Issue"}},[t._v("3 The Issue")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Static"}},[t._v("4 Static")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#CreateDirectoryRecursively"}},[t._v("5 CreateDirectoryRecursively")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Input"}},[t._v("5.1 Input")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Output"}},[t._v("5.2 Output")])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Algorithm_Analysis"}},[t._v("6 Algorithm Analysis")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Loop_Protection"}},[t._v("6.1 Loop Protection")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Algorithm_Formatting_to_Avoid_Input_Requirements"}},[t._v("6.2 Algorithm Formatting to Avoid Input Requirements")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Recycling_Memory_in_Looping_Algorithms"}},[t._v("6.3 Recycling Memory in Looping Algorithms")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Simplicity"}},[t._v("6.4 Simplicity")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Review"}},[t._v("6.5 Review")])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Conclusion"}},[t._v("7 Conclusion")])])]),t._v(" "),r("h2",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),r("p",[r("em",[t._v("Algorithm & Algorithm Analysis by:")]),t._v(" "),r("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),r("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),r("p",[t._v("Dear Community,")]),t._v(" "),r("p",[r("strong",[t._v("I have a gift for you!")])]),t._v(" "),r("p",[t._v("And also a chance to do some in-depth C++ algorithm analysis with youÂ ðŸ˜ƒ")]),t._v(" "),r("p",[t._v("Here is my entire function for recursively creating a directory!")]),t._v(" "),r("h2",{attrs:{id:"standard-create-directory"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#standard-create-directory"}},[t._v("#")]),t._v(" Standard Create Directory")]),t._v(" "),r("p",[t._v("The standard create directory function in UE4 is:")]),t._v(" "),r("p",[t._v("FPlatformFileManager::Get().GetPlatformFile().CreateDirectory(*FullPath);")]),t._v(" "),r("p",[t._v("FullPath should look something like:")]),t._v(" "),r("p",[t._v('"C:/YourProj/YourLevels/YourSubLevels"')]),t._v(" "),r("h2",{attrs:{id:"the-issue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#the-issue"}},[t._v("#")]),t._v(" The Issue")]),t._v(" "),r("p",[t._v("If you try to create the above directory, YourSubLevels, supplying the entire path, the CreateDirectory function will fail if all of the super directories do not exist.")]),t._v(" "),r("p",[t._v("So if "),r("code",[t._v("C:/YourProj/YourLevels/")]),t._v(" does not exist, the function will fail.")]),t._v(" "),r("p",[t._v("But in my case, I want to ensure that all necessary super directories will be created!")]),t._v(" "),r("p",[r("strong",[t._v("So I wrote a function to do this!")])]),t._v(" "),r("h2",{attrs:{id:"static"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[t._v("#")]),t._v(" Static")]),t._v(" "),r("p",[t._v("Remove the word static if you just want to plop this function in a .h file somewhere to test itÂ ðŸ˜ƒ")]),t._v(" "),r("h2",{attrs:{id:"createdirectoryrecursively"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#createdirectoryrecursively"}},[t._v("#")]),t._v(" CreateDirectoryRecursively")]),t._v(" "),r("p",[t._v('//Create Directory, Creating Entire Structure as Necessary\n//\t\tso if JoyLevels and Folder1 do not exist in JoyLevels/Folder1/Folder2\n//\t\t\tthey will be created so that Folder2 can be created!\nÂ \n//This is my solution for fact that trying to create a directory fails\n//\t\tif its super directories do not exist\nÂ \nÂ \n//Expects entire directory path, such as:\nÂ \n// C:/Folder1/Folder2/Folder3/NewFolderToMake/\nÂ \n//\t\t\tAuthor: Rama\nÂ \nÂ \nstatic FORCEINLINE void CreateDirectoryRecursively(FString FolderToMake)\n{\n//FolderToMake is not const so split can be used, and does not damage input\nÂ \n//Loop Proteciton\nconst int32 MAX_LOOP_ITR = 3000; //limit of 3000 directories in the structure\nÂ \n// Normalize all / and \\ to TEXT("/") and remove any trailing TEXT("/")\n//if the character before that is not a TEXT("/") or a colon\nFPaths::NormalizeDirectoryName(FolderToMake);\nÂ \n//Normalize removes the last "/", but my algorithm wants it\nFolderToMake += "/";\nÂ \nFString Base;\nFString Left;\nFString Remaining;\nÂ \n//Split off the Root\nFolderToMake.Split(TEXT("/"),&Base,&Remaining);\nBase += "/"; //add root text to Base\nÂ \nint32 LoopItr = 0;\nwhile(Remaining != "" && LoopItr < MAX_LOOP_ITR)\n{\nRemaining.Split(TEXT("/"),&Left,&Remaining);\nÂ \n//Add to the Base\nBase += Left + FString("/"); //add left and split text to Base\nÂ \n//Create Incremental Directory Structure!\nFPlatformFileManager::Get().GetPlatformFile().CreateDirectory(*Base);\nÂ \nLoopItr++;\n}\n}')]),t._v(" "),r("h3",{attrs:{id:"input"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#input"}},[t._v("#")]),t._v(" Input")]),t._v(" "),r("p",[r("strong",[t._v("New Folder =")]),t._v(" C:/Users/Rama/Documents/Victory/FolderSong/FolderDance/FolderRain/FolderRainbow")]),t._v(" "),r("p",[t._v('FString NewFolder =\n"C:/Users/Rama/Documents/Victory/FolderSong/FolderDance/FolderRain/FolderRainbow/";\nÂ \n//remove UMyFunctionLibrary:: if you removed the "static"\nUMyFunctionLibrary::CreateDirectoryRecursively(NewFolder);')]),t._v(" "),r("h3",{attrs:{id:"output"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[t._v("#")]),t._v(" Output")]),t._v(" "),r("p",[r("a",{attrs:{href:"/File:RainbowRecursively.jpg"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/9/94/RainbowRecursively.jpg",alt:"RainbowRecursively.jpg"}})])]),t._v(" "),r("h2",{attrs:{id:"algorithm-analysis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-analysis"}},[t._v("#")]),t._v(" Algorithm Analysis")]),t._v(" "),r("h3",{attrs:{id:"loop-protection"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#loop-protection"}},[t._v("#")]),t._v(" Loop Protection")]),t._v(" "),r("p",[t._v("The first and most important thing to note is that this is a while loop!")]),t._v(" "),r("p",[t._v("So in any while loop it is a really good idea to have Loop Protection!")]),t._v(" "),r("p",[t._v('const int32 MAX_LOOP_ITR = 3000;\nint32 LoopItr = 0;\nÂ \nwhile(Remaining != "" && LoopItr < MAX_LOOP_ITR)\n{\n//...\nLoopItr++;\n}')]),t._v(" "),r("p",[t._v('The loop is supposed to end happily and healthily when Remaining == "", because all parts of the directory structure have been created.')]),t._v(" "),r("p",[t._v("If the directory structure contains 3000 folders I'd be rather surprised, and so I use this number as the max loop count, to protect against a permanent hang.")]),t._v(" "),r("p",[t._v("You should always incorporate Loop Protection if you are using a While Loop!")]),t._v(" "),r("h3",{attrs:{id:"algorithm-formatting-to-avoid-input-requirements"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-formatting-to-avoid-input-requirements"}},[t._v("#")]),t._v(" Algorithm Formatting to Avoid Input Requirements")]),t._v(" "),r("p",[t._v("My algorithm requires that the file path not be using any \\ characters instead of / for the file path, such as")]),t._v(" "),r("p",[t._v("C:\\YourProj\\YourLevels\\YourSubLevels")]),t._v(" "),r("p",[t._v("In order to ensure that my algorithm will work, I am using Epic's awesome NormalizeDirectoryName function!")]),t._v(" "),r("p",[t._v('// Normalize all / and \\ to TEXT("/") and remove any trailing TEXT("/") if the character before that is not a TEXT("/") or a colon\nFPaths::NormalizeDirectoryName(FolderToMake);')]),t._v(" "),r("p",[t._v("If I did not do this re-formatting internally to guarantee success, I would have had to make users understand to only supply a certain format.")]),t._v(" "),r("p",[t._v("So wherever possible, you should try to format the input yourself to meet your algorithm's requirements.")]),t._v(" "),r("h3",{attrs:{id:"recycling-memory-in-looping-algorithms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#recycling-memory-in-looping-algorithms"}},[t._v("#")]),t._v(" Recycling Memory in Looping Algorithms")]),t._v(" "),r("p",[t._v("I am using Split to recycle variables to minimize Memory usage.")]),t._v(" "),r("p",[t._v('//While Loop\n//{\nRemaining.Split(TEXT("/"),&Left,&Remaining);\n//}')]),t._v(" "),r("p",[t._v("Recall from my "),r("strong",[r("a",{attrs:{href:"/Entry_Level_Guide_to_UE4_C%2B%2B",title:"Entry Level Guide to UE4 C++"}},[t._v("UE4 C++ Introductory Guide")])]),t._v(" that the & symbol means that you are accessing the memory location of the variable.")]),t._v(" "),r("p",[t._v("So in the while loop above, the Split function is continuously recycling the variable data!")]),t._v(" "),r("p",[t._v('Split is separating the input string Remaining on the first instance of the "/".')]),t._v(" "),r("p",[t._v("The left part of Remaining is passed off to the Base, added to the rest of the Base in order to make the folder.")]),t._v(" "),r("p",[t._v("The right part of the string, the remaining portion, is passed right back into Remaining!")]),t._v(" "),r("p",[t._v("So the contents of Remaining are replaced after the function is run!")]),t._v(" "),r("p",[t._v("In this way I am using the same amount of memory whether the directory structure contains 3 or 700 directories!")]),t._v(" "),r("p",[t._v("In any looping alogrithm make careful use of pointers and the & operator to minimize memory used")]),t._v(" "),r("h3",{attrs:{id:"simplicity"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#simplicity"}},[t._v("#")]),t._v(" Simplicity")]),t._v(" "),r("p",[t._v("When I first was making this function, it was getting very complicated.")]),t._v(" "),r("p",[t._v("I stepped back, realized where my mistake was, and re wrote the algorithm much more simply!")]),t._v(" "),r("p",[t._v("If your algorithms are running away with you and getting complicated,\ntake a step back and look for a simpler approach,\nthat may involving using or understanding the UE4 C++ API better.")]),t._v(" "),r("p",[t._v('In my case I did not notice that using NormalizeDirectoryName was removing the last "/" that my algorithm relied upon.')]),t._v(" "),r("p",[t._v('In my fix for this, I also ended up guaranteeing that a last "/" will be added even if the user did not put one in!')]),t._v(" "),r("p",[t._v('// Normalize all / and \\ to TEXT("/") and remove any trailing TEXT("/") if the character before that is not a TEXT("/") or a colon\nFPaths::NormalizeDirectoryName(FolderToMake);\nÂ \n//Normalize removes the last "/", but my algorithm wants it\nFolderToMake += "/";')]),t._v(" "),r("h3",{attrs:{id:"review"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#review"}},[t._v("#")]),t._v(" Review")]),t._v(" "),r("p",[t._v("Now check out the entire algorithm again, and see what you've learned from reading this algorithm analysis!")]),t._v(" "),r("p",[r("strong",[r("a",{attrs:{href:"#CreateDirectoryRecursively"}},[t._v("Algorithm Review! See What You've Learned!")])])]),t._v(" "),r("h2",{attrs:{id:"conclusion"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),r("p",[t._v("I hope you have additional insights now for when you are writing your own C++ Algorithms.")]),t._v(" "),r("p",[t._v("And I hope you enjoy using my CreateDirectoryRecursively!")]),t._v(" "),r("p",[t._v("Enjoy!")]),t._v(" "),r("p",[r("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),r("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),r("p",[t._v('Retrieved from "'),r("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Algorithm_Analysis:_Create_Directory_Recursively&oldid=2606",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://wiki.unrealengine.com/index.php?title=Algorithm_Analysis:_Create_Directory_Recursively&oldid=2606"),r("OutboundLink")],1),t._v('"')]),t._v(" "),r("p",[r("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[t._v("Category")]),t._v(":")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[t._v("Code")])])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);e.default=i.exports}}]);