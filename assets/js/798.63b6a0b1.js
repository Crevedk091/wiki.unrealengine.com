(window.webpackJsonp=window.webpackJsonp||[]).push([[798],{1298:function(t,e,a){"use strict";a.r(e);var n=a(28),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Line Traces / RayCasts How To Get UV Info From Hits - Epic Wiki")]),t._v(" "),a("h1",{attrs:{id:"line-traces-raycasts-how-to-get-uv-info-from-hits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#line-traces-raycasts-how-to-get-uv-info-from-hits"}},[t._v("#")]),t._v(" Line Traces / RayCasts How To Get UV Info From Hits")]),t._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[t._v("#")]),t._v(" Contents")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Overview"}},[t._v("1 Overview")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Github_Engine_Version"}},[t._v("2 Github Engine Version")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#My_PhysX_C.2B.2B_Code_For_You.21"}},[t._v("3 My PhysX C++ Code For You!")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#EngineTypes.h"}},[t._v("3.1 EngineTypes.h")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#CollisionQueryParams.h"}},[t._v("3.2 CollisionQueryParams.h")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#PhysXCollision.cpp"}},[t._v("3.3 PhysXCollision.cpp")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#PrimitiveComponent.cpp"}},[t._v("3.4 PrimitiveComponent.cpp")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#BodyInstance.h"}},[t._v("3.5 BodyInstance.h")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#BodyInstance.cpp"}},[t._v("3.6 BodyInstance.cpp")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Currently_Supported_Line_Trace_Functions"}},[t._v("4 Currently Supported Line Trace Functions")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Sample_Usage_Code"}},[t._v("5 Sample Usage Code")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#Conclusion"}},[t._v("6 Conclusion")])])]),t._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),a("p",[a("strong",[t._v("Author:")]),t._v(" "),a("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),a("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),a("p",[t._v("In this wiki I provide you with the code to add the option to return UV information about raycast hits (PhysX) / Line Traces (UE4) !")]),t._v(" "),a("p",[t._v("This is an optional flag that you can set, that does not affect performance or change UE4 behavior at all until it is turned on.")]),t._v(" "),a("p",[t._v("Even when turned on I have not noticed any performance impact, but if you examine my code you will see that performance of UE4 and the internal works of the PhysX code are entirely unchanged unless the optional flag is enabled.")]),t._v(" "),a("p",[a("a",{attrs:{href:"/File:PxUV.jpg"}},[a("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/f/f8/PxUV.jpg/900px-PxUV.jpg",alt:"PxUV.jpg"}})])]),t._v(" "),a("h2",{attrs:{id:"github-engine-version"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#github-engine-version"}},[t._v("#")]),t._v(" Github Engine Version")]),t._v(" "),a("p",[t._v("You must be using a Github version of UE4 in order to change these files below and recompile the engine.")]),t._v(" "),a("p",[t._v("Using a github version of UE4 you can add your own code to the engine and really make UE4 your own!")]),t._v(" "),a("p",[t._v("You can follow the steps here to obtain a github version of UE4!")]),t._v(" "),a("p",[a("strong",[t._v("How to get Github Version of UE4")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.unrealengine.com/ue4-on-github",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.unrealengine.com/ue4-on-github"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"my-physx-c-code-for-you"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#my-physx-c-code-for-you"}},[t._v("#")]),t._v(" My PhysX C++ Code For You!")]),t._v(" "),a("p",[t._v("I am using line numbers for the .cpp files especially to avoid posting any UE4 engine code publicaly.")]),t._v(" "),a("p",[t._v("Please note my line numbers are subject to change as more code is added to the engine.")]),t._v(" "),a("p",[a("strong",[t._v("The line numbers below are accurate to version 4.7.3 of UE4")]),t._v(". So you can always download 4.7.3 source code from Github to ensure you are seeing the larger context of my cpp code changes.")]),t._v(" "),a("p",[t._v("The code you do see here are my additions to the UE4 engine code to support returning UV information from PhysX "),a("a",{attrs:{href:"http://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/apireference/files/structPxRaycastHit.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("PxRaycastHits"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("h3",{attrs:{id:"enginetypes-h"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enginetypes-h"}},[t._v("#")]),t._v(" EngineTypes.h")]),t._v(" "),a("p",[t._v("Around line "),a("strong",[t._v("1485")]),t._v(", in FHitResult, add this")]),t._v(" "),a("p",[t._v("/** If CollisionQueryParams has bReturnUV set to true and the trace is a ray cast / line trace, then this value will be filled with the uv of the hit component at the point of impact */\nUPROPERTY()\nFVector2D UV;")]),t._v(" "),a("h3",{attrs:{id:"collisionqueryparams-h"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collisionqueryparams-h"}},[t._v("#")]),t._v(" CollisionQueryParams.h")]),t._v(" "),a("p",[t._v("Starting around line "),a("strong",[t._v("38")]),t._v(", make these two changes (emphasized with arrows)")]),t._v(" "),a("p",[t._v("/** Whether we want to return the UV at the hit location. Only valid for Line Traces / Ray casts */\nbool bReturnUV;       \t\t\t\t\t//<~~~~~~~~~~~~\n \n/** Set of components to ignore during the trace */\nTArray<uint32, TInlineAllocator<1> > IgnoreComponents;\n \n// Constructors\nFCollisionQueryParams(bool bInTraceComplex=false)\n{\nbTraceComplex = bInTraceComplex;\nTraceTag = NAME_None;\nbTraceAsyncScene = false;\nbFindInitialOverlaps = true;\nbReturnFaceIndex = false;\nbReturnPhysicalMaterial = false;\nbReturnUV = false;\t\t\t\t//<~~~~~~~~~~~~\n}")]),t._v(" "),a("h3",{attrs:{id:"physxcollision-cpp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#physxcollision-cpp"}},[t._v("#")]),t._v(" PhysXCollision.cpp")]),t._v(" "),a("p",[t._v("Around line "),a("strong",[t._v("858")]),t._v(", add this")]),t._v(" "),a("p",[t._v("if(Params.bReturnUV)\n{\nPOutputFlags |= PxSceneQueryFlag::eUV;\n}")]),t._v(" "),a("p",[t._v("then around line "),a("strong",[t._v("900")]),t._v(" add this:")]),t._v(" "),a("p",[t._v("if(Params.bReturnUV)\n{\nOutHit.UV = FVector2D(PHit.u,PHit.v); //u and v are exclusive to PxRaycastHit\n}")]),t._v(" "),a("h3",{attrs:{id:"primitivecomponent-cpp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#primitivecomponent-cpp"}},[t._v("#")]),t._v(" PrimitiveComponent.cpp")]),t._v(" "),a("p",[t._v("Around line "),a("strong",[t._v("1700")]),t._v(":")]),t._v(" "),a("p",[t._v("bool UPrimitiveComponent::LineTraceComponent(struct FHitResult& OutHit, const FVector Start, const FVector End, const struct FCollisionQueryParams& Params)\n{\nbool bHaveHit = BodyInstance.LineTrace(OutHit, Start, End, Params.bTraceComplex, Params.bReturnPhysicalMaterial, Params.bReturnUV);")]),t._v(" "),a("h3",{attrs:{id:"bodyinstance-h"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bodyinstance-h"}},[t._v("#")]),t._v(" BodyInstance.h")]),t._v(" "),a("p",[t._v("Modify this function")]),t._v(" "),a("p",[t._v("/**\n*  Trace a ray against just this bodyinstance\n*  @param  OutHit\t\t\t\t\tInformation about hit against this component, if true is returned\n*  @param  Start\t\t\t\t\tStart location of the ray\n*  @param  End\t\t\t\t\t\tEnd location of the ray\n*\t@param\tbTraceComplex\t\t\tShould we trace against complex or simple collision of this body\n*  @param bReturnPhysicalMaterial\tFill in the PhysMaterial field of OutHit\n*  @param bReturnUV\t\t\t\t\tFill in the UV field of OutHit\n*  @return true if a hit is found\n*/\nbool LineTrace(struct FHitResult& OutHit, const FVector& Start, const FVector& End, bool bTraceComplex, bool bReturnPhysicalMaterial = false, bool bReturnUV = false) const;")]),t._v(" "),a("h3",{attrs:{id:"bodyinstance-cpp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bodyinstance-cpp"}},[t._v("#")]),t._v(" BodyInstance.cpp")]),t._v(" "),a("p",[t._v("around line "),a("strong",[t._v("3383")]),t._v(" add this")]),t._v(" "),a("p",[t._v("if(bReturnUV)\n{\nPOutputFlags |= PxSceneQueryFlag::eUV;\n}")]),t._v(" "),a("p",[t._v("then around line "),a("strong",[t._v("3348")]),t._v(" add this")]),t._v(" "),a("p",[t._v("if(bReturnUV)\n{\nOutHit.UV = FVector2D(BestHit.u,BestHit.v); //u and v are exclusive to PxRaycastHit\n}")]),t._v(" "),a("h2",{attrs:{id:"currently-supported-line-trace-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#currently-supported-line-trace-functions"}},[t._v("#")]),t._v(" Currently Supported Line Trace Functions")]),t._v(" "),a("p",[t._v("With the above changes you can retrieve hit information from:")]),t._v(" "),a("p",[t._v("UWorld::LineTraceSingle")]),t._v(" "),a("p",[t._v("and")]),t._v(" "),a("p",[t._v("UPrimitiveComponent::LineTraceComponent.")]),t._v(" "),a("p",[t._v("Other line traces that use PxRaycastHit could be altered in similar fashion to support returning UV information.")]),t._v(" "),a("h2",{attrs:{id:"sample-usage-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sample-usage-code"}},[t._v("#")]),t._v(" Sample Usage Code")]),t._v(" "),a("p",[t._v("Once you've made the above changes and recompiled your UE4 Engine, you can use this code to get UV information from raycasts!")]),t._v(" "),a("p",[t._v("I used this code at the "),a("strong",[t._v("project-level")]),t._v(" in the tick function of my sample character:")]),t._v(" "),a("p",[t._v("The results of this code are shown in my picture above (except I am using a screen message)")]),t._v(" "),a("p",[t._v('void AISMCharacter::Tick(float DeltaTime)\n{\nSuper::Tick(DeltaTime);\n//~~~~~~~~~~~~\n \nFVector Start\t= GetActorLocation();\nFVector End \t= Start + GetActorRotation().Vector() * 10240;\n \nFCollisionQueryParams TraceParams(FName(TEXT("VictoreCore Trace")), true, this);\nTraceParams.bTraceComplex = true;\n \n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Focus of this wiki, telling UE4 we want the UV info!\nTraceParams.bReturnUV = true;\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n//Ignore Actors\nTraceParams.AddIgnoredActor(this);\n \n//Trace!\nFHitResult HitOut;\nGetWorld()->LineTraceSingle(\nHitOut,\t\t//result\nStart,\t//start\nEnd , //end\nECC_Pawn, //collision channel\nTraceParams\n);\n \nVSCREENMSG2("UV!", HitOut.UV.ToString());\n}')]),t._v(" "),a("h2",{attrs:{id:"conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),a("p",[t._v("With these changes to the UE4 engine you can now get UV information back from line traces!")]),t._v(" "),a("p",[t._v("Enjoy!")]),t._v(" "),a("p",[a("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),a("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),a("p",[t._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Line_Traces_/_RayCasts_How_To_Get_UV_Info_From_Hits&oldid=13389",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://wiki.unrealengine.com/index.php?title=Line_Traces_/_RayCasts_How_To_Get_UV_Info_From_Hits&oldid=13389"),a("OutboundLink")],1),t._v('"')]),t._v(" "),a("p",[a("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[t._v("Category")]),t._v(":")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[t._v("Code")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);e.default=r.exports}}]);