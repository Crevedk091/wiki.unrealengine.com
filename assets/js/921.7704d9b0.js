(window.webpackJsonp=window.webpackJsonp||[]).push([[921],{892:function(e,t,n){"use strict";n.r(t);var a=n(28),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Pong Tutorial - Epic Wiki")]),e._v(" "),n("h1",{attrs:{id:"pong-tutorial"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pong-tutorial"}},[e._v("#")]),e._v(" Pong Tutorial")]),e._v(" "),n("p",[n("strong",[e._v("This tutorial was recently finished and due to its length, there may be some grammatical/syntax errors scattered throughout it. If you are going through this and find anything confusing or that you think should be there, please change it! I am certain that I was not able to cover everything.")])]),e._v(" "),n("p",[e._v("Hi everyone. I recently went through the UE4 code base and created a pong game to help myself become familiarized with the Engine. Just a heads up that I am in no way sure that the implementation of this game follows the best practices for development. However, the goal of this tutorial was to implement everything via C++, which I managed. Hopefully by the end of this tutorial you will have a much better feel for working with the Engine in C++ and also a better feel for how awesome blueprints can be.")]),e._v(" "),n("h2",{attrs:{id:"contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Creating_the_Project"}},[e._v("1 Creating the Project")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Setting_Up_the_World"}},[e._v("2 Setting Up the World")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Creating_the_Assets"}},[e._v("3 Creating the Assets")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Opening_up_the_Code"}},[e._v("4 Opening up the Code")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Creating_the_Background"}},[e._v("5 Creating the Background")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Background.h"}},[e._v("5.1 Background.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Background.cpp"}},[e._v("5.2 Background.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Creating_the_Other_Sprites"}},[e._v("6 Creating the Other Sprites")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Ball.h"}},[e._v("6.1 Ball.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Ball.cpp"}},[e._v("6.2 Ball.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.h"}},[e._v("6.3 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp"}},[e._v("6.4 Paddle.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Bounds.h"}},[e._v("6.5 Bounds.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Bounds.cpp"}},[e._v("6.6 Bounds.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Goal.h"}},[e._v("6.7 Goal.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Goal.cpp"}},[e._v("6.8 Goal.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Creating_the_GameMode"}},[e._v("7 Creating the GameMode")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongGameMode.h"}},[e._v("7.1 PongGameMode.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.cpp"}},[e._v("7.2 PongGameMode.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Initializing_the_Background.2FCamera.2FPaddle.2FBall"}},[e._v("8 Initializing the Background/Camera/Paddle/Ball")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Background"}},[e._v("8.1 Background")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Background.h_2"}},[e._v("8.1.1 Background.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Background.cpp_2"}},[e._v("8.1.2 Background.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongCamera"}},[e._v("8.2 PongCamera")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongCamera.h"}},[e._v("8.2.1 PongCamera.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongCamera.cpp"}},[e._v("8.2.2 PongCamera.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle"}},[e._v("8.3 Paddle")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Paddle.h_2"}},[e._v("8.3.1 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp_2"}},[e._v("8.3.2 Paddle.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Ball"}},[e._v("8.4 Ball")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Ball.h_2"}},[e._v("8.4.1 Ball.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Ball.cpp_2"}},[e._v("8.4.2 Ball.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode"}},[e._v("8.5 PongGameMode")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongGameMode.h_2"}},[e._v("8.5.1 PongGameMode.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.cpp_2"}},[e._v("8.5.2 PongGameMode.cpp")])])])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Moving_the_Paddle"}},[e._v("9 Moving the Paddle")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Paddle.h_3"}},[e._v("9.1 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp_3"}},[e._v("9.2 Paddle.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Adding_Bounds"}},[e._v("10 Adding Bounds")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Bounds"}},[e._v("10.1 Bounds")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Bounds.h_2"}},[e._v("10.1.1 Bounds.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Bounds.cpp_2"}},[e._v("10.1.2 Bounds.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Background.h_3"}},[e._v("10.2 Background.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Background.cpp_3"}},[e._v("10.3 Background.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.h_3"}},[e._v("10.4 PongGameMode.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.cpp_3"}},[e._v("10.5 PongGameMode.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.h_4"}},[e._v("10.6 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp_4"}},[e._v("10.7 Paddle.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Creating_the_GameState"}},[e._v("11 Creating the GameState")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongGameState.h"}},[e._v("11.1 PongGameState.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameState.cpp"}},[e._v("11.2 PongGameState.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.h_4"}},[e._v("11.3 PongGameMode.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.cpp_4"}},[e._v("11.4 PongGameMode.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Adding_Movement_to_the_Ball"}},[e._v("12 Adding Movement to the Ball")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Ball.h_3"}},[e._v("12.1 Ball.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Ball.cpp_3"}},[e._v("12.2 Ball.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.h_5"}},[e._v("12.3 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp_5"}},[e._v("12.4 Paddle.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameState.h_2"}},[e._v("12.5 PongGameState.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameState.cpp_2"}},[e._v("12.6 PongGameState.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Goals.2FPaddle_AI"}},[e._v("13 Goals/Paddle AI")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Paddle_2"}},[e._v("13.1 Paddle")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Paddle.h_6"}},[e._v("13.1.1 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp_6"}},[e._v("13.1.2 Paddle.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PaddleAI"}},[e._v("13.2 PaddleAI")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PaddleAI.h"}},[e._v("13.2.1 PaddleAI.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PaddleAI.cpp"}},[e._v("13.2.2 PaddleAI.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Goal"}},[e._v("13.3 Goal")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Goal.h_2"}},[e._v("13.3.1 Goal.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Goal.cpp_2"}},[e._v("13.3.2 Goal.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#GameMode"}},[e._v("13.4 GameMode")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongGameMode.h_5"}},[e._v("13.4.1 PongGameMode.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameMode.cpp_5"}},[e._v("13.4.2 PongGameMode.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#GameState"}},[e._v("13.5 GameState")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongGameState.h_3"}},[e._v("13.5.1 PongGameState.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameState.cpp_3"}},[e._v("13.5.2 PongGameState.cpp")])])])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Creating_the_HUD_.2F_Finishing_up"}},[e._v("14 Creating the HUD / Finishing up")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#Pong_HUD"}},[e._v("14.1 Pong HUD")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"#PongHUD.h"}},[e._v("14.1.1 PongHUD.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongHUD.cpp"}},[e._v("14.1.2 PongHUD.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.h_7"}},[e._v("14.2 Paddle.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Paddle.cpp_7"}},[e._v("14.3 Paddle.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PaddleAI.h_2"}},[e._v("14.4 PaddleAI.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PaddleAI.cpp_2"}},[e._v("14.5 PaddleAI.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Ball.h_4"}},[e._v("14.6 Ball.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Ball.cpp_4"}},[e._v("14.7 Ball.cpp")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameState.h_4"}},[e._v("14.8 PongGameState.h")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#PongGameState.cpp_4"}},[e._v("14.9 PongGameState.cpp")])])])]),e._v(" "),n("li",[n("a",{attrs:{href:"#Finished"}},[e._v("15 Finished")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#All_Source_Files"}},[e._v("16 All Source Files")])])]),e._v(" "),n("h2",{attrs:{id:"creating-the-project"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-project"}},[e._v("#")]),e._v(" Creating the Project")]),e._v(" "),n("p",[e._v("So, this tutorial is being written for version 4.8.0 of the Engine. If you are using an older version, I would recommend upgrading to the latest.")]),e._v(" "),n("ol",[n("li",[e._v("Launch the Engine")]),e._v(" "),n("li",[e._v("Click on New Project")]),e._v(" "),n("li",[e._v("Select Blueprint -> Blank - We just want to start with a completely empty project")]),e._v(" "),n("li",[e._v("Target Desktop/Console, Scalable 3D or 2D graphics, and No Starter Content")]),e._v(" "),n("li",[e._v("Select a Location for your project and a name - I used Pong")])]),e._v(" "),n("h2",{attrs:{id:"setting-up-the-world"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#setting-up-the-world"}},[e._v("#")]),e._v(" Setting Up the World")]),e._v(" "),n("ol",[n("li",[e._v("Go to the World Outliner in the right hand corner and delete everything under the World - Atmospheric Fog, Floor, Light Source, etc...")]),e._v(" "),n("li",[e._v("Click Save and Save as PongMap")])]),e._v(" "),n("p",[e._v("Now we have a completely blank project with nothing in the world. So what is next?")]),e._v(" "),n("h2",{attrs:{id:"creating-the-assets"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-assets"}},[e._v("#")]),e._v(" Creating the Assets")]),e._v(" "),n("p",[e._v("The Following Assets are needed:")]),e._v(" "),n("p",[e._v("A Paddle")]),e._v(" "),n("p",[e._v("A Background (For the Pong Board)")]),e._v(" "),n("p",[e._v("A Ball")]),e._v(" "),n("p",[e._v("A Goal")]),e._v(" "),n("p",[e._v("A Boundary")]),e._v(" "),n("p",[e._v("So for these, I drew them in paint and made the background transparent. You can download the file here:")]),e._v(" "),n("p",[n("a",{attrs:{href:"/File:PongAssets.png",title:"Pong Assets"}},[n("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/3/37/PongAssets.png",alt:"Pong Assets"}})])]),e._v(" "),n("p",[e._v("Or you can create your own.")]),e._v(" "),n("p",[e._v("Once you have the .png file containing all of the sprites that you are going to use, drag it into the Content part of the Editor and the .png should be loaded in as a texture.")]),e._v(" "),n("p",[e._v("This editor is awesome and allows us to extract the sprites directly from the texture. The editor will handle creating UPaperSprite Objects for us which contain collision/rendering data - how awesome is that?")]),e._v(" "),n("p",[e._v("We are still going to have to modify the collision for the Boundaries however. The collision data for it is that of a filled square but we want a hollow square.")]),e._v(" "),n("ol",[n("li",[e._v("Double click on the Texture")]),e._v(" "),n("li",[e._v("Under Details -> Texture, Expand the Options and for the Filter Select Nearest")]),e._v(" "),n("li",[e._v("Save and close")]),e._v(" "),n("li",[e._v("Right Click on the Texture and Select Sprite Actions -> Extract Sprites")]),e._v(" "),n("li",[e._v("Click Extract. You should now have 5 sprites in your content folder")]),e._v(" "),n("li",[e._v("Right Click on the Content Folder and Select New Folder - Call it Sprites")]),e._v(" "),n("li",[e._v("Drag the five sprites from the Content Folder to the Sprites Folder -> Select Move Here")]),e._v(" "),n("li",[e._v("Rename the black circle to Ball, the black rectangle to Paddle, the large white box to Background, the smaller white rectangle to Goal, and the hollow rectangle to Bounds")])]),e._v(" "),n("p",[e._v("Now we have the sprites that we need to work with to make the pong game!")]),e._v(" "),n("h2",{attrs:{id:"opening-up-the-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#opening-up-the-code"}},[e._v("#")]),e._v(" Opening up the Code")]),e._v(" "),n("p",[e._v("Okay, lets open up the code so that we can start to work with our sprites.")]),e._v(" "),n("ol",[n("li",[e._v("In the Editor, click on File -> New C++ Class"),n("br"),e._v("\nWe are going to be creating the background first, so we are going to want to extend the Actor class"),n("br"),e._v("\nMake sure to read up on the Terminology here: "),n("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/GettingStarted/Terminology/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.unrealengine.com/latest/INT/GettingStarted/Terminology/index.html"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v('Select Actor as the Class to extend and give it the name "Background"')]),e._v(" "),n("li",[e._v("Click Create Class"),n("br"),e._v("\nYour project should be created now. Visual Studio will open up and there should be two .h and .cpp files under Source/Pong - Pong.cpp and Background.cpp")])]),e._v(" "),n("p",[e._v("Before we get started with Creating the background, we are going to be using Paper2D, so we need to first make sure that we are building the Project with that included.")]),e._v(" "),n("ol",[n("li",[e._v("Open Pong/Pong.Build.cs")]),e._v(" "),n("li",[e._v('Add "Paper2D" to the PublicDependency ModuleNames')]),e._v(" "),n("li",[e._v("It should look like this: "),n("code",[e._v('PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "Paper2D" });')]),e._v(" Paper2D will be added as a dependency now.")]),e._v(" "),n("li",[e._v("Go back into the Editor and select File -> Refresh Visual Studio Project"),n("br"),e._v("\nThis will update the project so that you can see the Paper2D headers via intellisense.")])]),e._v(" "),n("h2",{attrs:{id:"creating-the-background"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-background"}},[e._v("#")]),e._v(" Creating the Background")]),e._v(" "),n("p",[e._v("So, now we need to get our Background sprite and make it so that the Background Class we created will render the sprite to the screen. In the Unreal Engine, Components are used in order to create a modular way to attach functionality to objects. You can read up on components in the UE4 Documentation here: "),n("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/Components/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Actors/Components/index.html"),n("OutboundLink")],1),n("br"),e._v("\nReally, the documentation is going to be your friend.")]),e._v(" "),n("p",[e._v("So, we have a Background Actor and we want to assign the Background Sprite that we made to it. So, lets take a look at the API reference to find out if there is any class pre-made for us that will save us a ton of time. Take a look at the Paper2D API reference here: "),n("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/API/Plugins/Paper2D/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.unrealengine.com/latest/INT/API/Plugins/Paper2D/index.html"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("You'll notice that if you read the description for each of the Classes in the library, you'll find a UPaperSpriteComponent which is defined as: A component that handles rendering and collision for a single instance of a UPaperSprite asset. This is really nice because we can attach this component to our Actor and have it handle all the rendering and collision. We will want this for each of our sprites (We won't want collision for the background, but we can just disable that).")]),e._v(" "),n("p",[e._v("So, lets create a UPaperSpriteComponent in our Background Class.")]),e._v(" "),n("ol",[n("li",[e._v("Open up Background.h")]),e._v(" "),n("li",[e._v("Add "),n("code",[e._v("const FObjectInitializer& ObjectInitializer")]),e._v(" into the constructor"),n("br"),e._v("\nYou can see this constructor defined in the generated.h file included if you are curious.")]),e._v(" "),n("li",[e._v("Add a private variable "),n("code",[e._v("class UPaperSpriteComponent* Sprite")]),e._v(" We are using the class keyword because we are making a forward declaration so that we don't have to include the header file that defines UPaperSpriteComponent - we will include the header in the .cpp.")]),e._v(" "),n("li",[e._v("You header should look like this:")])]),e._v(" "),n("h3",{attrs:{id:"background-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-h"}},[e._v("#")]),e._v(" Background.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Background.generated.h"\n \nUCLASS()\nclass PONG_API ABackground : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABackground( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n \nprivate:\n \n//Reference to the Background Sprite\nclass UPaperSpriteComponent* Sprite;\n};')]),e._v(" "),n("p",[e._v("Now we want to attach the UPaperSpriteComponent to this Actor in the constructor. We have the Sprite in the header just to have a reference to the Component once we attach it. Now, since we exported the sprites in the editor, there are UPaperSprite objects that are created which we can grab references to.")]),e._v(" "),n("p",[e._v("Also, we can create a default UPaperSpriteComponent and attach it to ABackground through the use of the FObjectInitializer object. We can call the method CreateDefaultSubObject which will attach a SubOject to the Actor and register it. This is doing the same thing as adding a component to an actor via the editor. We are just implementing it in C++.")]),e._v(" "),n("h3",{attrs:{id:"background-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-cpp"}},[e._v("#")]),e._v(" Background.cpp")]),e._v(" "),n("p",[e._v("The code for this is as follows, your Background.cpp should look similar to this:")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Background.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABackground::ABackground( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Background Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BackgroundSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Background\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BackgroundSprite Reference we grabbed\nSprite->SetSprite( BackgroundSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid ABackground::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid ABackground::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}')]),e._v(" "),n("p",[e._v("Ok, now we have a background actor that renders to the background sprite we created. Awesome! Lets test it out.")]),e._v(" "),n("ol",[n("li",[e._v("Save all your files and compile in the editor")]),e._v(" "),n("li",[e._v("In the Content Browser, go to C++ Classes/Pong - Your Background class should be shown in here")]),e._v(" "),n("li",[e._v("Drag it out into your world")])]),e._v(" "),n("p",[e._v("You should now see your sprite in the world. This sprite is going to be used as the background.")]),e._v(" "),n("h2",{attrs:{id:"creating-the-other-sprites"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-other-sprites"}},[e._v("#")]),e._v(" Creating the Other Sprites")]),e._v(" "),n("p",[e._v("We still need to create classes for the other four sprites in the game - The ball and the paddle. The ball is going to be another class that we add which extends Actor - we need it to have a render target and collision.")]),e._v(" "),n("ol",[n("li",[e._v("In the editor, add a C++ class which extends Actor")]),e._v(" "),n("li",[e._v("Name it Ball and click Create class")])]),e._v(" "),n("p",[e._v("We also need a class for the paddle. This class is different in that we are going to be controlling it. So, it is going to have to handle input. For this, we want to extend the Pawn class(The pawn class also extends the Actor Class) which is used when we want to create a controllable object in the world. You might think that the Character Class should be used here instead, but that would be used for a sprite that is going to have animations attached to it. The pong paddle is never going to be animating.")]),e._v(" "),n("ol",[n("li",[e._v("in the editor, add a C++ class which extends Pawn")]),e._v(" "),n("li",[e._v("Name it Paddle and click Create class")])]),e._v(" "),n("p",[e._v("The Code for the .h and .cpp of each class is below - you may want to try to implement these by yourself before looking at how it is impelemented below to get a better feel for the syntax of the Unreal Engine.")]),e._v(" "),n("h3",{attrs:{id:"ball-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-h"}},[e._v("#")]),e._v(" Ball.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Ball.generated.h"\n \nUCLASS()\nclass PONG_API ABall : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABall( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \nprivate:\n \n//Reference to the Sprite Component which contains the ball sprite\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"ball-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-cpp"}},[e._v("#")]),e._v(" Ball.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Ball.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABall::ABall( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Ball Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BallSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Ball\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BallSprite Reference we grabbed\nSprite->SetSprite( BallSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid ABall::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid ABall::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}')]),e._v(" "),n("h3",{attrs:{id:"paddle-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \nprivate:\n \n//Reference to the Sprite Component which contains the paddle sprite\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"paddle-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \n}')]),e._v(" "),n("h3",{attrs:{id:"bounds-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bounds-h"}},[e._v("#")]),e._v(" Bounds.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Bounds.generated.h"\n \nUCLASS()\nclass PONG_API ABounds : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABounds( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n \nprivate:\n \n//Reference to the Component that holds the Bounds Sprite.\nclass UPaperSpriteComponent* Sprite;\n};')]),e._v(" "),n("h3",{attrs:{id:"bounds-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bounds-cpp"}},[e._v("#")]),e._v(" Bounds.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Bounds.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABounds::ABounds( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Bounds Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BoundsSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Bounds\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BoundsSprite Reference we grabbed\nSprite->SetSprite( BoundsSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid ABounds::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid ABounds::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}')]),e._v(" "),n("h3",{attrs:{id:"goal-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#goal-h"}},[e._v("#")]),e._v(" Goal.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Goal.generated.h"\n \nUCLASS()\nclass PONG_API AGoal : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nAGoal( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n \nprivate:\n \n//Reference to the Sprite that represents a pong goal area\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"goal-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#goal-cpp"}},[e._v("#")]),e._v(" Goal.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Goal.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nAGoal::AGoal( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Goal Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> GoalSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Goal\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the GoalSprite Reference we grabbed\nSprite->SetSprite( GoalSpriteRef.Object );\n \n}\n \n// Called when the game starts or when spawned\nvoid AGoal::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid AGoal::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}')]),e._v(" "),n("h2",{attrs:{id:"creating-the-gamemode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-gamemode"}},[e._v("#")]),e._v(" Creating the GameMode")]),e._v(" "),n("p",[e._v("When we start up our game, we are going to want our own custom GameMode override. This is where we will set the DefaultPawnClass, the GameStateClass, and the HudClass. We can also do some initialization here for the game.")]),e._v(" "),n("ol",[n("li",[e._v("Create a C++ class that extends GameMode, call it PongGameMode")]),e._v(" "),n("li",[e._v("In the constructor set the DefaultPawnClass to APaddle::StaticClass()"),n("br"),e._v("\nThis is going to make it so that when you start to play the game, APaddle is spawned which will be the default player-controlled object. You'll notice that there are a bunch of different Objects created in the world by default when you hit play. We are going to be creating custom classes for most of these.")]),e._v(" "),n("li",[e._v("We are going to override the StartPlay() function contained in GameMode.h - You should view the header files to get a feel for all the different functions that you can override")])]),e._v(" "),n("h3",{attrs:{id:"ponggamemode-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-h"}},[e._v("#")]),e._v(" PongGameMode.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameMode.h"\n#include "PongGameMode.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameMode : public AGameMode\n{\nGENERATED_BODY()\n \npublic:\n//Constructor where we set the default classes to initialize\nAPongGameMode( const FObjectInitializer& ObjectInitializer );\n \n//Function called to spawn our pawn objects into the world\nvirtual void StartPlay() override;\n};')]),e._v(" "),n("h3",{attrs:{id:"ponggamemode-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-cpp"}},[e._v("#")]),e._v(" PongGameMode.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameMode.h"\n#include "Paddle.h"\n \n \n \nAPongGameMode::APongGameMode( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nDefaultPawnClass = APaddle::StaticClass();\n}\n \n \nvoid APongGameMode::StartPlay()\n{\n \nSuper::StartPlay();\nSuper::StartMatch();\n}')]),e._v(" "),n("ol",[n("li",[e._v("Save/Compile")]),e._v(" "),n("li",[e._v("In the editor, on the right side under World Settings, Set the GameMode Override to PongGameMode")]),e._v(" "),n("li",[e._v("Save")])]),e._v(" "),n("p",[e._v("Now when you hit Play, A Paddle should be spawned into the game. This is because the PongGameMode creates the default Pawn to spawn as the Paddle.")]),e._v(" "),n("h2",{attrs:{id:"initializing-the-background-camera-paddle-ball"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#initializing-the-background-camera-paddle-ball"}},[e._v("#")]),e._v(" Initializing the Background/Camera/Paddle/Ball")]),e._v(" "),n("p",[e._v("We have a GameMode, Camera, Background, Ball, and Paddle. So now we need to actually spawn all of these actors into our world. To do this, we can make a call "),n("code",[e._v("GetWorld()->SpawnActor")]),e._v(" We will use this to create the Camera.Background, and the Ball. We will also set the PongCameraActor that we spawn to be our focused view. When we spawn the background, we are also going to want to set it's size to take up the entire view that we are looking at, so we will have to make some functions in the PongCameraActor/Background classes in order to help us do that.")]),e._v(" "),n("h3",{attrs:{id:"background"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),n("p",[e._v("For the background, we are going to want a way to set the width/height of the background sprite. So, three functions were created to handle doing this - SetHeight, SetWidth, and SetDimensions")]),e._v(" "),n("h4",{attrs:{id:"background-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-h-2"}},[e._v("#")]),e._v(" Background.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Background.generated.h"\n \nUCLASS()\nclass PONG_API ABackground : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABackground( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Set the Width of this sprite\nvoid SetWidth( float Width );\n \n// Set the Height of this sprite\nvoid SetHeight( float Height );\n \n// Set the Width and Height of this sprite via a FVector2D\nvoid SetDimensions( FVector2D& Dimensions );\n \nprivate:\n \n//Reference to the Background Sprite\nclass UPaperSpriteComponent* Sprite;\n};')]),e._v(" "),n("h4",{attrs:{id:"background-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-cpp-2"}},[e._v("#")]),e._v(" Background.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Background.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABackground::ABackground( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Background Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BackgroundSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Background\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BackgroundSprite Reference we grabbed\nSprite->SetSprite( BackgroundSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid ABackground::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid ABackground::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Set the Width of this sprite\nvoid ABackground::SetWidth( float Width )\n{\n//calculate the new X scale value\nfloat sourceWidth = Sprite->GetSprite()->GetSourceSize().X;\nfloat scale;\n \n//Scale must be > 1 is the sourceWidth < Width and < 1 in the other case\nif ( Width <= sourceWidth )\n{\nscale = sourceWidth / Width;\n}\nelse\n{\nscale = Width / sourceWidth;\n}\n \n//Update the current scale with the new value\nFVector scaleV = Sprite->RelativeScale3D;\nscaleV.X = scale;\nSprite->SetRelativeScale3D( scaleV );\n}\n \n// Set the Height of this sprite\nvoid ABackground::SetHeight( float Height )\n{\n//calculate the new Z scale value (Camera is orientated so that Z is up/down)\nfloat sourceHeight = Sprite->GetSprite()->GetSourceSize().Y;\nfloat scale;\n \n//Scale must be > 1 is the sourceHeight < Height and < 1 in the other case\nif ( Height <= sourceHeight )\n{\nscale = sourceHeight / Height;\n}\nelse\n{\nscale = Height / sourceHeight;\n}\n \n//Update the current scale with the new value\nFVector scaleV = Sprite->RelativeScale3D;\nscaleV.Z = scale;\nSprite->SetRelativeScale3D( scaleV );\n}\n \n//Wrapper around SetHeight and SetWidth for a FVector2D\nvoid ABackground::SetDimensions( FVector2D& Dimensions )\n{\nSetWidth( Dimensions.X );\nSetHeight( Dimensions.Y );\n}')]),e._v(" "),n("h3",{attrs:{id:"pongcamera"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pongcamera"}},[e._v("#")]),e._v(" PongCamera")]),e._v(" "),n("p",[e._v("First, we need to create the class.")]),e._v(" "),n("ol",[n("li",[e._v("Go into the Editor, select New C++ Class")]),e._v(" "),n("li",[e._v("Click the CheckBox for Showing All the Classes")]),e._v(" "),n("li",[e._v('Search for and Select "CameraActor"')]),e._v(" "),n("li",[e._v("Call your new class PongCamera")]),e._v(" "),n("li",[e._v("Create")])]),e._v(" "),n("p",[e._v("Since we are making a 2D type of game, we are going to want to use an Orthographic perspective. The reason for this is that we won't have to worry about the depth of the objects too much (In this game, the y-axis is being used to represent the depth)")]),e._v(" "),n("p",[e._v("By extending the CameraActor class, we will default get a CameraComponent constructed onto our Actor. So, we need to run some initialization on this Class. Also, we need to create a function to get the Dimensions that we can use to set our background object. So, lets make this class.")]),e._v(" "),n("h4",{attrs:{id:"pongcamera-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pongcamera-h"}},[e._v("#")]),e._v(" PongCamera.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "Camera/CameraActor.h"\n#include "PongCamera.generated.h"\n \n/**\n*\n*/\nUCLASS( )\nclass PONG_API APongCamera : public ACameraActor\n{\nGENERATED_BODY( )\n \npublic:\n \nAPongCamera( const FObjectInitializer& ObjectInitializer );\n \n//Get a 2D vector representing the Height/Width of what is being current displayed on the screen\nFVector2D GetViewDimensions();\n \n};')]),e._v(" "),n("h4",{attrs:{id:"pongcamera-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pongcamera-cpp"}},[e._v("#")]),e._v(" PongCamera.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongCamera.h"\n \n \nAPongCamera::APongCamera( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nUCameraComponent* Camera = GetCameraComponent();\n \n//Set the Camera To Orthographic.  Also set the Location and Rotation on the Camera: X is left and right, Z is up and down, Y is depth relative to this camera\nCamera->ProjectionMode = ECameraProjectionMode::Orthographic;\nCamera->SetRelativeLocation( FVector( 0.0f, 100.0f, 0.0f ) );\nCamera->SetRelativeRotation( FRotator( 0.0f, -90.0f, 0.0f ) );\nCamera->SetAbsolute( true, true, true );\n \n}\n \n//Get the Dimensions of what our camera can view\nFVector2D APongCamera::GetViewDimensions()\n{\nUCameraComponent* Camera = GetCameraComponent();\nFVector2D dimensions;\n \n//The width is the Orthographic view Width.  Calculate the height from the Aspect ratio and OrthoWidth\ndimensions.X = Camera->OrthoWidth;\ndimensions.Y = 1 / ( Camera->AspectRatio / Camera->OrthoWidth );\n \nreturn dimensions;\n}')]),e._v(" "),n("h3",{attrs:{id:"paddle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle"}},[e._v("#")]),e._v(" Paddle")]),e._v(" "),n("p",[e._v("For the ball, all we are going to do is set it up to spawn to the left on the board. We also need to remember that our Background has a location of 0,0,0. So, since we want our Paddle to be visible in front of the board, we are going to set the Y value of the paddle to be greater than that of the Background. In this case, we will just set it to 10.")]),e._v(" "),n("p",[e._v("Now, we could make a function in the paddle to set the starting location based on the background dimensions or the camera view. But, we are not going to worry about that and we are just going to hard-code in some values. If you want to attempt to initialize the paddle on the left hand side via a function call, it would make for a good practice exercise at this point.")]),e._v(" "),n("h4",{attrs:{id:"paddle-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h-2"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \nprivate:\n \n//Reference to the Sprite Component which contains the paddle sprite\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h4",{attrs:{id:"paddle-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp-2"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\n \n//Set the location of the Paddle to the Left\nSprite->SetRelativeLocation( FVector( -200.0f, 10.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nSprite->SetAbsolute( true, true, true );\n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \n}')]),e._v(" "),n("h3",{attrs:{id:"ball"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball"}},[e._v("#")]),e._v(" Ball")]),e._v(" "),n("p",[e._v("For the ball, we are going to spawn it right in the middle of the screen instead of to the left with the paddle. This is a very similar setup.")]),e._v(" "),n("h4",{attrs:{id:"ball-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-h-2"}},[e._v("#")]),e._v(" Ball.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Ball.generated.h"\n \nUCLASS()\nclass PONG_API ABall : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABall( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \nprivate:\n \n//Reference to the Sprite Component which contains the ball sprite\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h4",{attrs:{id:"ball-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-cpp-2"}},[e._v("#")]),e._v(" Ball.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Ball.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABall::ABall( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Ball Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BallSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Ball\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BallSprite Reference we grabbed\nSprite->SetSprite( BallSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid ABall::BeginPlay()\n{\nSuper::BeginPlay();\n \n//Set the ball to spawn in the middle of the Board and scale its size down\nSprite->SetRelativeLocation( FVector( 0.0f, 10.0f, 0.0f ) );\nSprite->SetRelativeScale3D( FVector( 0.07f, 1.0f, 0.07f ) );\nSprite->SetAbsolute( true, true, true );\n}\n \n// Called every frame\nvoid ABall::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}')]),e._v(" "),n("h3",{attrs:{id:"ponggamemode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode"}},[e._v("#")]),e._v(" PongGameMode")]),e._v(" "),n("p",[e._v("Finally, we are going to actually spawn everything in the GameMode's StartPlay() function. This is where we are going to tie the background and camera together too.")]),e._v(" "),n("h4",{attrs:{id:"ponggamemode-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-h-2"}},[e._v("#")]),e._v(" PongGameMode.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameMode.h"\n#include "PongGameMode.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameMode : public AGameMode\n{\nGENERATED_BODY()\n \npublic:\n//Constructor where we set the default classes to initialize\nAPongGameMode( const FObjectInitializer& ObjectInitializer );\n \n//Function called to spawn our pawn objects into the world\nvirtual void StartPlay() override;\n};')]),e._v(" "),n("h4",{attrs:{id:"ponggamemode-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-cpp-2"}},[e._v("#")]),e._v(" PongGameMode.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameMode.h"\n#include "Paddle.h"\n#include "PongCamera.h"\n#include "Background.h"\n#include "Ball.h"\n \nAPongGameMode::APongGameMode( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nDefaultPawnClass = APaddle::StaticClass();\n \n}\n \n \nvoid APongGameMode::StartPlay()\n{\nSuper::StartPlay( );\nUWorld* const World = GetWorld();\nif ( World )\n{\nAPongCamera* camera = World->SpawnActor<APongCamera>( APongCamera::StaticClass() );\n \n//Camera is set to the CameraActor created\nWorld->GetFirstPlayerController()->SetViewTarget( camera );\n \n//Set the background to fill up the entire view of the camera\nABackground* background = World->SpawnActor<ABackground>( ABackground::StaticClass() );\nFVector2D dimensions = camera->GetViewDimensions();\nbackground->SetDimensions( dimensions );\n \n//Spawn the Ball into the World\nWorld->SpawnActor<ABall>( ABall::StaticClass() );\n}\n \nSuper::StartMatch();\n}')]),e._v(" "),n("p",[e._v("Play the game and you should see a Pong game in the works! There should be a paddle, a ball, and a background in your view.")]),e._v(" "),n("h2",{attrs:{id:"moving-the-paddle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#moving-the-paddle"}},[e._v("#")]),e._v(" Moving the Paddle")]),e._v(" "),n("p",[e._v("So, now we need to make it where we can move the paddle up and down. To do this, we are going to bind the up and down arrow keys to call a function within the Paddle class. So, lets set this up.")]),e._v(" "),n("ol",[n("li",[e._v("In the editor, go to Edit -> Project Settings")]),e._v(" "),n("li",[e._v("Under Engine go to Input")]),e._v(" "),n("li",[e._v('Create a new Axis Mapping and Call it "Move"')]),e._v(" "),n("li",[e._v("Create two mappings under the group")]),e._v(" "),n("li",[e._v("For the first one, select the Up key and set the scale to 1.0")]),e._v(" "),n("li",[e._v("For the second one, select the Down Key and set the scale to -1.0")]),e._v(" "),n("li",[e._v("Exit out of the Settings")])]),e._v(" "),n("p",[e._v("Go back to Visual Studio and open up Paddle.cpp. We are going to modify this class to handle the input. Now, it may be the case where you want to create your own custom movement component and custom player controller. We are not going to do this because the paddle has very basic movement functionality that can be handled with ease inside the paddle class. I am mentioning this because if you are going to create more complex handling of the Player's will, then you might want your own playercontroller. You can read more on it here: "),n("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Controller/PlayerController/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Controller/PlayerController/"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Ok, now lets bind the input key to our paddle and update the movement of the paddle within the Tick function, please read the comments in the code to see how this is working.")]),e._v(" "),n("h3",{attrs:{id:"paddle-h-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h-3"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \n// Function called to move the paddle.  Scale represents up/down\nvoid MovePaddle( float Scale );\n \nprivate:\n \n//Reference to the Sprite Component which contains the paddle sprite\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"paddle-cpp-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp-3"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n \nObjectInitializer.CreateDefaultSubobject<UPawnMovementComponent>( this, TEXT( "MovementComp" ) );\n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\n \n//Set the location of the Paddle to the Left\nSprite->SetRelativeLocation( FVector( -200.0f, 10.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nSprite->SetAbsolute( true, true, true );\n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// Update the sprites location based on the movement input\nFVector move = GetMovementInputVector();\nFVector location = GetActorLocation();\nlocation += move*DeltaTime;\nSprite->SetRelativeLocation( location );\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \nconst UInputSettings* settings = GetDefault<UInputSettings>( );\n \n//Create movement mappings for upwards and downwards movement, the float value tells if we are moving the paddle up or down\nconst FInputAxisKeyMapping upKey("Move", EKeys::Up, 1.0f);\nconst FInputAxisKeyMapping downKey( "Move", EKeys::Down, -1.0f );\n \n// Add the axis mappings\n// Once this code is executed, these mappings will be added in the editors Input Settings!\n((UInputSettings*)settings)->AddAxisMapping( upKey );\n((UInputSettings*)settings)->AddAxisMapping( downKey );\n \n// Bind the axis - if we press up, the function is called with 1.0.  if we press down, the function is called with -1.0.\n// if we do nothing, the function is called with 0.0f\nInputComponent->BindAxis( "Move", this, &APaddle::MovePaddle );\n \n}\n \nvoid APaddle::MovePaddle( float Scale )\n{\n//Add a movement input, hardcoding in 75.0f for the vector\nFVector direction = FVector( 0.0f, 0.0f, 75.0f );\nGetMovementComponent()->ConsumeInputVector();\nAddMovementInput( direction, Scale );\n}')]),e._v(" "),n("p",[e._v("Running this, you'll notice that the paddle moves up and down but there is a problem! It can go straight off the screen. This is the next issue that we'll have to fix.")]),e._v(" "),n("h2",{attrs:{id:"adding-bounds"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adding-bounds"}},[e._v("#")]),e._v(" Adding Bounds")]),e._v(" "),n("p",[e._v("There are three different bounds that need to be added to the Pong game. Bounds for encompassing the border of the gameboard - you don't want the ball to go off screen ever. Also there need to be bounds for the goals when the pong ball counts as a score for the player or AI.")]),e._v(" "),n("p",[e._v("There are many ways to go about implementing this and I chose to use some sprites in order to handle collisions/overlap events. This seemed like the easiest way to me to create the necessary data to handle collision. Now we are going to go back into some of the classes created earlier and modify them to handle/generate events that we want.")]),e._v(" "),n("h3",{attrs:{id:"bounds"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bounds"}},[e._v("#")]),e._v(" Bounds")]),e._v(" "),n("p",[e._v("The Bounds Class was modified to have a function to set it's scale (Since the bounds are being generated from a Sprite that is relative to the background Sprite, we want these two Objects to have the same scale). We also want the bounds to be set up for collision correctly. It should Block everything. The position of the Bounds should also be the same as the paddle/ball in the world - This is hardcoded to 50.0 units.")]),e._v(" "),n("p",[e._v("Before we go in and modify the code, we need to set the collision to be correct on the sprite itself.")]),e._v(" "),n("ol",[n("li",[e._v("Go to the Bounds Sprite in the editor and double click on it")]),e._v(" "),n("li",[e._v("Click on Edit Collision")]),e._v(" "),n("li",[e._v("You will notice that the collision is set to be a filled rectangle. We DO NOT want this. In order to fix this, we are going to have to modify the collision data of the sprite.")]),e._v(" "),n("li",[e._v("Under Collision/Collision Shapes on the right hand side, delete the current collision shape, we do not want it")]),e._v(" "),n("li",[e._v("Add Four new collision shapes - Each a rectangle that covers one edge of the sprite. Use the tips in the top-left of the editor for help with how to insert/remove vertices.")])]),e._v(" "),n("p",[e._v("Once your finished, your collision is probably not going to be perfect, but it will be decent. You can get a feel for working visually with the collision geometry. Now, lets go edit the Bounds Class.")]),e._v(" "),n("h4",{attrs:{id:"bounds-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bounds-h-2"}},[e._v("#")]),e._v(" Bounds.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Bounds.generated.h"\n \nUCLASS()\nclass PONG_API ABounds : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABounds( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Set the X,Y, and Z scale for the sprite\nvoid SetScale( FVector& vector );\n \nprivate:\n \n//Reference to the Component that holds the Bounds Sprite.\nclass UPaperSpriteComponent* Sprite;\n};')]),e._v(" "),n("h4",{attrs:{id:"bounds-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bounds-cpp-2"}},[e._v("#")]),e._v(" Bounds.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Bounds.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABounds::ABounds( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Bounds Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BoundsSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Bounds\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "Bounds" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BoundsSprite Reference we grabbed\nSprite->SetSprite( BoundsSpriteRef.Object );\n \n//Make sure that this component blocks everything\nSprite->GetBodyInstance()->SetCollisionEnabled( ECollisionEnabled::QueryAndPhysics );\nSprite->GetBodyInstance()->SetObjectType( ECollisionChannel::ECC_WorldStatic );\n \n//Don\'t draw this sprite\nSprite->SetVisibility( false );\n \n}\n \n// Called when the game starts or when spawned\nvoid ABounds::BeginPlay()\n{\nSuper::BeginPlay();\n \n//Set the location of the Bounds to be the same as the paddle - This is just hardcoded to 50 units\nSprite->SetRelativeLocation( FVector( 0.0f, 50.f, 0.0f ) );\nSprite->SetAbsolute( true, true, true );\n \n//Ensure that this component\'s name is "Bounds"\nRename( TEXT( "Bounds" ) );\n}\n \n// Called every frame\nvoid ABounds::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Set the X,Y, and Z scale for the sprite\nvoid ABounds::SetScale( FVector& vector )\n{\nSprite->SetRelativeScale3D( vector );\n}')]),e._v(" "),n("p",[e._v("The Background class was also modified to add in an accessor for the Scale. The GameMode was also updated to spawn the bounds.")]),e._v(" "),n("h3",{attrs:{id:"background-h-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-h-3"}},[e._v("#")]),e._v(" Background.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Background.generated.h"\n \nUCLASS()\nclass PONG_API ABackground : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABackground( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Set the Width of this sprite\nvoid SetWidth( float Width );\n \n// Set the Height of this sprite\nvoid SetHeight( float Height );\n \n// Set the Width and Height of this sprite via a FVector2D\nvoid SetDimensions( FVector2D& Dimensions );\n \n// Get the scale\nFVector& GetScale();\n \nprivate:\n \n//Reference to the Background Sprite\nclass UPaperSpriteComponent* Sprite;\n};')]),e._v(" "),n("h3",{attrs:{id:"background-cpp-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background-cpp-3"}},[e._v("#")]),e._v(" Background.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Background.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nABackground::ABackground( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Background Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BackgroundSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Background\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BackgroundSprite Reference we grabbed\nSprite->SetSprite( BackgroundSpriteRef.Object );\n}\n \n// Called when the game starts or when spawned\nvoid ABackground::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid ABackground::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Set the Width of this sprite\nvoid ABackground::SetWidth( float Width )\n{\n//calculate the new X scale value\nfloat sourceWidth = Sprite->GetSprite()->GetSourceSize().X;\nfloat scale;\n \n//Scale must be > 1 is the sourceWidth < Width and < 1 in the other case\nif ( Width <= sourceWidth )\n{\nscale = sourceWidth / Width;\n}\nelse\n{\nscale = Width / sourceWidth;\n}\n \n//Update the current scale with the new value\nFVector scaleV = Sprite->RelativeScale3D;\nscaleV.X = scale;\nSprite->SetRelativeScale3D( scaleV );\n}\n \n// Set the Height of this sprite\nvoid ABackground::SetHeight( float Height )\n{\n//calculate the new Z scale value (Camera is orientated so that Z is up/down)\nfloat sourceHeight = Sprite->GetSprite()->GetSourceSize().Y;\nfloat scale;\n \n//Scale must be > 1 is the sourceHeight < Height and < 1 in the other case\nif ( Height <= sourceHeight )\n{\nscale = sourceHeight / Height;\n}\nelse\n{\nscale = Height / sourceHeight;\n}\n \n//Update the current scale with the new value\nFVector scaleV = Sprite->RelativeScale3D;\nscaleV.Z = scale;\nSprite->SetRelativeScale3D( scaleV );\n}\n \n//Wrapper around SetHeight and SetWidth for a FVector2D\nvoid ABackground::SetDimensions( FVector2D& Dimensions )\n{\nSetWidth( Dimensions.X );\nSetHeight( Dimensions.Y );\n}\n \nFVector& ABackground::GetScale()\n{\nreturn Sprite->RelativeScale3D;\n}')]),e._v(" "),n("h3",{attrs:{id:"ponggamemode-h-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-h-3"}},[e._v("#")]),e._v(" PongGameMode.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameMode.h"\n#include "PongGameMode.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameMode : public AGameMode\n{\nGENERATED_BODY()\n \npublic:\n//Constructor where we set the default classes to initialize\nAPongGameMode( const FObjectInitializer& ObjectInitializer );\n \n//Function called to spawn our pawn objects into the world\nvirtual void StartPlay() override;\n};')]),e._v(" "),n("h3",{attrs:{id:"ponggamemode-cpp-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-cpp-3"}},[e._v("#")]),e._v(" PongGameMode.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameMode.h"\n#include "Paddle.h"\n#include "PongCamera.h"\n#include "Background.h"\n#include "Ball.h"\n#include "Bounds.h"\n#include "Goal.h"\n \nAPongGameMode::APongGameMode( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nDefaultPawnClass = APaddle::StaticClass();\n \n}\n \n \nvoid APongGameMode::StartPlay()\n{\nSuper::StartPlay( );\nUWorld* const World = GetWorld();\nif ( World )\n{\nAPongCamera* camera = World->SpawnActor<APongCamera>( APongCamera::StaticClass() );\n \n//Camera is set to the CameraActor created\nWorld->GetFirstPlayerController()->SetViewTarget( camera );\n \n//Set the background to fill up the entire view of the camera\nABackground* background = World->SpawnActor<ABackground>( ABackground::StaticClass() );\nFVector2D dimensions = camera->GetViewDimensions();\nbackground->SetDimensions( dimensions );\n \n//Spawn the Ball into the World\nWorld->SpawnActor<ABall>( ABall::StaticClass() );\n \nFVector scale = background->GetScale();\n \n//Spawn the Bounds into the World\nABounds* bounds = World->SpawnActor<ABounds>( ABounds::StaticClass() );\nbounds->SetScale( scale );\n}\n \nSuper::StartMatch();\n}')]),e._v(" "),n("p",[e._v("Finally, we want to make it so that the Paddle is unable to move once it hits the bounds. In order to do this, two booleans will be added to the Paddle header - MoveUp and MoveDown. These will represent when the paddle is able to move up and when the paddle is able to move down. In order to set these values, two functions will need to be overridden - NotifyActorBeginOverlap and NotifyActorEndOverlap. These two functions will be called when the Actor Overlaps with another Actor. In this case, we will be waiting for when the paddle starts to overlap with the bounds and we will force the paddle to stop moving.")]),e._v(" "),n("h3",{attrs:{id:"paddle-h-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h-4"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \n// Function called to move the paddle.  Scale represents up/down\nvoid MovePaddle( float Scale );\n \n// Notification when the paddle begins to overlap another Actor\nvirtual void NotifyActorBeginOverlap( AActor* OtherActor ) override;\n \n// Notification when the paddle ends overlap\nvirtual void NotifyActorEndOverlap( AActor* OtherActor ) override;\n \nprotected:\n \n//Reference to the Sprite Component which contains the paddle sprite\nUPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Paddle )\nclass UPaperSpriteComponent* Sprite;\n \nprivate:\n \n//Booleans for keeping track of valid movement directions\nbool MoveUp;\nbool MoveDown;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"paddle-cpp-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp-4"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n \nObjectInitializer.CreateDefaultSubobject<UPawnMovementComponent>( this, TEXT( "MovementComp" ) );\n \n//Can initially move in all directions\nMoveUp = true;\nMoveDown = true;\n \n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\n \n//Set the location of the Paddle to the Left\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nSprite->SetAbsolute( true, true, true );\n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// Update the sprites location based on the movement input\nFVector move = GetMovementInputVector();\nif ( ( MoveUp && move.Z > 0 ) || ( MoveDown && move.Z < 0 ) )\n{\nFVector location = GetActorLocation( );\nlocation += move*DeltaTime;\nSprite->SetRelativeLocation( location );\n}\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \nconst UInputSettings* settings = GetDefault<UInputSettings>( );\n \n//Create movement mappings for upwards and downwards movement, the float value tells if we are moving the paddle up or down\nconst FInputAxisKeyMapping upKey("Move", EKeys::Up, 1.0f);\nconst FInputAxisKeyMapping downKey( "Move", EKeys::Down, -1.0f );\n \n// Add the axis mappings\n// Once this code is executed, these mappings will be added in the editors Input Settings!\n((UInputSettings*)settings)->AddAxisMapping( upKey );\n((UInputSettings*)settings)->AddAxisMapping( downKey );\n \n// Bind the axis - if we press up, the function is called with 1.0.  if we press down, the function is called with -1.0.\n// if we do nothing, the function is called with 0.0f\nInputComponent->BindAxis( "Move", this, &APaddle::MovePaddle );\n \n//Set the sprite to generate overlap events for world-static objects -> The Bounds is set to World Static, so this should generate an overlap event now\nSprite->GetBodyInstance()->SetCollisionEnabled( ECollisionEnabled::QueryAndPhysics );\nSprite->GetBodyInstance()->SetObjectType( ECollisionChannel::ECC_Pawn );\nSprite->GetBodyInstance()->SetResponseToChannel( ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Overlap );\n}\n \nvoid APaddle::MovePaddle( float Scale )\n{\n//Add a movement input, hardcoding in 75.0f for the vector\nFVector direction = FVector( 0.0f, 0.0f, 75.0f );\nGetMovementComponent()->ConsumeInputVector();\nAddMovementInput( direction, Scale );\n}\n \nvoid APaddle::NotifyActorBeginOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\nFVector prev = GetMovementComponent()->GetLastInputVector();\n \n//If moving into a bound, set the movement in that direction to false\nif ( prev.Z > 0.0f )\n{\nMoveUp = false;\n}\nelse if ( prev.Z < 0.0f )\n{\nMoveDown = false;\n}\n \n}\n}\n \nvoid APaddle::NotifyActorEndOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\n//Out of the bounds so enable all movement inputs\nMoveUp = true;\nMoveDown = true;\n}\n}')]),e._v(" "),n("h2",{attrs:{id:"creating-the-gamestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-gamestate"}},[e._v("#")]),e._v(" Creating the GameState")]),e._v(" "),n("p",[e._v("Next, a game state will be added. This is a state machine will handle the custom states that the pong game goes through. Before the game starts and you can move your paddle around, we are going to make it so that you must press the spacebar first. This will be handled in the GameState class as a specific state. We will define custom states in the header of the class.")]),e._v(" "),n("ol",[n("li",[e._v("In the Editor Add a New C++ Class")]),e._v(" "),n("li",[e._v("Select Game State as the Class to Extend")]),e._v(" "),n("li",[e._v('Name the new Class "PongGameState" and Create')])]),e._v(" "),n("p",[e._v("Some states that will be added will be as follows:")]),e._v(" "),n("p",[e._v("WAITING_TO_START")]),e._v(" "),n("p",[e._v("PUSH_BALL")]),e._v(" "),n("p",[e._v("PLAYING")]),e._v(" "),n("p",[e._v("UPDATE_SCORE")]),e._v(" "),n("p",[e._v("These are all personally chosen and you can make whatever you desire. The GameMode will also need to be updated to set this as the default gamestate to use.")]),e._v(" "),n("h3",{attrs:{id:"ponggamestate-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-h"}},[e._v("#")]),e._v(" PongGameState.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameState.h"\n#include "PongGameState.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameState : public AGameState\n{\nGENERATED_BODY()\n \nenum PONG_STATES\n{\nWAITING_TO_START,\nPUSH_BALL,\nPLAYING,\nUPDATE_SCORE\n};\n \npublic:\n \nAPongGameState( const FObjectInitializer& ObjectInitializer );\n \n//Tick called every frame\nvirtual void Tick( float DeltaTime ) override;\n \nprivate:\n \n//The current state the game is in\nPONG_STATES CurrentState;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"ponggamestate-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-cpp"}},[e._v("#")]),e._v(" PongGameState.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameState.h"\n \nAPongGameState::APongGameState( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nPrimaryActorTick.bCanEverTick = true;\nCurrentState = PONG_STATES::WAITING_TO_START;\n}\n \n \nvoid APongGameState::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// If match is in progress, run the custom state machine\nif ( IsMatchInProgress( ) )\n{\nswitch ( CurrentState )\n{\ncase PONG_STATES::WAITING_TO_START:\nCurrentState = PONG_STATES::PUSH_BALL;\nbreak;\n \ncase PONG_STATES::PUSH_BALL:\nCurrentState = PONG_STATES::PLAYING;\nbreak;\n \ncase PONG_STATES::PLAYING:\nbreak;\n \ncase PONG_STATES::UPDATE_SCORE:\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n \ndefault:\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n}\n}\n}')]),e._v(" "),n("h3",{attrs:{id:"ponggamemode-h-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-h-4"}},[e._v("#")]),e._v(" PongGameMode.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameMode.h"\n#include "PongGameMode.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameMode : public AGameMode\n{\nGENERATED_BODY()\n \npublic:\n//Constructor where we set the default classes to initialize\nAPongGameMode( const FObjectInitializer& ObjectInitializer );\n \n//Function called to spawn our pawn objects into the world\nvirtual void StartPlay() override;\n};')]),e._v(" "),n("h3",{attrs:{id:"ponggamemode-cpp-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-cpp-4"}},[e._v("#")]),e._v(" PongGameMode.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameMode.h"\n#include "Paddle.h"\n#include "PongCamera.h"\n#include "Background.h"\n#include "Ball.h"\n#include "Bounds.h"\n#include "Goal.h"\n#include "PongGameState.h"\n \nAPongGameMode::APongGameMode( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n//Set Default Classes\nDefaultPawnClass = APaddle::StaticClass();\nGameStateClass = APongGameState::StaticClass();\n}\n \n \nvoid APongGameMode::StartPlay()\n{\nSuper::StartPlay( );\nUWorld* const World = GetWorld();\nif ( World )\n{\nAPongCamera* camera = World->SpawnActor<APongCamera>( APongCamera::StaticClass() );\n \n//Camera is set to the CameraActor created\nWorld->GetFirstPlayerController()->SetViewTarget( camera );\n \n//Set the background to fill up the entire view of the camera\nABackground* background = World->SpawnActor<ABackground>( ABackground::StaticClass() );\nFVector2D dimensions = camera->GetViewDimensions();\nbackground->SetDimensions( dimensions );\n \n//Spawn the Ball into the World\nWorld->SpawnActor<ABall>( ABall::StaticClass() );\n \nFVector scale = background->GetScale();\n \n//Spawn the Bounds into the World\nABounds* bounds = World->SpawnActor<ABounds>( ABounds::StaticClass() );\nbounds->SetScale( scale );\n}\n \nSuper::StartMatch();\n}')]),e._v(" "),n("h2",{attrs:{id:"adding-movement-to-the-ball"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adding-movement-to-the-ball"}},[e._v("#")]),e._v(" Adding Movement to the Ball")]),e._v(" "),n("p",[e._v("Movement needs to be added to the ball. The ball should start out by shooting off in one direction (Towards the player in this game). In order to do this, the PongGameState class will be modified to cause the ball to shoot off to the left upon reaching the PUSH_BALL state. Also, collision will have to be updated for the Ball so that it interacts with the paddle and the Bounds correctly.")]),e._v(" "),n("p",[e._v("The Ball needs to generate Hit Events, so physics must be simulated. Direction and Speed need to be kept track of for the ball. When a Hit Event Occurs, the direction should be updated so that the Ball is reflected in the right direction. Not only this, but the ball should also gain some velocity moving up/down if it hits the paddle.")]),e._v(" "),n("p",[n("strong",[e._v('Note: There may be updates to some classes that I did not catch. I changed quite a few things. Make sure that in all the custom Classes with sprites that you add "RootComponent = Sprite;" in the constructor. I may have changed some of the initialization around for some of the classes as well')])]),e._v(" "),n("p",[e._v("Some changes that need to be made to get this all working are as follows:")]),e._v(" "),n("p",[e._v("Add a accessor for the Z velocity in the paddle class")]),e._v(" "),n("p",[e._v("Add velocity/direction to the Ball class")]),e._v(" "),n("p",[e._v("Add movement updates in the tick function of the Ball class")]),e._v(" "),n("p",[e._v("Override the NotifyHit event in the Ball class to update the direction/velocity")]),e._v(" "),n("p",[e._v("Update the GameState to shoot off the ball - A function will be added to the Ball Class to start movement")]),e._v(" "),n("h3",{attrs:{id:"ball-h-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-h-3"}},[e._v("#")]),e._v(" Ball.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Ball.generated.h"\n \nUCLASS()\nclass PONG_API ABall : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABall( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to start moving the Ball\nvoid StartMove();\n \n// notify hit\nvirtual void NotifyHit( UPrimitiveComponent* MyComp, AActor* Other, UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit ) override;\n \nprotected:\n \n//Reference to the Sprite Component which contains the ball sprite\nUPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Ball )\nclass UPaperSpriteComponent* Sprite;\n \nprivate:\n \n//The direction the ball is traveling in\nFVector Direction;\n \n//Velocity of the ball.  How Fast it is travelling. Distance/Time\nfloat Velocity;\n};')]),e._v(" "),n("h3",{attrs:{id:"ball-cpp-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-cpp-3"}},[e._v("#")]),e._v(" Ball.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Ball.h"\n#include "PaperSpriteComponent.h"\n#include "Paddle.h"\n \n// Sets default values\nABall::ABall( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Ball Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BallSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Ball\'" ) );\n \n//Find the Material we want to set this ball to: Note, you should have created this in the Editor\n//ConstructorHelpers::FObjectFinder'),n("UPhysicalMaterial",[e._v(' BallPhysicsRef( TEXT( "PhysicalMaterial\'/Game/Materials/BallMaterial\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BallSprite Reference we grabbed\nSprite->SetSprite( BallSpriteRef.Object );\n \nRootComponent = Sprite;\n \n//Set the physics properties\n//Restrict the translation/rotation axis\nSetActorEnableCollision( true );\nSprite->SetEnableGravity( false );\nSprite->SetConstraintMode( EDOFMode::SixDOF );\nSprite->GetBodyInstance()->bLockXRotation = true;\nSprite->GetBodyInstance()->bLockYRotation = true;\nSprite->GetBodyInstance()->bLockZRotation = true;\nSprite->GetBodyInstance()->bLockXTranslation = false;\nSprite->GetBodyInstance()->bLockYTranslation = true;\nSprite->GetBodyInstance()->bLockZTranslation = false;\n \n//Enable Hit Notifies\nSprite->SetNotifyRigidBodyCollision( true );\n \n//Set the ball to spawn in the middle of the Board and scale its size down\nSprite->SetRelativeLocation( FVector( 0.0f, 50.0f, 0.0f ) );\nSprite->SetRelativeScale3D( FVector( 0.07f, 1.0f, 0.07f ) );\nSprite->SetAbsolute( true, true, true );\n \nSprite->SetLinearDamping( 0.0f );\nSprite->SetSimulatePhysics( true );\n \nDirection = FVector( 0.0f, 0.0f, 0.0f );\nVelocity = 0.0f;\n}\n \n// Called when the game starts or when spawned\nvoid ABall::BeginPlay()\n{\nSuper::BeginPlay();\n}\n \n// Called every frame\nvoid ABall::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n//Set a time variable to be < one hundreth of a second\nfloat time = (DeltaTime > 0.01f ? 0.0083f : DeltaTime);\n \n//Update the translation based on the time variable\nFTransform transform = Sprite->GetRelativeTransform();\ntransform.AddToTranslation( Direction * Velocity * time );\nSprite->SetRelativeTransform( transform );\n \n}\n \nvoid ABall::StartMove()\n{\n// Move the ball via setting the Direction and Velocity\nDirection = FVector( -1.0f, 0.0f, 0.0f );\nVelocity = 250.0f;\n}\n \n//The Ball has hit something\nvoid ABall::NotifyHit( UPrimitiveComponent* MyComp, AActor* Other, UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit )\n{\n//Make sure that the physics velocities are set to 0.  We are keeping track of direction/speed.  We want this hit event so that we can easily mirror the direction\nSprite->SetAllPhysicsAngularVelocity( FVector( 0.0f, 0.0f, 0.0f ) );\nSprite->SetAllPhysicsLinearVelocity( FVector( 0.0f, 0.0f, 0.0f ) );\n \n//Mirror the Direction so that we can get the new trajectory of the ball\nDirection = Direction.MirrorByVector( HitNormal );\n \n//If the ball hits the paddle, add Z velocity to the ball (This can become very fast)\nif ( Other->GetName().Equals( "Paddle" ) )\n{\nAPaddle* paddle = (APaddle*)Other;\nDirection.Z += (paddle->GetZVelocity() / Velocity);\n}\n}')])],1),e._v(" "),n("h3",{attrs:{id:"paddle-h-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h-5"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \n// Function called to move the paddle.  Scale represents up/down\nvoid MovePaddle( float Scale );\n \n// Notification when the paddle begins to overlap another Actor\nvirtual void NotifyActorBeginOverlap( AActor* OtherActor ) override;\n \n// Notification when the paddle ends overlap\nvirtual void NotifyActorEndOverlap( AActor* OtherActor ) override;\n \n// How fast the paddle is moving up or down\nfloat GetZVelocity();\n \nprotected:\n \n//Reference to the Sprite Component which contains the paddle sprite\nUPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Paddle )\nclass UPaperSpriteComponent* Sprite;\n \nprivate:\n \n//Booleans for keeping track of valid movement directions\nbool MoveUp;\nbool MoveDown;\n \n//How fast the paddle is moving\nfloat Velocity;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"paddle-cpp-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp-5"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n \nRootComponent = Sprite;\n \nObjectInitializer.CreateDefaultSubobject<UPawnMovementComponent>( this, TEXT( "MovementComp" ) );\n \n//Can initially move in all directions\nMoveUp = true;\nMoveDown = true;\n \n//Set the sprite to generate overlap events for world-static objects -> The Bounds is set to World Static, so this should generate an overlap event now\nSprite->GetBodyInstance()->SetCollisionEnabled( ECollisionEnabled::QueryAndPhysics );\nSprite->GetBodyInstance()->SetObjectType( ECollisionChannel::ECC_Pawn );\nSprite->GetBodyInstance()->SetResponseToChannel( ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Overlap );\n \nSprite->SetSimulatePhysics( false );\n \n//Set the location of the Paddle to the Left\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nSprite->SetAbsolute( true, true, true );\n \n \n \n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\n \n//Ensure that this component\'s name is "Paddle"\nRename( TEXT( "Paddle" ) );\n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// Update the sprites location based on the movement input\nFVector move = GetMovementInputVector();\nif ( ( MoveUp && move.Z > 0 ) || ( MoveDown && move.Z < 0 ) )\n{\nFTransform loc = Sprite->GetRelativeTransform();\nloc.AddToTranslation( move*DeltaTime );\nSprite->SetRelativeTransform( loc );\n}\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \nconst UInputSettings* settings = GetDefault<UInputSettings>( );\n \n//Create movement mappings for upwards and downwards movement, the float value tells if we are moving the paddle up or down\nconst FInputAxisKeyMapping upKey("Move", EKeys::Up, 1.0f);\nconst FInputAxisKeyMapping downKey( "Move", EKeys::Down, -1.0f );\n \n// Add the axis mappings\n// Once this code is executed, these mappings will be added in the editors Input Settings!\n((UInputSettings*)settings)->AddAxisMapping( upKey );\n((UInputSettings*)settings)->AddAxisMapping( downKey );\n \n// Bind the axis - if we press up, the function is called with 1.0.  if we press down, the function is called with -1.0.\n// if we do nothing, the function is called with 0.0f\nInputComponent->BindAxis( "Move", this, &APaddle::MovePaddle );\n \nVelocity = 0.0f;\n}\n \nvoid APaddle::MovePaddle( float Scale )\n{\n//Add a movement input, hardcoding in 75.0f for the vector\nFVector direction = FVector( 0.0f, 0.0f, 75.0f );\nGetMovementComponent()->ConsumeInputVector();\nAddMovementInput( direction, Scale );\nVelocity = Scale * 75.0f;\n}\n \nvoid APaddle::NotifyActorBeginOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\nFVector prev = GetMovementComponent()->GetLastInputVector();\n \n//If moving into a bound, set the movement in that direction to false\nif ( prev.Z > 0.0f )\n{\nMoveUp = false;\n}\nelse if ( prev.Z < 0.0f )\n{\nMoveDown = false;\n}\n \n}\n}\n \nvoid APaddle::NotifyActorEndOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\n//Out of the bounds so enable all movement inputs\nMoveUp = true;\nMoveDown = true;\n}\n}\n \n//Get the ZVelocity (How fast the paddle is moving up or down)\nfloat APaddle::GetZVelocity()\n{\nreturn Velocity;\n}')]),e._v(" "),n("h3",{attrs:{id:"ponggamestate-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-h-2"}},[e._v("#")]),e._v(" PongGameState.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameState.h"\n#include "PongGameState.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameState : public AGameState\n{\nGENERATED_BODY()\n \nenum PONG_STATES\n{\nWAITING_TO_START,\nPUSH_BALL,\nPLAYING,\nUPDATE_SCORE\n};\n \npublic:\n \nAPongGameState( const FObjectInitializer& ObjectInitializer );\n \n//Tick called every frame\nvirtual void Tick( float DeltaTime ) override;\n \n//Mutator for the reference to the Ball\nvoid SetBall( class ABall* Ball );\n \nprivate:\n \n//The current state the game is in\nPONG_STATES CurrentState;\n \n//Reference to the Ball\nclass ABall* Ball;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"ponggamestate-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-cpp-2"}},[e._v("#")]),e._v(" PongGameState.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameState.h"\n#include "Ball.h"\n \nAPongGameState::APongGameState( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nPrimaryActorTick.bCanEverTick = true;\nCurrentState = PONG_STATES::WAITING_TO_START;\n}\n \n \nvoid APongGameState::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// If match is in progress, run the custom state machine\nif ( IsMatchInProgress( ) )\n{\nswitch ( CurrentState )\n{\ncase PONG_STATES::WAITING_TO_START:\nCurrentState = PONG_STATES::PUSH_BALL;\nbreak;\n \ncase PONG_STATES::PUSH_BALL:\nBall->StartMove();\nCurrentState = PONG_STATES::PLAYING;\nbreak;\n \ncase PONG_STATES::PLAYING:\nbreak;\n \ncase PONG_STATES::UPDATE_SCORE:\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n \ndefault:\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n}\n}\n}\n \nvoid APongGameState::SetBall( ABall* Ball )\n{\nthis->Ball = Ball;\n}')]),e._v(" "),n("p",[e._v("The Ball should now move around in the world and collide/bounce off of everything. If you move the paddle and hit the ball, the ball should move up/down in the direction that you hit it.")]),e._v(" "),n("h2",{attrs:{id:"goals-paddle-ai"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#goals-paddle-ai"}},[e._v("#")]),e._v(" Goals/Paddle AI")]),e._v(" "),n("p",[e._v("The next step will be to add in the goals. A way to know when the Ball is overlapping a goal will also need to be known in the gamestate in order to move the state forwards when a goal is made. In order to do this, an overlap event will be added that will be called with the overlap happens.")]),e._v(" "),n("p",[e._v("Also, a PaddleAI class will be made that extends the Paddle Class. This will control the AI for the paddle.")]),e._v(" "),n("ol",[n("li",[e._v("Create a new C++ Class")]),e._v(" "),n("li",[e._v("Select the Paddle Class as the class to extend")]),e._v(" "),n("li",[e._v('Name the new Class "PaddleAI" and create')])]),e._v(" "),n("h3",{attrs:{id:"paddle-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-2"}},[e._v("#")]),e._v(" Paddle")]),e._v(" "),n("p",[e._v("A GetPosition Function has been added to this class in order to get where the paddle currently is. This is used when setting the locations of the Goals because we want the goals to be located behind the paddles. The renaming in the BeginPlay() method was also moved to the GameMode as part of initialization there due to double renaming once the PaddleAI class was created.")]),e._v(" "),n("h4",{attrs:{id:"paddle-h-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h-6"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \n// Function called to move the paddle.  Scale represents up/down\nvoid MovePaddle( float Scale );\n \n// Notification when the paddle begins to overlap another Actor\nvirtual void NotifyActorBeginOverlap( AActor* OtherActor ) override;\n \n// Notification when the paddle ends overlap\nvirtual void NotifyActorEndOverlap( AActor* OtherActor ) override;\n \n// How fast the paddle is moving up or down\nfloat GetZVelocity();\n \n// Get the location of the sprite\nFVector2D GetPosition();\n \nprotected:\n \n//Reference to the Sprite Component which contains the paddle sprite\nUPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Paddle )\nclass UPaperSpriteComponent* Sprite;\n \nprivate:\n \n//Booleans for keeping track of valid movement directions\nbool MoveUp;\nbool MoveDown;\n \n//How fast the paddle is moving\nfloat Velocity;\n \n};')]),e._v(" "),n("h4",{attrs:{id:"paddle-cpp-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp-6"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n \nRootComponent = Sprite;\n \nObjectInitializer.CreateDefaultSubobject<UPawnMovementComponent>( this, TEXT( "MovementComp" ) );\n \n//Can initially move in all directions\nMoveUp = true;\nMoveDown = true;\n \n//Set the sprite to generate overlap events for world-static objects -> The Bounds is set to World Static, so this should generate an overlap event now\nSprite->GetBodyInstance()->SetCollisionEnabled( ECollisionEnabled::QueryAndPhysics );\nSprite->GetBodyInstance()->SetObjectType( ECollisionChannel::ECC_Pawn );\nSprite->GetBodyInstance()->SetResponseToChannel( ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Overlap );\n \nSprite->SetSimulatePhysics( false );\n \n//Set the location of the Paddle to the Left\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nSprite->SetAbsolute( true, true, true );\n \n \n \n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// Update the sprites location based on the movement input\nFVector move = GetMovementInputVector();\nif ( ( MoveUp && move.Z > 0 ) || ( MoveDown && move.Z < 0 ) )\n{\nFTransform loc = Sprite->GetRelativeTransform();\nloc.AddToTranslation( move*DeltaTime );\nSprite->SetRelativeTransform( loc );\n}\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \nconst UInputSettings* settings = GetDefault<UInputSettings>( );\n \n//Create movement mappings for upwards and downwards movement, the float value tells if we are moving the paddle up or down\nconst FInputAxisKeyMapping upKey("Move", EKeys::Up, 1.0f);\nconst FInputAxisKeyMapping downKey( "Move", EKeys::Down, -1.0f );\n \n// Add the axis mappings\n// Once this code is executed, these mappings will be added in the editors Input Settings!\n((UInputSettings*)settings)->AddAxisMapping( upKey );\n((UInputSettings*)settings)->AddAxisMapping( downKey );\n \n// Bind the axis - if we press up, the function is called with 1.0.  if we press down, the function is called with -1.0.\n// if we do nothing, the function is called with 0.0f\nInputComponent->BindAxis( "Move", this, &APaddle::MovePaddle );\n \nVelocity = 0.0f;\n}\n \nvoid APaddle::MovePaddle( float Scale )\n{\n//Add a movement input, hardcoding in 75.0f for the vector\nFVector direction = FVector( 0.0f, 0.0f, 75.0f );\nGetMovementComponent()->ConsumeInputVector();\nAddMovementInput( direction, Scale );\nVelocity = Scale * 75.0f;\n}\n \nvoid APaddle::NotifyActorBeginOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\nFVector prev = GetMovementComponent()->GetLastInputVector();\n \n//If moving into a bound, set the movement in that direction to false\nif ( prev.Z > 0.0f )\n{\nMoveUp = false;\n}\nelse if ( prev.Z < 0.0f )\n{\nMoveDown = false;\n}\n \n}\n}\n \nvoid APaddle::NotifyActorEndOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\n//Out of the bounds so enable all movement inputs\nMoveUp = true;\nMoveDown = true;\n}\n}\n \n//Get the ZVelocity (How fast the paddle is moving up or down)\nfloat APaddle::GetZVelocity()\n{\nreturn Velocity;\n}\n \nFVector2D APaddle::GetPosition()\n{\nFVector2D location;\nlocation.X = Sprite->GetComponentLocation().X;\nlocation.Y = Sprite->GetComponentLocation().Z;\n \nreturn location;\n}')]),e._v(" "),n("h3",{attrs:{id:"paddleai"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddleai"}},[e._v("#")]),e._v(" PaddleAI")]),e._v(" "),n("p",[e._v("The AI Paddle class was created. A SetBall Method was created in order to store a reference to the Ball. This is used in the Tick function for some very simple ai. If the ball is above the paddle, the paddle moves up. If the ball is below the paddle, the paddle moves down. If the paddle and the ball are at the same height, the paddle does not move.")]),e._v(" "),n("h4",{attrs:{id:"paddleai-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddleai-h"}},[e._v("#")]),e._v(" PaddleAI.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "Paddle.h"\n#include "PaddleAI.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APaddleAI : public APaddle\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddleAI( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Ball Reference\nvoid SetBall( class ABall* Ball );\n \nprivate:\n \n//Reference to Ball\nclass ABall* Ball;\n \n};')]),e._v(" "),n("h4",{attrs:{id:"paddleai-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddleai-cpp"}},[e._v("#")]),e._v(" PaddleAI.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PaddleAI.h"\n#include "Ball.h"\n#include "PaperSpriteComponent.h"\n \n \n \n// Sets default values\nAPaddleAI::APaddleAI( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n}\n \n// Called when the game starts or when spawned\nvoid APaddleAI::BeginPlay( )\n{\nSuper::BeginPlay();\nSprite->SetRelativeLocation( FVector( 200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\n}\n \n// Called every frame\nvoid APaddleAI::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// Update the direction the AI should move based on where the Ball is\nif ( Sprite->GetComponentLocation().Z > Ball->GetActorLocation().Z )\n{\nMovePaddle( -1.0f );\n}\nelse if ( Sprite->GetComponentLocation().Z < Ball->GetActorLocation().Z )\n{\nMovePaddle( 1.0f );\n}\nelse\n{\nMovePaddle( 0.0f );\n}\n \n}\n \nvoid APaddleAI::SetBall( ABall* Ball )\n{\nthis->Ball = Ball;\n}')]),e._v(" "),n("h3",{attrs:{id:"goal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#goal"}},[e._v("#")]),e._v(" Goal")]),e._v(" "),n("p",[e._v("The goals were made so that a SetPosition function could be called to set the position of them. There are two goals, the PlayerGoal and the AIGoal. These were spawned and set in the GameMode class shown later on in this tutorial. The goals need to be initialized so that they are not visible and they generate overlap events when a dynamic object(The Ball) collides with it.")]),e._v(" "),n("h4",{attrs:{id:"goal-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#goal-h-2"}},[e._v("#")]),e._v(" Goal.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Goal.generated.h"\n \nUCLASS()\nclass PONG_API AGoal : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nAGoal( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Set the X,Y, and Z scale for the sprite\nvoid SetScale( FVector& vector );\n \n// Set the position of the Goal\nvoid SetPosition( FVector& position );\n \n// Accessor for the width\nfloat GetWidth();\n \nprivate:\n \n//Reference to the Sprite that represents a pong goal area\nclass UPaperSpriteComponent* Sprite;\n \n};')]),e._v(" "),n("h4",{attrs:{id:"goal-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#goal-cpp-2"}},[e._v("#")]),e._v(" Goal.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Goal.h"\n#include "PaperSpriteComponent.h"\n \n// Sets default values\nAGoal::AGoal( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Goal Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> GoalSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Goal\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the GoalSprite Reference we grabbed\nSprite->SetSprite( GoalSpriteRef.Object );\n \nRootComponent = Sprite;\n \n//Make sure that this component overlaps\nSprite->GetBodyInstance()->SetCollisionEnabled( ECollisionEnabled::QueryOnly );\nSprite->GetBodyInstance()->SetObjectType( ECollisionChannel::ECC_WorldStatic );\nSprite->GetBodyInstance()->SetResponseToAllChannels( ECollisionResponse::ECR_Overlap );\nSprite->SetVisibility( false );\n}\n \n// Called when the game starts or when spawned\nvoid AGoal::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid AGoal::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Set the X,Y, and Z scale for the sprite\nvoid AGoal::SetScale( FVector& vector )\n{\nSprite->SetRelativeScale3D( vector );\n}\n \nvoid AGoal::SetPosition( FVector& position )\n{\nSprite->SetRelativeLocation( position );\n}\n \nfloat AGoal::GetWidth()\n{\nreturn Sprite->GetSprite()->GetSourceSize().X;\n}')]),e._v(" "),n("h3",{attrs:{id:"gamemode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gamemode"}},[e._v("#")]),e._v(" GameMode")]),e._v(" "),n("p",[e._v("The gamemode was updated to spawn an AIPaddle, spawn the Goals, rename the paddles/goals, set the positions of the goals, and update the state/aipaddle with references to the Ball. Just a bunch of initialization stuff here.")]),e._v(" "),n("h4",{attrs:{id:"ponggamemode-h-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-h-5"}},[e._v("#")]),e._v(" PongGameMode.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameMode.h"\n#include "PongGameMode.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameMode : public AGameMode\n{\nGENERATED_BODY()\n \npublic:\n//Constructor where we set the default classes to initialize\nAPongGameMode( const FObjectInitializer& ObjectInitializer );\n \n//Function called to spawn our pawn objects into the world\nvirtual void StartPlay() override;\n};')]),e._v(" "),n("h4",{attrs:{id:"ponggamemode-cpp-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamemode-cpp-5"}},[e._v("#")]),e._v(" PongGameMode.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameMode.h"\n#include "Paddle.h"\n#include "PongCamera.h"\n#include "Background.h"\n#include "Ball.h"\n#include "Bounds.h"\n#include "Goal.h"\n#include "PongGameState.h"\n#include "PaddleAI.h"\n \nAPongGameMode::APongGameMode( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n//Set Default Classes\nDefaultPawnClass = APaddle::StaticClass();\nGameStateClass = APongGameState::StaticClass();\n}\n \n \nvoid APongGameMode::StartPlay()\n{\nSuper::StartPlay( );\nUWorld* const World = GetWorld();\nif ( World )\n{\nAPongGameState* gameState = GetGameState<APongGameState>();\nAPongCamera* camera = World->SpawnActor<APongCamera>( APongCamera::StaticClass() );\n \n//Camera is set to the CameraActor created\nWorld->GetFirstPlayerController()->SetViewTarget( camera );\n \n//Set the background to fill up the entire view of the camera\nABackground* background = World->SpawnActor<ABackground>( ABackground::StaticClass() );\nFVector2D dimensions = camera->GetViewDimensions();\nbackground->SetDimensions( dimensions );\n \n//Spawn the Ball into the World\nABall* ball = World->SpawnActor<ABall>( ABall::StaticClass() );\n \nFVector scale = background->GetScale();\n \n//Spawn the Bounds into the World\nABounds* bounds = World->SpawnActor<ABounds>( ABounds::StaticClass() );\nbounds->SetScale( scale );\n \n//Spawn the Player and AI Goals\nAGoal* playerGoal = World->SpawnActor<AGoal>( AGoal::StaticClass() );\nAGoal* aiGoal = World->SpawnActor<AGoal>( AGoal::StaticClass() );\n \nplayerGoal->SetScale( scale );\naiGoal->SetScale( scale );\n \nplayerGoal->Rename( TEXT( "PlayerGoal" ) );\naiGoal->Rename( TEXT( "AIGoal" ) );\n \n//Get a reference to the paddles and rename them\nAPaddle* playerPaddle = (APaddle*)World->GetFirstPlayerController()->GetPawn();\nAPaddleAI* aiPaddle = World->SpawnActor<APaddleAI>( APaddleAI::StaticClass( ) );\nplayerPaddle->Rename( TEXT( "PlayerPaddle" ) );\naiPaddle->Rename( TEXT( "AIPaddle" ) );\n \n//playerGoal spawns on the left, aiGoal on the right\nFVector playerPos, aiPos;\nplayerPos.Y = 50.f;\naiPos.Y = 50.f;\nplayerPos.X = playerPaddle->GetPosition().X - ( playerGoal->GetWidth() * scale.X ) / 2;\naiPos.X = 5.0f + aiPaddle->GetPosition().X + ( playerGoal->GetWidth() * scale.X ) / 2;\nplayerPos.Z = 0.f;\naiPos.Z = 0.f;\n \nplayerGoal->SetPosition( playerPos );\naiGoal->SetPosition( aiPos );\n \ngameState->SetBall( ball );\naiPaddle->SetBall( ball );\n}\n \nSuper::StartMatch();\n}')]),e._v(" "),n("h3",{attrs:{id:"gamestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gamestate"}},[e._v("#")]),e._v(" GameState")]),e._v(" "),n("p",[e._v("The PongGameState was updated majorly for some of these changes made. A UFUNCTION() BallOVerlap function was created. This function was created and registered such that it is called whenever the Ball overlaps with another Actor. Private variables for the score were added in order to keep track of when a score was made. A ResetBoard helper function was also made so that the state machine can call it to reset everything back to initial states after a goal has been scored.")]),e._v(" "),n("h4",{attrs:{id:"ponggamestate-h-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-h-3"}},[e._v("#")]),e._v(" PongGameState.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameState.h"\n#include "PongGameState.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameState : public AGameState\n{\nGENERATED_BODY()\n \nenum PONG_STATES\n{\nWAITING_TO_START,\nPUSH_BALL,\nPLAYING,\nUPDATE_SCORE\n};\n \npublic:\n \nAPongGameState( const FObjectInitializer& ObjectInitializer );\n \n//Tick called every frame\nvirtual void Tick( float DeltaTime ) override;\n \n//Mutator for the reference to the Ball\nvoid SetBall( class ABall* Ball );\n \n//Overlap event for when the ball overlaps\nUFUNCTION()\nvoid BallOverlap( AActor* OtherActor );\n \nprivate:\n//Helper function to Reset the Board to it\'s initial state\nvoid ResetBoard();\n \nprivate:\n \n//The current state the game is in\nPONG_STATES CurrentState;\n \n//Reference to the Ball\nclass ABall* Ball;\n \n//booleans to keep track of when a goal is scored\nbool AIScored;\nbool PlayerScored;\n \n//values to store to the current score\nint AIScore;\nint PlayerScore;\n \n};')]),e._v(" "),n("h4",{attrs:{id:"ponggamestate-cpp-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-cpp-3"}},[e._v("#")]),e._v(" PongGameState.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameState.h"\n#include "Ball.h"\n \nAPongGameState::APongGameState( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nPrimaryActorTick.bCanEverTick = true;\nPlayerScore = 0;\nAIScore = 0;\nCurrentState = PONG_STATES::WAITING_TO_START;\n}\n \n \nvoid APongGameState::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// If match is in progress, run the custom state machine\nif ( IsMatchInProgress( ) )\n{\nswitch ( CurrentState )\n{\ncase PONG_STATES::WAITING_TO_START:\nResetBoard();\nCurrentState = PONG_STATES::PUSH_BALL;\nbreak;\n \ncase PONG_STATES::PUSH_BALL:\nBall->StartMove();\nCurrentState = PONG_STATES::PLAYING;\nbreak;\n \ncase PONG_STATES::PLAYING:\nif ( PlayerScored || AIScored )\n{\nCurrentState = PONG_STATES::WAITING_TO_START;\n}\nbreak;\n \ncase PONG_STATES::UPDATE_SCORE:\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n \ndefault:\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n}\n}\n}\n \nvoid APongGameState::SetBall( ABall* Ball )\n{\nthis->Ball = Ball;\nBall->OnActorBeginOverlap.AddDynamic( this, &APongGameState::BallOverlap );\n}\n \nvoid APongGameState::BallOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "PlayerGoal" ) )\n{\nAIScored = true;\nAIScore++;\n}\n \nif ( OtherActor->GetName().Equals( "AIGoal" ) )\n{\nPlayerScored = true;\nPlayerScore++;\n}\n}\n \nvoid APongGameState::ResetBoard()\n{\nPlayerScored = false;\nAIScored = false;\n}')]),e._v(" "),n("h2",{attrs:{id:"creating-the-hud-finishing-up"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-hud-finishing-up"}},[e._v("#")]),e._v(" Creating the HUD / Finishing up")]),e._v(" "),n("p",[e._v('Collision should be working now. The score should be updating. All that is needed now is a way to display the score and to polish up the states. In order to display the score, a HUD is going to be created. The HUD is going to be used to draw test to the canvas. In our case, we are going to draw the current score of the Pong Game and maybe an Initial text to start the game, something like "Press space to Begin.".')]),e._v(" "),n("h3",{attrs:{id:"pong-hud"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pong-hud"}},[e._v("#")]),e._v(" Pong HUD")]),e._v(" "),n("ol",[n("li",[e._v("Create a new c++ class in the editor")]),e._v(" "),n("li",[e._v("Extend the HUD class")]),e._v(" "),n("li",[e._v('call the new class "PongHUD" and click create')])]),e._v(" "),n("p",[e._v("The HUD is going to go through a Draw Function where it will constantly draw the HUD. Some functions are made for different components to be drawn. The Score is set to always be drawn, and a boolean value controls when the Score is drawn.")]),e._v(" "),n("h4",{attrs:{id:"ponghud-h"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponghud-h"}},[e._v("#")]),e._v(" PongHUD.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/HUD.h"\n#include "PongHUD.generated.h"\n \n/**\n*\n*/\nUCLASS( )\nclass PONG_API APongHUD : public AHUD\n{\nGENERATED_BODY( )\n \n \npublic:\n \nAPongHUD( const FObjectInitializer& ObjectInitializer );\n \nvirtual void DrawHUD() override;\n \n//Display the current Pong Score on the screen\nvoid DisplayScore( );\n \n//Display The text waiting for space\nvoid DisplaySpaceText();\n \n//Set if the waiting for space text should be displayed\nvoid DisplayWaitingForSpace( bool bSpace );\n \n//Set the score to be displayed\nvoid SetScore( int PlayerScore, int AIScore );\n \nprivate:\n \n//The score of the game\nint Score[2];\n \n//Display space text?\nbool bWaitingForSpace;\n};')]),e._v(" "),n("h4",{attrs:{id:"ponghud-cpp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponghud-cpp"}},[e._v("#")]),e._v(" PongHUD.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongHUD.h"\n \n \n \n \nAPongHUD::APongHUD( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nScore[0] = 0;\nScore[1] = 0;\nbWaitingForSpace = false;\n}\n \nvoid APongHUD::DrawHUD( )\n{\nSuper::DrawHUD();\n \nDisplayScore();\n \nif ( bWaitingForSpace )\n{\nDisplaySpaceText();\n}\n}\n \nvoid APongHUD::DisplaySpaceText( )\n{\nFVector2D sLoc;\nGetOwningPlayerController()->ProjectWorldLocationToScreen( FVector( -50.0f, 0.0f, 0.0f ), sLoc );\nFString s = "Press Space to Begin.";\nDrawText( s, FLinearColor::Blue, sLoc.X, sLoc.Y );\n}\n \nvoid APongHUD::DisplayScore()\n{\nFVector2D sLoc;\nGetOwningPlayerController( )->ProjectWorldLocationToScreen( FVector( -50.0f, 0.0f, 150.0f ), sLoc );\nFString s = "Score: " + FString::FromInt( Score[0] ) + " - " + FString::FromInt( Score[1] );\nDrawText( s, FLinearColor::Blue, sLoc.X, sLoc.Y );\n}\n \nvoid APongHUD::SetScore( int PlayerScore, int AIScore)\n{\nScore[0] = PlayerScore;\nScore[1] = AIScore;\n}\n \nvoid APongHUD::DisplayWaitingForSpace( bool bSpace )\n{\nbWaitingForSpace = bSpace;\n}')]),e._v(" "),n("p",[e._v("Helper functions were added to the Ball and Paddle in order to Reset them. This is called from the PongGameState when we go into the RESET state. A boolean, bMoveable was also added to the paddle in order to control when the paddle can move.")]),e._v(" "),n("h3",{attrs:{id:"paddle-h-7"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-h-7"}},[e._v("#")]),e._v(" Paddle.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "Paddle.generated.h"\n \nUCLASS()\nclass PONG_API APaddle : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddle( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \n// Function called to move the paddle.  Scale represents up/down\nvoid MovePaddle( float Scale );\n \n// Notification when the paddle begins to overlap another Actor\nvirtual void NotifyActorBeginOverlap( AActor* OtherActor ) override;\n \n// Notification when the paddle ends overlap\nvirtual void NotifyActorEndOverlap( AActor* OtherActor ) override;\n \n// How fast the paddle is moving up or down\nfloat GetZVelocity();\n \n// Get the location of the sprite\nFVector2D GetPosition();\n \n// Reset the paddles location\nvirtual void Reset();\n \n// Sets if the paddle can be moved\nvoid SetMoveable( bool bMoveable );\n \nprotected:\n \n//Reference to the Sprite Component which contains the paddle sprite\nUPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Paddle )\nclass UPaperSpriteComponent* Sprite;\n \n//Booleans for keeping track of valid movement directions\nbool bMoveUp;\nbool bMoveDown;\n \nprivate:\n \n//How fast the paddle is moving\nfloat Velocity;\n \n//Is the paddle moveable, can it move?\nbool bMoveable;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"paddle-cpp-7"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddle-cpp-7"}},[e._v("#")]),e._v(" Paddle.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Paddle.h"\n#include "PaperSpriteComponent.h"\n \n \n// Sets default values\nAPaddle::APaddle( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Paddle Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> PaddleSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Paddle\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the PaddleSprite Reference we grabbed\nSprite->SetSprite( PaddleSpriteRef.Object );\n \nRootComponent = Sprite;\n \nObjectInitializer.CreateDefaultSubobject<UPawnMovementComponent>( this, TEXT( "MovementComp" ) );\n \n//Can initially move in all directions\nbMoveUp = true;\nbMoveDown = true;\n \n//Set the sprite to generate overlap events for world-static objects -> The Bounds is set to World Static, so this should generate an overlap event now\nSprite->GetBodyInstance()->SetCollisionEnabled( ECollisionEnabled::QueryAndPhysics );\nSprite->GetBodyInstance()->SetObjectType( ECollisionChannel::ECC_Pawn );\nSprite->GetBodyInstance()->SetResponseToChannel( ECollisionChannel::ECC_WorldStatic, ECollisionResponse::ECR_Overlap );\n \nSprite->SetSimulatePhysics( false );\n \n//Set the location of the Paddle to the Left\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nSprite->SetAbsolute( true, true, true );\n \n \n \n}\n \n// Called when the game starts or when spawned\nvoid APaddle::BeginPlay()\n{\nSuper::BeginPlay();\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\n}\n \n// Called every frame\nvoid APaddle::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// Update the sprites location based on the movement input\nFVector move = GetMovementInputVector();\nif ( ( ( bMoveUp && move.Z > 0 ) || ( bMoveDown && move.Z < 0 ) ) && bMoveable )\n{\nFTransform loc = Sprite->GetRelativeTransform();\nloc.AddToTranslation( move*DeltaTime );\nSprite->SetRelativeTransform( loc );\n}\n \n}\n \n// Called to bind functionality to input\nvoid APaddle::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \nconst UInputSettings* settings = GetDefault<UInputSettings>( );\n \n//Create movement mappings for upwards and downwards movement, the float value tells if we are moving the paddle up or down\nconst FInputAxisKeyMapping upKey("Move", EKeys::Up, 1.0f);\nconst FInputAxisKeyMapping downKey( "Move", EKeys::Down, -1.0f );\n \n// Add the axis mappings\n// Once this code is executed, these mappings will be added in the editors Input Settings!\n((UInputSettings*)settings)->AddAxisMapping( upKey );\n((UInputSettings*)settings)->AddAxisMapping( downKey );\n \n// Bind the axis - if we press up, the function is called with 1.0.  if we press down, the function is called with -1.0.\n// if we do nothing, the function is called with 0.0f\nInputComponent->BindAxis( "Move", this, &APaddle::MovePaddle );\n \nVelocity = 0.0f;\n}\n \nvoid APaddle::MovePaddle( float Scale )\n{\n//Add a movement input, hardcoding in 75.0f for the vector\nFVector direction = FVector( 0.0f, 0.0f, 75.0f );\nGetMovementComponent()->ConsumeInputVector();\nAddMovementInput( direction, Scale );\nVelocity = Scale * 75.0f;\n}\n \nvoid APaddle::NotifyActorBeginOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\nFVector prev = GetMovementComponent()->GetLastInputVector();\n \n//If moving into a bound, set the movement in that direction to false\nif ( prev.Z > 0.0f )\n{\nbMoveUp = false;\n}\nelse if ( prev.Z < 0.0f )\n{\nbMoveDown = false;\n}\n \n}\n}\n \nvoid APaddle::NotifyActorEndOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "Bounds" ) )\n{\n//Out of the bounds so enable all movement inputs\nbMoveUp = true;\nbMoveDown = true;\n}\n}\n \n//Get the ZVelocity (How fast the paddle is moving up or down)\nfloat APaddle::GetZVelocity()\n{\nreturn Velocity;\n}\n \nFVector2D APaddle::GetPosition()\n{\nFVector2D location;\nlocation.X = Sprite->GetComponentLocation().X;\nlocation.Y = Sprite->GetComponentLocation().Z;\n \nreturn location;\n}\n \n// Reset the paddles location\nvoid APaddle::Reset()\n{\nSprite->SetRelativeLocation( FVector( -200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nSprite->SetRelativeScale3D( FVector( 0.1f, 1.0f, 0.1f ) );\nbMoveUp = true;\nbMoveDown = true;\n}\n \nvoid APaddle::SetMoveable( bool bMoveable )\n{\nthis->bMoveable = bMoveable;\n}')]),e._v(" "),n("h3",{attrs:{id:"paddleai-h-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddleai-h-2"}},[e._v("#")]),e._v(" PaddleAI.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "Paddle.h"\n#include "PaddleAI.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APaddleAI : public APaddle\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAPaddleAI( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Ball Reference\nvoid SetBall( class ABall* Ball );\n \n// AI Paddle Reset override\nvirtual void Reset() override;\n \nprivate:\n \n//Reference to Ball\nclass ABall* Ball;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"paddleai-cpp-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#paddleai-cpp-2"}},[e._v("#")]),e._v(" PaddleAI.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PaddleAI.h"\n#include "Ball.h"\n#include "PaperSpriteComponent.h"\n \n \n \n// Sets default values\nAPaddleAI::APaddleAI( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n}\n \n// Called when the game starts or when spawned\nvoid APaddleAI::BeginPlay( )\n{\nSuper::BeginPlay();\nSprite->SetRelativeLocation( FVector( 200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\n}\n \n// Called every frame\nvoid APaddleAI::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n//Paddle AI can always move\nbMoveUp = true;\nbMoveDown = true;\n \n// Update the direction the AI should move based on where the Ball is\nif ( Sprite->GetComponentLocation().Z > Ball->GetActorLocation().Z )\n{\nMovePaddle( -1.0f );\n}\nelse if ( Sprite->GetComponentLocation().Z < Ball->GetActorLocation().Z )\n{\nMovePaddle( 1.0f );\n}\nelse\n{\nMovePaddle( 0.0f );\n}\n \n}\n \nvoid APaddleAI::SetBall( ABall* Ball )\n{\nthis->Ball = Ball;\n}\n \n// Reset the paddles location\nvoid APaddleAI::Reset( )\n{\nSprite->SetRelativeLocation( FVector( 200.0f, 50.f, 0.0f ) );\nSprite->SetRelativeRotation( FRotator( 0.f, 0.f, 0.f ) );\nbMoveUp = true;\nbMoveDown = true;\n}')]),e._v(" "),n("h3",{attrs:{id:"ball-h-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-h-4"}},[e._v("#")]),e._v(" Ball.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Actor.h"\n#include "Ball.generated.h"\n \nUCLASS()\nclass PONG_API ABall : public AActor\n{\nGENERATED_BODY()\n \npublic:\t\n// Sets default values for this actor\'s properties\nABall( const FObjectInitializer& ObjectInitializer );\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to start moving the Ball\nvoid StartMove();\n \n// notify hit\nvirtual void NotifyHit( UPrimitiveComponent* MyComp, AActor* Other, UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit ) override;\n \n// Reset the Ball\nvoid Reset();\n \nprotected:\n \n//Reference to the Sprite Component which contains the ball sprite\nUPROPERTY( EditAnywhere, BlueprintReadWrite, Category = Ball )\nclass UPaperSpriteComponent* Sprite;\n \nprivate:\n \n//The direction the ball is traveling in\nFVector Direction;\n \n//Velocity of the ball.  How Fast it is travelling. Distance/Time\nfloat Velocity;\n};')]),e._v(" "),n("h3",{attrs:{id:"ball-cpp-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ball-cpp-4"}},[e._v("#")]),e._v(" Ball.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "Ball.h"\n#include "PaperSpriteComponent.h"\n#include "Paddle.h"\n \n// Sets default values\nABall::ABall( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n//Find the Ball Sprite -- Right click on your sprite in the editor and click copy reference to get the path to it\nConstructorHelpers::FObjectFinder<UPaperSprite> BallSpriteRef( TEXT( "PaperSprite\'/Game/Sprites/Ball\'" ) );\n \n//Create a default UPaperSpriteComponent and register it to this Actor\nSprite = ObjectInitializer.CreateDefaultSubobject<UPaperSpriteComponent>( this, TEXT( "SpriteComp" ) );\n \n//Set the Sprite to render for the UPaperSpriteComponent to the BallSprite Reference we grabbed\nSprite->SetSprite( BallSpriteRef.Object );\n \nRootComponent = Sprite;\n \n//Set the physics properties\n//Restrict the translation/rotation axis\nSetActorEnableCollision( true );\nSprite->SetEnableGravity( false );\nSprite->SetConstraintMode( EDOFMode::SixDOF );\nSprite->GetBodyInstance()->bLockXRotation = true;\nSprite->GetBodyInstance()->bLockYRotation = true;\nSprite->GetBodyInstance()->bLockZRotation = true;\nSprite->GetBodyInstance()->bLockXTranslation = false;\nSprite->GetBodyInstance()->bLockYTranslation = true;\nSprite->GetBodyInstance()->bLockZTranslation = false;\n \n//Enable Hit Notifies\nSprite->SetNotifyRigidBodyCollision( true );\n \n//Set the ball to spawn in the middle of the Board and scale its size down\nSprite->SetRelativeLocation( FVector( 0.0f, 50.0f, 0.0f ) );\nSprite->SetRelativeScale3D( FVector( 0.07f, 1.0f, 0.07f ) );\nSprite->SetAbsolute( true, true, true );\n \nSprite->SetLinearDamping( 0.0f );\nSprite->SetSimulatePhysics( true );\n \nDirection = FVector( 0.0f, 0.0f, 0.0f );\nVelocity = 0.0f;\n}\n \n// Called when the game starts or when spawned\nvoid ABall::BeginPlay()\n{\nSuper::BeginPlay();\n}\n \n// Called every frame\nvoid ABall::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n//Set a time variable to be < one hundreth of a second\nfloat time = (DeltaTime > 0.01f ? 0.0083f : DeltaTime);\n \n//Update the translation based on the time variable\nFTransform transform = Sprite->GetRelativeTransform();\ntransform.AddToTranslation( Direction * Velocity * time );\nSprite->SetRelativeTransform( transform );\n \n}\n \nvoid ABall::StartMove()\n{\n// Move the ball via setting the Direction and Velocity\nDirection = FVector( -1.0f, 0.0f, 0.0f );\nVelocity = 250.0f;\n}\n \n//The Ball has hit something\nvoid ABall::NotifyHit( UPrimitiveComponent* MyComp, AActor* Other, UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit )\n{\n//Make sure that the physics velocities are set to 0.  We are keeping track of direction/speed.  We want this hit event so that we can easily mirror the direction\nSprite->SetAllPhysicsAngularVelocity( FVector( 0.0f, 0.0f, 0.0f ) );\nSprite->SetAllPhysicsLinearVelocity( FVector( 0.0f, 0.0f, 0.0f ) );\n \n//Mirror the Direction so that we can get the new trajectory of the ball\nDirection = Direction.MirrorByVector( HitNormal );\n \n//If the ball hits the paddle, add Z velocity to the ball (This can become very fast)\nif ( Other->GetName().Contains( "Paddle" ) )\n{\nAPaddle* paddle = (APaddle*)Other;\nDirection.Z += (paddle->GetZVelocity() / Velocity);\n}\n}\n \nvoid ABall::Reset()\n{\nSprite->SetRelativeLocation( FVector( 0.0f, 50.0f, 0.0f ) );\nSprite->SetRelativeScale3D( FVector( 0.07f, 1.0f, 0.07f ) );\nDirection = FVector( 0.0f, 0.0f, 0.0f );\nVelocity = 0.0f;\n}')]),e._v(" "),n("p",[e._v("Finally, the GameState was updated significantly. The states were all filled in.")]),e._v(" "),n("h3",{attrs:{id:"ponggamestate-h-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-h-4"}},[e._v("#")]),e._v(" PongGameState.h")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/GameState.h"\n#include "PongGameState.generated.h"\n \n/**\n*\n*/\nUCLASS()\nclass PONG_API APongGameState : public AGameState\n{\nGENERATED_BODY()\n \nenum PONG_STATES\n{\nRESET,\nWAITING_TO_START,\nPUSH_BALL,\nPLAYING\n};\n \npublic:\n \nAPongGameState( const FObjectInitializer& ObjectInitializer );\n \n//Called when play begins\nvirtual void BeginPlay() override;\n \n//Tick called every frame\nvirtual void Tick( float DeltaTime ) override;\n \n//Mutator for the reference to the Ball\nvoid SetBall( class ABall* Ball );\n \n//Overlap event for when the ball overlaps\nUFUNCTION()\nvoid BallOverlap( AActor* OtherActor );\n \nprivate:\n//Helper function to Reset the Board to it\'s initial state\nvoid ResetBoard();\n \nprivate:\n \n//The current state the game is in\nPONG_STATES CurrentState;\n \n//Reference to the Ball\nclass ABall* Ball;\n \n//booleans to keep track of when a goal is scored\nbool bAIScored;\nbool bPlayerScored;\n \n//values to store to the current score\nint AIScore;\nint PlayerScore;\n \n//Reference to the controller used for the paddle\nclass APlayerController* Controller;\nclass APongHUD* HUD;\n \n};')]),e._v(" "),n("h3",{attrs:{id:"ponggamestate-cpp-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ponggamestate-cpp-4"}},[e._v("#")]),e._v(" PongGameState.cpp")]),e._v(" "),n("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#include "Pong.h"\n#include "PongGameState.h"\n#include "Ball.h"\n#include "Paddle.h"\n#include "PongHUD.h"\n \nAPongGameState::APongGameState( const FObjectInitializer& ObjectInitializer )\n: Super( ObjectInitializer )\n{\nPrimaryActorTick.bCanEverTick = true;\nPlayerScore = 0;\nAIScore = 0;\nCurrentState = PONG_STATES::WAITING_TO_START;\n}\n \nvoid APongGameState::BeginPlay()\n{\nSuper::BeginPlay();\n \nController = GetWorld()->GetFirstPlayerController();\nHUD = (APongHUD*)Controller->GetHUD();\n}\n \nvoid APongGameState::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n// If match is in progress, run the custom state machine\nif ( IsMatchInProgress( ) )\n{\nswitch ( CurrentState )\n{\ncase PONG_STATES::RESET:\nResetBoard();\nfor ( auto it = GetWorld( )->GetPawnIterator( ); it.GetIndex( ) < GetWorld( )->GetNumPawns( ); it++ )\n{\n( (APaddle*)it->Get() )->SetMoveable( false );\n}\nCurrentState = PONG_STATES::WAITING_TO_START;\nbreak;\n \ncase PONG_STATES::WAITING_TO_START:\nHUD->DisplayWaitingForSpace( true );\nif ( Controller->WasInputKeyJustReleased( EKeys::SpaceBar ) )\n{\nHUD->DisplayWaitingForSpace( false );\nfor ( auto it = GetWorld( )->GetPawnIterator( ); it.GetIndex( ) < GetWorld( )->GetNumPawns( ); it++ )\n{\n( (APaddle*)it->Get() )->SetMoveable( true );\n}\nCurrentState = PONG_STATES::PUSH_BALL;\n}\nbreak;\n \ncase PONG_STATES::PUSH_BALL:\nBall->StartMove();\nCurrentState = PONG_STATES::PLAYING;\nbreak;\n \ncase PONG_STATES::PLAYING:\nif (bPlayerScored || bAIScored )\n{\nHUD->SetScore( PlayerScore, AIScore );\nCurrentState = PONG_STATES::RESET;\n}\nbreak;\n \ndefault:\nCurrentState = PONG_STATES::RESET;\nbreak;\n}\n}\n}\n \nvoid APongGameState::SetBall( ABall* Ball )\n{\nthis->Ball = Ball;\nBall->OnActorBeginOverlap.AddDynamic( this, &APongGameState::BallOverlap );\n}\n \nvoid APongGameState::BallOverlap( AActor* OtherActor )\n{\nif ( OtherActor->GetName().Equals( "PlayerGoal" ) )\n{\nbAIScored = true;\nAIScore++;\n}\n \nif ( OtherActor->GetName().Equals( "AIGoal" ) )\n{\nbPlayerScored = true;\nPlayerScore++;\n}\n}\n \nvoid APongGameState::ResetBoard()\n{\n \nbPlayerScored = false;\nbAIScored = false;\n \n// Reset the paddles\nfor ( auto it = GetWorld( )->GetPawnIterator( ); it.GetIndex( ) < GetWorld( )->GetNumPawns( ); it++ )\n{\n( (APaddle*)it->Get() )->Reset( );\n}\n \nBall->Reset();\n \n}')]),e._v(" "),n("h2",{attrs:{id:"finished"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#finished"}},[e._v("#")]),e._v(" Finished")]),e._v(" "),n("p",[e._v("And that is Pong, Congratulations!")]),e._v(" "),n("h2",{attrs:{id:"all-source-files"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#all-source-files"}},[e._v("#")]),e._v(" All Source Files")]),e._v(" "),n("p",[e._v("Here are all of the final source files zipped up: "),n("a",{attrs:{href:"/File:PongSource.zip",title:"File:PongSource.zip"}},[e._v("File:PongSource.zip")])]),e._v(" "),n("p",[n("strong",[e._v("Author:")]),e._v(" Igne")]),e._v(" "),n("p",[e._v('Retrieved from "'),n("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Pong_Tutorial&oldid=17207",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Pong_Tutorial&oldid=17207"),n("OutboundLink")],1),e._v('"')]),e._v(" "),n("p",[n("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Categories")]),e._v(":")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])]),e._v(" "),n("li",[n("a",{attrs:{href:"/Category:Community_Created_Content",title:"Category:Community Created Content"}},[e._v("Community Created Content")])])]),e._v(" "),n("p",[n("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=o.exports}}]);