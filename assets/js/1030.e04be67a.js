(window.webpackJsonp=window.webpackJsonp||[]).push([[1030],{607:function(t,e,r){"use strict";r.r(e);var a=r(28),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("Structs, USTRUCTS(), They're Awesome - Epic Wiki")]),t._v(" "),r("h1",{attrs:{id:"structs-ustructs-they-re-awesome"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#structs-ustructs-they-re-awesome"}},[t._v("#")]),t._v(" Structs, USTRUCTS(), They're Awesome")]),t._v(" "),r("p",[t._v("(Redirected from "),r("a",{attrs:{href:"/index.php?title=Structs,_USTRUCTS(),_UE4_C%2B%2B_Structs&redirect=no",title:"Structs, USTRUCTS(), UE4 C++ Structs"}},[t._v("Structs, USTRUCTS(), UE4 C++ Structs")]),t._v(")")]),t._v(" "),r("h2",{attrs:{id:"contents"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[t._v("#")]),t._v(" Contents")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Overview"}},[t._v("1 Overview")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Technical"}},[t._v("1.1 Technical")])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Core_Syntax"}},[t._v("2 Core Syntax")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Examples"}},[t._v("3 Examples")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Example_1"}},[t._v("3.1 Example 1")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Example_2"}},[t._v("3.2 Example 2")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Particle_Data_Tracker"}},[t._v("3.2.1 Particle Data Tracker")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Garbage_Collection"}},[t._v("3.2.2 Garbage Collection")])])])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Structs_With_Struct_Member_Variables"}},[t._v("4 Structs With Struct Member Variables")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Struct_Assignment"}},[t._v("5 Struct Assignment")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Deep_Copy"}},[t._v("5.1 Deep Copy")])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Automatic_Make.2FBreak_in_BP"}},[t._v("6 Automatic Make/Break in BP")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Replication"}},[t._v("7 Replication")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Related_Links"}},[t._v("8 Related Links")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Thank_You_Epic_for_USTRUCTS.28.29"}},[t._v("9 Thank You Epic for USTRUCTS()")])])]),t._v(" "),r("h2",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[t._v("#")]),t._v(" Overview")]),t._v(" "),r("p",[r("em",[t._v("Original Author:")]),t._v(" "),r("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),r("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),r("p",[t._v("Structs enable you to create custom variable types to organize your data, by relating other c++ or UE4 C++ data types to each other.")]),t._v(" "),r("p",[t._v("The power of structs is "),r("strong",[t._v("extreme organization")]),t._v(", as well as ability to have functions for internal data type operations!")]),t._v(" "),r("h3",{attrs:{id:"technical"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#technical"}},[t._v("#")]),t._v(" Technical")]),t._v(" "),r("p",[t._v("Structs enable you to create custom variable types to organize your data, by relating other C++ or UE4 C++ data types to each other. The power of structs is "),r("strong",[t._v("extreme organization")]),t._v(" as well as the ability to have functions for "),r("strong",[t._v("internal data type operations")]),t._v(". '")]),t._v(" "),r("p",[t._v("In UE4, structs should be used for simple data type combining and data management purposes. For complex interactions with the game world, you should make a UObject or AActor subclass instead.")]),t._v(" "),r("h2",{attrs:{id:"core-syntax"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#core-syntax"}},[t._v("#")]),t._v(" Core Syntax")]),t._v(" "),r("p",[t._v("//If you want this to appear in BP, make sure to use this instead\n//USTRUCT(BlueprintType)\nUSTRUCT()\nstruct FJoyStruct\n{\nGENERATED_BODY()\n \n//Always make USTRUCT variables into UPROPERTY()\n//    any non-UPROPERTY() struct vars are not replicated\n \n// So to simplify your life for later debugging, always use UPROPERTY()\nUPROPERTY()\nint32 SampleInt32;\n \nUPROPERTY()\nAActor* TargetActor;\n \n//Set\nvoid SetInt(const int32 NewValue)\n{\nSampleInt32 = NewValue;\n}\n \n//Get\nAActor* GetActor()\n{\nreturn TargetActor;\n}\n \n//Check\nbool ActorIsValid() const\n{\nif(!TargetActor) return false;\nreturn TargetActor->IsValidLowLevel();\n}\n \n//Constructor\nFJoyStruct()\n{\n//Always initialize your USTRUCT variables!\n//   exception is if you know the variable type has its own default constructor\nSampleInt32 \t= 5;\nTargetActor = NULL;\n}\n};")]),t._v(" "),r("p",[r("em",[t._v("Additional Note Author:")]),t._v(" "),r("a",{attrs:{href:"/index.php?title=User:DesertEagle_PWN&action=edit&redlink=1",title:"User:DesertEagle PWN (page does not exist)"}},[t._v("DesertEagle_PWN")]),t._v(" ("),r("a",{attrs:{href:"/index.php?title=User_talk:DesertEagle_PWN&action=edit&redlink=1",title:"User talk:DesertEagle PWN (page does not exist)"}},[t._v("talk")]),t._v(")"),r("br"),t._v("\nAdditional Note: The idea of USTRUCTS() is to declare engine data types that are in global scope and can be accessed by other classes/structs/blueprints. Because of this, it is invalid UE4 syntax to declare a struct inside of a class or other struct if using the USTRUCT() macro. Regular structs can still be utilized inside your classes and other structs; however these cannot be replicated natively and will not be available for UE4 reflective debugging or other engine systems such as Blueprints.")]),t._v(" "),r("h2",{attrs:{id:"examples"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),r("h3",{attrs:{id:"example-1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#example-1"}},[t._v("#")]),t._v(" Example 1")]),t._v(" "),r("p",[t._v("You want to relate a float brightness value with a world space location FVector, both of which are interpolated using an Alpha value.")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("And you want to do this for 100 different game locations simultaneously.")])]),t._v(" "),r("li",[r("p",[t._v("And you want to do this process repeatedly over time!")])]),t._v(" "),r("li",[r("p",[t._v("You need to store the incremental interpolation values between game events.")])]),t._v(" "),r("li",[r("p",[t._v("AActors/UObjects are not involved (You could just subclass AActor/UObject and store the data per instance)")])])]),t._v(" "),r("p",[t._v("USTRUCT()\nstruct FMyInterpStruct\n{\nGENERATED_BODY()\n \nUPROPERTY()\nfloat Brightness;\n \nUPROPERTY()\nfloat BrightnessGoal; //interping to\n \nUPROPERTY()\nFVector Location;\n \nUPROPERTY()\nFVector LocationGoal;\n \nUPROPERTY()\nfloat Alpha;\n \nvoid InterpInternal()\n{\nLocation = FMath::Lerp<FVector>(Location,LocationGoal,Alpha);\nBrightness = FMath::Lerp<float>(Brightness,BrightnessGoal,Alpha);\n}\n \n//Brightness out is returned, FVector is returned by reference\nfloat Interp(const float& NewAlpha, FVector& Out)\n{\n//value received from rest of your game engine\nAlpha = NewAlpha;\n \n//Internal data structure management\nInterpInternal();\n \n//Return Values\nOut = Location;\nreturn Brightness;\n}\nFMyInterpStruct()\n{\nBrightness = 2;\nBrightnessGoal = 100;\n \nAlpha = 0;\n \nLocation = FVector::ZeroVector;\nLocationGoal = FVector(0,0,200000);\n}\n};")]),t._v(" "),r("h3",{attrs:{id:"example-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#example-2"}},[t._v("#")]),t._v(" Example 2")]),t._v(" "),r("p",[t._v("You want to track information about particle system components that you have spawned into the world through")]),t._v(" "),r("p",[t._v("UGameplayStatics::SpawnEmitterAtLocation() // returns a UParticleSystemComponent")]),t._v(" "),r("p",[t._v("and you want to track the lifetime of the particle and apply parameter changes from C++. You could write your own class, but if your needs are simple or you do not have project-permissions to make a subclass of UParticleSystemComponent, you can just make a USTRUCT to relate the various data types!")]),t._v(" "),r("p",[t._v("USTRUCT()\nstruct FParticleStruct\n{\nGENERATED_BODY()\n \nUPROPERTY()\nUParticleSystemComponent* PSCPtr;\n \nUPROPERTY()\nfloat LifeTime;\n \nvoid SetColor()\n{\n//\n}\nFLinearColor GetCurrentColor() const\n{\n//\n}\n \n//For GC\nvoid Destroy()\n{\nPSCPtr = nullptr;\n}\n \n//Constructor\nFParticleStruct()\n{\nPSCPtr = NULL;\nLifeTime = -1;\n}\n};")]),t._v(" "),r("h4",{attrs:{id:"particle-data-tracker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#particle-data-tracker"}},[t._v("#")]),t._v(" Particle Data Tracker")]),t._v(" "),r("p",[t._v("Now you can have an array of these USTRUCTS for each particle that you spawn!")]),t._v(" "),r("p",[t._v("//Particle Data Tracking Array\nUPROPERTY()\nTArray<FParticleStruct> PSCArray;")]),t._v(" "),r("h4",{attrs:{id:"garbage-collection"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#garbage-collection"}},[t._v("#")]),t._v(" Garbage Collection")]),t._v(" "),r("p",[t._v("By marking a USTRUCT or USTRUCT array as UPROPERTY() and marking any UObject / AActor members as UPROPERTY(), you are protected from dangling pointer crashes")]),t._v(" "),r("p",[r("a",{attrs:{href:"/How_To_Prevent_Crashes_Due_To_Dangling_Actor_Pointers",title:"How To Prevent Crashes Due To Dangling Actor Pointers"}},[t._v("How_To_Prevent_Crashes_Due_To_Dangling_Actor_Pointers")])]),t._v(" "),r("p",[t._v("However you must also clear ustructs you no longer need if they have pointers to UObjects if you ever want GC to be able garbage collect those UObjects.")]),t._v(" "),r("h2",{attrs:{id:"structs-with-struct-member-variables"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#structs-with-struct-member-variables"}},[t._v("#")]),t._v(" Structs With Struct Member Variables")]),t._v(" "),r("p",[t._v("The struct that wants to use another struct must be defined below the struct it wants to include.")]),t._v(" "),r("p",[t._v("USTRUCT()\nstruct FFlowerStruct\n{\nGENERATED_BODY()\n \nUPROPERTY()\nint32 NumPetals;\n \nUPROPERTY()\nFLinearColor Color;\n \nUPROPERTY()\nFVector Scale3D;\n \nvoid SetFlowerColor(const FLinearColor& NewColor)\n{\nColor = NewColor;\n}\n \nFFlowerStruct()\n{\nNumPetals \t= 5;\nScale3D \t\t= FVector(1,1,1);\nColor \t\t\t= FLinearColor(1,0,0,1);\n}\n};\n \nUSTRUCT()\nstruct FIslandStruct\n{\nGENERATED_BODY()\n \nUPROPERTY()\nint32 Type;\n \nUPROPERTY()\nTArray<FVector> StarLocations;\n \nUPROPERTY()\nfloat RainAlpha;\n \n//Dynamic Array of Flower Custom USTRUCT()\nUPROPERTY()\nTArray<FFlowerStruct> FlowersOnThisIsland;\n \nvoid SetRainAlpha(const float& NewAlpha)\n{\nRainAlpha = NewAlpha;\n}\n \nint32 GetStarCount() const\n{\nreturn StarLocations.Num();\n}\nFIslandStruct()\n{\nType = 0;\nPercent = 1;\n}\n};")]),t._v(" "),r("h2",{attrs:{id:"struct-assignment"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#struct-assignment"}},[t._v("#")]),t._v(" Struct Assignment")]),t._v(" "),r("p",[t._v("My personal favorite thing about structs is that unlike UObject or AActor classes, which must be utilized via pointers (AActor*) you can directly copy the entire contents of a USTRUCT to another USTRUCT of the same type with a single line of assignment!")]),t._v(" "),r("p",[t._v("FFlowerStruct ExistingFlower;\n \n// ... create ExistingFlower here\n \nFFlowerStruct NewFlower;\nNewFlower = ExistingFlower;")]),t._v(" "),r("h3",{attrs:{id:"deep-copy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deep-copy"}},[t._v("#")]),t._v(" Deep Copy")]),t._v(" "),r("p",[t._v("If you have struct members pointing to UObjects or array pointers, you must be careful to copy these members yourself!")]),t._v(" "),r("p",[t._v('USTRUCT()\nstruct FMyStruct {\nint32* MyIntArray;\n};\n \nFMyStruct MyFirstStruct, MySecondStruct;\n \n// Create the integer array on the first struct\nMyFirstStruct.MyIntArray = new int32[10];\nfor( int i = 0; i < 10; ++i ) {\nMyFirstStruct.MyIntArray[i] = i;\n}\n \nGEngine->AddOnScreenMessage(-1, 10.f, FColor::Blue, FString::FromInt(MyFirstStruct.MyIntArray[4]));\n \n// Assign the first struct to the second struct, i.e. create a shallow copy\nMySecondStruct.MyIntArray[4] = 6;\n \nGEngine->AddOnScreenMessage(-1, 10.f, FColor::Blue, FString::Printf(TEXT("%d %d"), MyFirstStruct.MyIntArray[4], MySecondStruct.MyIntArray[4]));')]),t._v(" "),r("p",[t._v("On screen the output will be")]),t._v(" "),r("p",[t._v("4\n6 6")]),t._v(" "),r("p",[t._v("instead of the expected")]),t._v(" "),r("p",[t._v("4\n4 6")]),t._v(" "),r("p",[t._v("This is because the data stored in MyStruct::MyIntArray is not actually stored inside of MyStruct. The "),r("em",[t._v("new")]),t._v(" keyword creates the data somewhere in RAM and we simply store a pointer there. The address the pointer stores is copied over to "),r("em",[t._v("MySecondStruct")]),t._v(", but it still points to the same data. In fact, it would be counterproductive to remove this functionality since there are cases where you want exactly that. Additionally the Unreal Property System does not support non-UObject pointers, which is why "),r("em",[t._v("MyIntArray")]),t._v(" is not marked with UPROPERTY().")]),t._v(" "),r("p",[t._v('However, copying arrays of integers (e.g. int32[10] instead of int32*) means the data is stored directly inside the struct and as such "deep copied". However, if you store a pointer to a UObject, this object is NOT deep copied! Once again only the pointer is copied and the original UObject left unchanged. Which is good because otherwise you might manipulate the wrong instance thinking you only had one to begin with leaving the original UObject unaffected, thus resembling a very nerve-wrecking and very difficult to track down bug!')]),t._v(" "),r("h2",{attrs:{id:"automatic-make-break-in-bp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#automatic-make-break-in-bp"}},[t._v("#")]),t._v(" Automatic Make/Break in BP")]),t._v(" "),r("p",[t._v("Marking the USTRUCT as "),r("em",[t._v("BlueprintType")]),t._v(" and adding "),r("em",[t._v('EditAnywhere, BlueprintReadWrite, Category = "Your Category"')]),t._v(" to USTRUCT properties causes UE4 to automatically create "),r("em",[t._v("Make")]),t._v(" and "),r("em",[t._v("Break")]),t._v(" Blueprint functions, allowing to construct or extract data from the custom USTRUCT.")]),t._v(" "),r("p",[t._v("Special thanks to Community member Iniside for pointing this out. 😃")]),t._v(" "),r("p",[t._v('USTRUCT(BlueprintType)\nstruct FFlowerStruct\n{\nGENERATED_BODY()\n \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Flower Struct")\nint32 NumPetals;\n \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Flower Struct")\nFLinearColor Color;\n \nUPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Flower Struct")\nFVector Scale3D;\n};')]),t._v(" "),r("p",[r("a",{attrs:{href:"/File:CustomUStructMakeBreak.jpg"}},[r("img",{attrs:{src:"https://d3ar1piqh1oeli.cloudfront.net/0/0d/CustomUStructMakeBreak.jpg/1000px-CustomUStructMakeBreak.jpg",alt:"CustomUStructMakeBreak.jpg"}})])]),t._v(" "),r("h2",{attrs:{id:"replication"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#replication"}},[t._v("#")]),t._v(" Replication")]),t._v(" "),r("hr"),t._v(" "),r("hr"),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("Remember that only UPROPERTY() variables of USTRUCTS() are considered for replication!")]),t._v(" "),r("hr"),t._v(" "),r("hr"),t._v(" "),r("hr"),t._v(" "),r("p",[t._v("So if your USTRUCT is not replicating properly, the first thing you should check is that every member is at least UPROPERTY()! The struct does not have be a BlueprintType, it just needs UPROPERTY() above all properties that you want replicated.")]),t._v(" "),r("h2",{attrs:{id:"related-links"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#related-links"}},[t._v("#")]),t._v(" Related Links")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://forums.unrealengine.com/showthread.php?103241-UE_Log-crashing-engine-when-trying-to-print-a-FString&p=488561&viewfull=1#post488561",target:"_blank",rel:"noopener noreferrer"}},[t._v("UStruct data member memory management"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"thank-you-epic-for-ustructs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#thank-you-epic-for-ustructs"}},[t._v("#")]),t._v(" Thank You Epic for USTRUCTS()")]),t._v(" "),r("p",[t._v("I love USTRUCTS(), thank you Epic!")]),t._v(" "),r("p",[r("a",{attrs:{href:"/User:Rama",title:"User:Rama"}},[t._v("Rama")]),t._v(" ("),r("a",{attrs:{href:"/User_talk:Rama",title:"User talk:Rama"}},[t._v("talk")]),t._v(")")]),t._v(" "),r("p",[t._v('Retrieved from "'),r("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Structs,_USTRUCTS(),_They%27re_Awesome&oldid=23795",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://wiki.unrealengine.com/index.php?title=Structs,_USTRUCTS(),_They%27re_Awesome&oldid=23795"),r("OutboundLink")],1),t._v('"')]),t._v(" "),r("p",[r("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[t._v("Category")]),t._v(":")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[t._v("Code")])])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);e.default=n.exports}}]);