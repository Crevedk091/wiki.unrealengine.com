(window.webpackJsonp=window.webpackJsonp||[]).push([[396],{436:function(e,n,t){"use strict";t.r(n);var i=t(28),s=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Creating Input Devices - Epic Wiki")]),e._v(" "),t("h1",{attrs:{id:"creating-input-devices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#creating-input-devices"}},[e._v("#")]),e._v(" Creating Input Devices")]),e._v(" "),t("p",[e._v("From Epic Wiki")]),e._v(" "),t("p",[e._v("Jump to: "),t("a",{attrs:{href:"#mw-navigation"}},[e._v("navigation")]),e._v(", "),t("a",{attrs:{href:"#p-search"}},[e._v("search")])]),e._v(" "),t("h2",{attrs:{id:"contents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Example_Code"}},[e._v("2 Example Code")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#Plugin_Code"}},[e._v("2.1 Plugin Code")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#uPlugin_Ddefinition"}},[e._v("2.2 uPlugin Ddefinition")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Module_Build_File"}},[e._v("2.3 Module Build File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#IPlugin_Header_File"}},[e._v("2.4 IPlugin Header File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#PCH_File"}},[e._v("2.5 PCH File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Plugin_Header_File"}},[e._v("2.6 Plugin Header File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Plugin_Cpp_File"}},[e._v("2.7 Plugin Cpp File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Input_Device_Header_File"}},[e._v("2.8 Input Device Header File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Input_Device_Cpp_File"}},[e._v("2.9 Input Device Cpp File")])])])])]),e._v(" "),t("h2",{attrs:{id:"overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),t("p",[e._v("This page will detail how to create custom Input Device plugins in order to add support for additional controller/input types. It will also show example code for adding additional Key/Gamepad Input Names. The code will show how to fire events from the existing Input Names via a MessageHandler and how to fire events from any Key/Gamepad Input directly.")]),e._v(" "),t("p",[e._v("WARNING: The code is currently unstable! There is a bug with ForceFeedback that is preventing a build. I will have this fixed by 25th July unless someone fixes it before then.")]),e._v(" "),t("p",[e._v("(Warning: firing direct messages bypasses 'controller#, and therefore does not support local multilayer)")]),e._v(" "),t("h2",{attrs:{id:"example-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#example-code"}},[e._v("#")]),e._v(" Example Code")]),e._v(" "),t("p",[e._v('The code will show how to create a plugin for a psudo Input Device which will simulate controller#1 pressing the bottom face button every .1 seconds. It will also create a new custom Gamepad Input called "Psudo Player Weight" and fire events for this input with a value of 75.0 (kg).')]),e._v(" "),t("p",[e._v("In your own code you will most likely link your plugin with a static/dynamic library which communicates with you Input Device. When the engine calls FPsudoInputsInputDevice::SendControllerEvents() you can then pass on any events/polled controller states using the MessageHandler in a generic way.")]),e._v(" "),t("h3",{attrs:{id:"plugin-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin-code"}},[e._v("#")]),e._v(" Plugin Code")]),e._v(" "),t("h3",{attrs:{id:"uplugin-ddefinition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uplugin-ddefinition"}},[e._v("#")]),e._v(" uPlugin Ddefinition")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/PsudoInputs.uplugin")])]),e._v(" "),t("p",[e._v('{\n"FileVersion" : 0,\nÂ \n"FriendlyName" : "Psudo Inputs Plugin"\n"Version" : 0,\n"VersionName" : "0.2",\n"CreatedBy" : "mspe044@gmail.com",\n"EngineVersion" : 1579795,\n"Description" : "I wish I was a real input!Â ðŸ˜¢",\n"Category" : "MyInputs",\nÂ \n"Modules" :\n[\n{\n"Name" : "PsudoInputs",\n"Type" : "Runtime",\n"LoadingPhase" : "PreDefault"\n}\n]\n}')]),e._v(" "),t("h3",{attrs:{id:"module-build-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#module-build-file"}},[e._v("#")]),e._v(" Module Build File")]),e._v(" "),t("p",[e._v("This is where you link to any library supporting your Input Device. There is a sample method 'LoadYourThirdPartyLibraries()' to help you do this however the call to it is currently commented out.")]),e._v(" "),t("p",[e._v("This method will will link to a static library in "),t("strong",[e._v(".../Plugins/PsudoInputs/Source/PsudoInputs/ThirdParty/LibraryDirName/...")]),e._v(" with include files in the sub directory "),t("strong",[e._v(".../include/")]),e._v(" and library code in subdirectoires seprated by compile arcitecture I.E. "),t("strong",[e._v(".../Win64/VS2013/MyLibrary.lib")])]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/PsudoInputs.Build.cs")])]),e._v(" "),t("p",[e._v('namespace UnrealBuildTool.Rules\n{\nusing System.IO;\nÂ \npublic class PsudoInputs : ModuleRules\n{\npublic PsudoInputs(TargetInfo Target)\n{\n// I chose not to use PCH, this is proberbly slower and worse\nPCHUsage = PCHUsageMode.NoSharedPCHs;\nÂ \n// ... add public include paths required here ...\nPublicIncludePaths.AddRange( new string[] {\n"PsudoInputs/Public",\n});\nÂ \n// ... add other private include paths required here ...\nPrivateIncludePaths.AddRange( new string[] {\n"PsudoInputs/Private",\n});\nÂ \n// ... add other public dependencies that you statically link with here ...\nPublicDependencyModuleNames.AddRange( new string[] {\n"Core",\n"CoreUObject",      // Provides Actors and Structs\n"Engine",           // Used by Actor\n"Slate",            // Used by InputDevice to fire bespoke FKey events\n"InputCore",        // Provides LOCTEXT and other Input features\n"InputDevice",      // Provides IInputInterface\n});\nÂ \n// ... add private dependencies that you statically link with here ...\nPrivateDependencyModuleNames.AddRange( new string[] {\n});\nÂ \n// ... add any modules that your module loads dynamically here ...\nDynamicallyLoadedModuleNames.AddRange( new string[] {\n});\nÂ \n//Â !!!!!!!!!! UNCOMMENT THIS IF YOU WANT TO CALL A LIBRARYÂ !!!!!!!!!!\n//LoadYourThirdPartyLibraries(Target);\n}\nÂ \npublic bool LoadYourThirdPartyLibraries(TargetInfo Target)\n{\nbool isLibrarySupported = false;\nÂ \n// This will give oyu a relitive path to the module ../PsudoInputs/\nstring ModulePath = Path.GetDirectoryName(RulesCompiler.GetModuleFilename(this.GetType().Name));\n// This will give you a relative path to ../PsudoInputs/ThirdParty/"LibraryDirName"/\nstring MyLibraryPath = Path.Combine(ModulePath, "ThirdParty", "LibraryDirName");\nÂ \n// Use this to keep Win32/Win64/e.t.c. library files in seprate subdirectories\nstring ArchitecturePath = "";\nÂ \n// When you are building for Win64\nif (Target.Platform == UnrealTargetPlatform.Win64 &&\nWindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)\n{\n// We will look for the library in ../PsudoInputs/ThirdParty/MyLibrary/Win64/VS20##/\nArchitecturePath = Path.Combine("Win64", "VS" + WindowsPlatform.GetVisualStudioCompilerVersionName());\nÂ \nisLibrarySupported = true;\n}\n// When you are building for Win32\nelse if (Target.Platform == UnrealTargetPlatform.Win32 &&\nWindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)\n{\n// We will look for the library in ../PsudoInputs/ThirdParty/MyLibrary/Win32/VS20##/\nArchitecturePath = Path.Combine("Win32", "VS" + WindowsPlatform.GetVisualStudioCompilerVersionName());\nÂ \nisLibrarySupported = true;\n}\n// Add mac/linux/mobile support in much the same way\nÂ \n// If the current build architecture was supported by the above if statements\nif (isLibrarySupported)\n{\n// Add the architecture spacific path to the library files\nPublicAdditionalLibraries.Add(Path.Combine(MyLibraryPath, "lib", ArchitecturePath, "MyLibrary.lib"));\n// Add a more generic path to the include header files\nPublicIncludePaths.Add(Path.Combine(MyLibraryPath, "include"));\n}\nÂ \n// Defination lets us know whether we successfully found our library!\nDefinitions.Add(string.Format("WITH_MY_LIBRARY_PATH_USE={0}", isLibrarySupported ? 1 : 0));\nÂ \nreturn isLibrarySupported;\n}\n}\n}')]),e._v(" "),t("h3",{attrs:{id:"iplugin-header-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iplugin-header-file"}},[e._v("#")]),e._v(" IPlugin Header File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/Public/PsudoInputsPlugin.h")])]),e._v(" "),t("p",[e._v('#pragma once\nÂ \n#include "ModuleManager.h"\n#include "IInputDeviceModule.h"\nÂ \n#include "InputCoreTypes.h"\nÂ \n/**\n* The public interface to this module.  In most cases, this interface is only public to sibling modules\n* within this plugin.\n*/\nclass IPsudoInputsPlugin : public IInputDeviceModule\n{\npublic:\n/**\n* Singleton-like access to this module\'s interface.  This is just for convenience!\n* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n*\n* @return Returns singleton instance, loading the module on demand if needed\n*/\nstatic inline IPsudoInputsPlugin& Get()\n{\nreturn FModuleManager::LoadModuleChecked< IPsudoInputsPlugin >("PsudoInputs");\n}\nÂ \n/**\n* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n*\n* @return True if the module is loaded and ready to use\n*/\nstatic inline bool IsAvailable()\n{\nreturn FModuleManager::Get().IsModuleLoaded( "PsudoInputs" );\n}\nÂ \n// This is where I declare my fancy new output type\n//  - It\'s pretending to be a set of scales like a poor mans Wii Balance Board)\nstatic const FKey Psudo_WeighingScales;\n};')]),e._v(" "),t("h3",{attrs:{id:"pch-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pch-file"}},[e._v("#")]),e._v(" PCH File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/Private/PsudoInputsPrivatePCH")])]),e._v(" "),t("p",[e._v('// You should place include statements to your module\'s private header files here.  You only need to\n// add includes for headers that are used in most of your module\'s source files though.\nÂ \n#include "Core.h"\n#include "CoreUObject.h"\nÂ \n#include "IPsudoInputsPlugin.h"')]),e._v(" "),t("h3",{attrs:{id:"plugin-header-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin-header-file"}},[e._v("#")]),e._v(" Plugin Header File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/Private/PsudoInputsPlugin.h")])]),e._v(" "),t("p",[e._v('#pragma once\n#include "PsudoInputsPrivatePCH.h"\nÂ \nclass FPsudoInputsPlugin : public IPsudoInputsPlugin\n{\npublic:\n/** IPsudoInputsInterface implementation */\nvirtual TSharedPtr< class IInputDevice > CreateInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler);\nÂ \n// This is not required as IInputDeviceModule handels startup!\n//virtual void StartupModule() OVERRIDE;\nvirtual void ShutdownModule() OVERRIDE;\nÂ \nTSharedPtr< class FPsudoInputsInputDevice > PsudoInputDevice;\n};')]),e._v(" "),t("h3",{attrs:{id:"plugin-cpp-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin-cpp-file"}},[e._v("#")]),e._v(" Plugin Cpp File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/Private/PsudoInputsPlugin.c")])]),e._v(" "),t("p",[e._v('#include "PsudoInputsPrivatePCH.h"\nÂ \n#include "Internationalization.h" // LOCTEXT\n#include "InputCoreTypes.h"\nÂ \n#include "PsudoInputsPlugin.h"\nÂ \n#include "Engine.h" // Are these both necessary?\n#include "EngineUserInterfaceClasses.h" // Are these both necessary?\nÂ \n#include "IPsudoInputsPlugin.h"\nÂ \n#include "PsudoInputs.generated.inl"\nÂ \nIMPLEMENT_MODULE(FPsudoInputsPlugin, PsudoInputs)\nDEFINE_LOG_CATEGORY_STATIC(PsudoInputsPlugin, Log, All);\nÂ \n#define LOCTEXT_NAMESPACE "InputKeys"\nÂ \nconst FKey IPsudoInputsPlugin::Psudo_WeighingScales("Psudo_WeighingScales");\nÂ \n// This function is called by *Application.cpp after startup to instantiate the modules InputDevice\nTSharedPtr< class IInputDevice > FPsudoInputsPlugin::CreateInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler)\n{\nUE_LOG(PsudoInputsPlugin, Log, TEXT("Create Input Device"));\nÂ \n// EKey: use these sparingly... only when you need a button/axis/motion that doesn\'t fit any of the input names that already exist\n//  - I\'m defineing my poor mans Wii Balance Board, it will be called "Psudo Player Weight" in the editor\nEKeys::AddKey(FKeyDetails(IPsudoInputsPlugin::Psudo_WeighingScales, LOCTEXT("Psudo_WeighingScales", "Psudo Player Weight"), FKeyDetails::Axis));\nconst_cast<UInputSettings*>(GetDefault<UInputSettings>())->AddAxisMapping(FInputAxisKeyMapping("PsudoWeighingScales", IPsudoInputsPlugin::Psudo_WeighingScales, 1.0F));\nÂ \nFPsudoInputsPlugin::PsudoInputDevice = MakeShareable(new FPsudoInputsInputDevice(InMessageHandler));\nÂ \n// We return the IInputDevice so that the Application has a handel on it.\n//  - The application will ask for controller updates via \'SendControllerEvents()\'\n//  - The application will update the MessageHandler if it changes via \'SetMessageHandler(...)\'\nreturn FPsudoInputsPlugin::PsudoInputDevice;\n}\nÂ \n#undef LOCTEXT_NAMESPACE\nÂ \n// This function may be called during shutdown to clean up the module.\nvoid FPsudoInputsPlugin::ShutdownModule()\n{\nFPsudoInputsPlugin::PsudoInputDevice->~FPsudoInputsInputDevice();\nÂ \nUE_LOG(PsudoInputsPlugin, Log, TEXT("Shutdown Module"));\n}')]),e._v(" "),t("h3",{attrs:{id:"input-device-header-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-device-header-file"}},[e._v("#")]),e._v(" Input Device Header File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/Private/PsudoInputsInputDevice.h")])]),e._v(" "),t("p",[e._v('#pragma once\n//#include "PsudoInputsPluginPrivatePCH.h"\nÂ \n#include "IInputDevice.h"\nÂ \n#define MAX_NUM_PSUDO_INPUT_CONTROLLERS\t4 // We dont realy have any input controllers, this is a sham!Â ðŸ˜›\n#define NUM_PSUDO_INPUT_BUTTONS\t\t\t4 // I\'ve only used the one button but w/evs\nÂ \n/**\n* Type definition for shared pointers to instances of FMessageEndpoint.\n*/\n// ToDo: Is this necessary?\ntypedef TSharedPtr<class FPsudoInputsInputDevice> FPsudoInputsInputDevicePtr;\nÂ \n/**\n* Type definition for shared references to instances of FMessageEndpoint.\n*/\n// ToDo: Is this necessary?\ntypedef TSharedRef<class FPsudoInputsInputDevice> FPsudoInputsInputDeviceRef;\nÂ \n/**\n* Interface class for my psudo device\n*/\nclass FPsudoInputsInputDevice : public IInputDevice\n{\npublic:\nFPsudoInputsInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& MessageHandler);\nÂ \n// Tick the interface (e.g. check for new controllers)\nvirtual void Tick(float DeltaTime) OVERRIDE;\nÂ \n// Poll for controller state and send events if needed\nvirtual void SendControllerEvents() OVERRIDE;\nÂ \n// Set which MessageHandler will get the events from SendControllerEvents.\nvirtual void SetMessageHandler(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler) OVERRIDE;\nÂ \n// Exec handler to allow console commands to be passed through for debugging\nvirtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) OVERRIDE;\nÂ \n// IForceFeedbackSystem pass through functions\nvirtual void SetChannelValue(int32 ControllerId, FForceFeedbackChannelType ChannelType, float Value) OVERRIDE;\nvirtual void SetChannelValues(int32 ControllerId, const FForceFeedbackValues &values) OVERRIDE;\nÂ \nvirtual ~FPsudoInputsInputDevice();\nprivate:\n// ToDo: Is this necessary?\nbool Active;\nÂ \n/** Delay before sending a repeat message after a button was first pressed */\nfloat InitialButtonRepeatDelay; // How long a button is held for before you send a 2nd event\nÂ \n/** Delay before sending a repeat message after a button has been pressed for a while */\nfloat ButtonRepeatDelay; // How long a button is held for before you send a 3rd/4th/e.t.c event\nÂ \nEControllerButtons::Type PsudoInputButtonMapping[NUM_PSUDO_INPUT_BUTTONS];\ndouble NextRepeatTime[NUM_PSUDO_INPUT_BUTTONS];\nÂ \nTSharedRef< FGenericApplicationMessageHandler > MessageHandler;\n};')]),e._v(" "),t("h3",{attrs:{id:"input-device-cpp-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-device-cpp-file"}},[e._v("#")]),e._v(" Input Device Cpp File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoInputs/Source/PsudoInputs/Private/PsudoInputsInputDevice.cpp")])]),e._v(" "),t("p",[e._v('#include "PsudoInputsPrivatePCH.h"\nÂ \n#include "GenericPlatformMath.h"\nÂ \n#include "PsudoInputsInputDevice.h"\nÂ \n#include "Slate.h"\nÂ \n#include "WindowsApplication.h"\n#include "WindowsWindow.h"\n#include "WindowsCursor.h"\n#include "GenericApplicationMessageHandler.h"\n#include "IInputDeviceModule.h"\n#include "IInputDevice.h"\nÂ \nDEFINE_LOG_CATEGORY_STATIC(LogPsudoInputDevice, Log, All);\nÂ \nbyte pollState[MAX_NUM_PSUDO_INPUT_CONTROLLERS];\nÂ \nFPsudoInputsInputDevice::FPsudoInputsInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler) : Active(true), MessageHandler(InMessageHandler)\n{\nUE_LOG(LogPsudoInputDevice, Log, TEXT("Starting PsudoInputsInputDevice"));\nÂ \nInitialButtonRepeatDelay = 0.2f;\nButtonRepeatDelay = 0.1f;\nÂ \nPsudoInputButtonMapping[0] = EControllerButtons::FaceButtonTop;\t\t\t// PSUDO_BUTTON_ONE\nNextRepeatTime[0] = -1.0;\t\t\t\t\t\t\t\t\t\t\t\t// Set toÂ !pressed\nPsudoInputButtonMapping[1] = EControllerButtons::FaceButtonBottom;\t\t// PSUDO_BUTTON_TWO\nNextRepeatTime[1] = -1.0;\t\t\t\t\t\t\t\t\t\t\t\t// Set toÂ !pressed\nPsudoInputButtonMapping[2] = EControllerButtons::FaceButtonLeft;\t\t// PSUDO_BUTTON_THREE\nNextRepeatTime[2] = -1.0;\t\t\t\t\t\t\t\t\t\t\t\t// Set toÂ !pressed\nPsudoInputButtonMapping[3] = EControllerButtons::FaceButtonRight;\t\t// PSUDO_BUTTON_FOUR\nNextRepeatTime[3] = -1.0;\t\t\t\t\t\t\t\t\t\t\t\t// Set toÂ !pressed\n}\nÂ \n// This method runs once every game tick, use it if you need a regular polling event\nvoid FPsudoInputsInputDevice::Tick(float DeltaTime){\n}\nÂ \n// This method runs every time the game wants to check for controller updates!\nvoid FPsudoInputsInputDevice::SendControllerEvents()\n{\n// Commented this out as it will spam the log!\n//UE_LOG(LogPsudoInputDevice, Log, TEXT("Sending Controller Events"));\nÂ \n// Here is where we check the state of our input device proberbly by calling a method in your third party library...\n//  - I dont have a real device (xbox controller, wiimote, e.t.c.) in this tutorialÂ ðŸ˜¢ so im gona fake it!!!\nconst double CurrentTime = FPlatformTime::Seconds();\nÂ \n// I could make library to read from a fancy set of matrix serebellum jacks and iterate over each of those \'controllers\'.. but ill save that for the next tutorial\nint controllerIndex = 0; // Apparantly I was lazy so there is only one controller!\nÂ \n// This is how you fire regular boring controller events... the ones like the green xbox \'A\' key (EControllerButtons::FaceButtonBottom)\nÂ \nint jumpButtonIndex = 0;\nÂ \n// This will make the third person tutorial man jump for player one!\nÂ \n// IF BUTTON IS CURRENTLY PRESSED DOWN BY USER\n//  - If button pressed has not fired since the user pressed the button\nif (NextRepeatTime[jumpButtonIndex] == -1.0) {\nMessageHandler->OnControllerButtonPressed(PsudoInputButtonMapping[jumpButtonIndex], controllerIndex, false);\nÂ \nNextRepeatTime[jumpButtonIndex] = CurrentTime + InitialButtonRepeatDelay;\n}\n//  - Else If (button pressed has fired > 0 times) && (time since last event > repeat event time)\nelse if (NextRepeatTime[jumpButtonIndex] <= CurrentTime) {\nMessageHandler->OnControllerButtonPressed(PsudoInputButtonMapping[jumpButtonIndex], controllerIndex, true);\nÂ \nNextRepeatTime[jumpButtonIndex] = CurrentTime + ButtonRepeatDelay;\n}\n// ELSE (BUTTON IS CURRENTLY NOT PRESSED BY USER)\nif (NextRepeatTime[jumpButtonIndex] != -1.0) {\n// You would normally test whether the controll is pressed or released, on release you call: (see XInputInterface.cpp for a nice example)\n//MessageHandler->OnControllerButtonReleased(PsudoInputButtonMapping[jumpButtonIndex], controllerIndex, false);\n//NextRepeatTime[jumpButtonIndex] = -1.0;\n}\nÂ \nÂ \nInitialButtonRepeatDelay = 0.2f;\nButtonRepeatDelay = 0.1f;\nÂ \n// This is how you fire your fancypantz new controller events... the ones you added because you couldn\'t find an existing EControllerButton that matched your needs!\nFSlateApplication::Get().OnControllerAnalog(IPsudoInputsPlugin::Psudo_WeighingScales, controllerIndex, 75); // This will spam 75(kg) to my fancy new output type!\nÂ \n}\nÂ \n// This method is called every time someone changes the message handler (other hacky plugins might change it to customise it.. we haven\'t cos we\'re cool like that)\nvoid FPsudoInputsInputDevice::SetMessageHandler(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler)\n{\nUE_LOG(LogPsudoInputDevice, Log, TEXT("Setting Message Handler"));\nMessageHandler = InMessageHandler;\n}\nÂ \n// Exec handler to allow console commands to be passed through for debugging\nbool FPsudoInputsInputDevice::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar){\nUE_LOG(LogPsudoInputDevice, Log, TEXT("Execute Console Command:Â %s"), Cmd);\nÂ \n// Put your fancy custom console command code here... I could have used this to let you fire psudo controller events but im lazy..\nÂ \nreturn true;\n}\nÂ \n// IForceFeedbackSystem pass through functions\n//  - I *believe* this is a handel for the game to communicate back to your third party library (i.e. game tells joystick to increase force feedback/vibrate/turn on/off a light)\nvoid FPsudoInputsInputDevice::SetChannelValue(int32 ControllerId, FForceFeedbackChannelType ChannelType, float Value){\nUE_LOG(LogPsudoInputDevice, Log, TEXT("Set Force FeedbackÂ %f"), Value);\n}\nvoid FPsudoInputsInputDevice::SetChannelValues(int32 ControllerId, const FForceFeedbackValues &values){\nUE_LOG(LogPsudoInputDevice, Log, TEXT("Set Force Feedback Values"));\n}\nÂ \n// This is where you nicely clean up your plugin when its told to shut down!\n//  - USE THIS PLEASE!!! no one likes a memory leak >_<\nFPsudoInputsInputDevice::~FPsudoInputsInputDevice() {\nUE_LOG(LogPsudoInputDevice, Log, TEXT("Shutdown Complete"));\n}')]),e._v(" "),t("p",[e._v('Retrieved from "'),t("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Creating_Input_Devices&oldid=6624",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Creating_Input_Devices&oldid=6624"),t("OutboundLink")],1),e._v('"')])])}),[],!1,null,null,null);n.default=s.exports}}]);