(window.webpackJsonp=window.webpackJsonp||[]).push([[291],{277:function(e,t,r){"use strict";r.r(t);var a=r(28),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("C++ Camera Controlled Turrets - Epic Wiki")]),e._v(" "),r("h1",{attrs:{id:"c-camera-controlled-turrets"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-camera-controlled-turrets"}},[e._v("#")]),e._v(" C++ Camera Controlled Turrets")]),e._v(" "),r("p",[r("strong",[e._v("Rate this Tutorial:")])]),e._v(" "),r("p",[e._v("0.00")]),e._v(" "),r("p",[r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}}),r("img",{attrs:{src:"/extensions/VoteNY/images/star_off.gif",alt:""}})]),e._v(" "),r("p",[e._v("Approved for Versions:4.12")]),e._v(" "),r("h2",{attrs:{id:"contents"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Requirements"}},[e._v("2 Requirements")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Our_Goals"}},[e._v("3 Our Goals")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Getting_Started"}},[e._v("4 Getting Started")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Set_up_the_Ship_Mesh"}},[e._v("4.1 Set up the Ship Mesh")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Set_up_the_Turret_Barrel_Mesh"}},[e._v("4.2 Set up the Turret Barrel Mesh")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Creating_The_Base_Classes"}},[e._v("4.3 Creating The Base Classes")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Initializing_the_Ship_and_Turret_Classes"}},[e._v("5 Initializing the Ship and Turret Classes")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#ShipBase_Class"}},[e._v("5.1 ShipBase Class")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#TurretBase_Class"}},[e._v("5.2 TurretBase Class")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Extending_The_Base_Classes"}},[e._v("6 Extending The Base Classes")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Adding_Turret_Functionality"}},[e._v("7 Adding Turret Functionality")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#Turret_Spawn_Logic"}},[e._v("7.1 Turret Spawn Logic")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Turret_Control"}},[e._v("7.2 Turret Control")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Turret_Firing"}},[e._v("7.3 Turret Firing")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#Conclusion"}},[e._v("8 Conclusion")])])]),e._v(" "),r("h2",{attrs:{id:"overview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),r("p",[e._v("This tutorial is aimed at people who want to do a little more C++ programming. Having some prior knowledge of C++ is not needed to follow this tutorial. It will take you from the beginning to end. The end result is having a player controlled ship which it's turrets will follow the direction of the camera.")]),e._v(" "),r("p",[e._v("So I've decided that since I've finally figured out how to make turrets work on battleships/spaceships that I should share my discovery and help anyone else who is having difficulties figuring it out with C++! I'm going to take you through the entire process from start to finish, including the set up needed to get everything working just right. So this tutorial may be a little bit long, but I promise you it's worth it!")]),e._v(" "),r("h2",{attrs:{id:"requirements"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#requirements"}},[e._v("#")]),e._v(" Requirements")]),e._v(" "),r("p",[e._v("Before you start this tutorial, you should have a few things prepared and ready.")]),e._v(" "),r("ol",[r("li",[e._v("C++ empty project.")]),e._v(" "),r("li",[e._v("Ship mesh")]),e._v(" "),r("li",[e._v("Turret Chassis mesh")]),e._v(" "),r("li",[e._v("Turret Barrel mesh")])]),e._v(" "),r("p",[e._v("For a little clarification on the Turret meshes, you want two separate meshes to bring into the engine, the body of the turret (which we will refer to as the Chassis) and the barrels of the turret (which we will refer to as the Barrels).")]),e._v(" "),r("p",[e._v("Go on ahead and get all those three meshes imported into the project!")]),e._v(" "),r("h2",{attrs:{id:"our-goals"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#our-goals"}},[e._v("#")]),e._v(" Our Goals")]),e._v(" "),r("p",[e._v("So we are setting out with a few goals to accomplish in this tutorial.")]),e._v(" "),r("ol",[r("li",[e._v("We want to set up the Ship and Turret base classes")]),e._v(" "),r("li",[e._v("Extend the Ship and Turret base classes into blueprints")]),e._v(" "),r("li",[e._v("Get the turrets to spawn on the Ship")]),e._v(" "),r("li",[e._v("Make the turrets rotate and pitch properly")]),e._v(" "),r("li",[e._v("Bonus: Get the turrets to fire!")])]),e._v(" "),r("h2",{attrs:{id:"getting-started"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#getting-started"}},[e._v("#")]),e._v(" Getting Started")]),e._v(" "),r("h3",{attrs:{id:"set-up-the-ship-mesh"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#set-up-the-ship-mesh"}},[e._v("#")]),e._v(" Set up the Ship Mesh")]),e._v(" "),r("p",[e._v("Before we go to much further, we want to make sure that your ship mesh is set up correctly! What we want to do is add some sockets to the ship so our code can spawn the turrets in correctly and at the right locations. So go to where your ship mesh is and double click it. This should bring up the mesh editor in the engine.")]),e._v(" "),r("p",[e._v("Now make sure that the Sockets button is highlighted in the top navbar, and then go to Window -> Socket Manager.")]),e._v(" "),r("p",[e._v("This will make a little window appear off to the right, with a green button named Create Socket.")]),e._v(" "),r("p",[e._v("Go ahead and create some sockets and place them where ever on the mesh you wish! Mine are set up as below.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/a/a5/Icon_template_note1.png",alt:"Note"}}),e._v(" Make sure that you name the sockets consistantly and append a number at the end. This will enable our code to easily find any sockets on the ship and spawn the turrets onto them. I used TurretSkt0, TurretSkt1, etc.")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:ShipSockets.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/9/97/ShipSockets.png",alt:"ShipSockets.png"}})])]),e._v(" "),r("h3",{attrs:{id:"set-up-the-turret-barrel-mesh"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#set-up-the-turret-barrel-mesh"}},[e._v("#")]),e._v(" Set up the Turret Barrel Mesh")]),e._v(" "),r("p",[e._v("Just like the Ship Mesh and placing it's sockets, we want to do the same thing for the barrel mesh, but this time where putting the sockets at the end of the barrels. This is going to be used to help give an origin point of where we are going to spawn our projectiles.")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/a/a5/Icon_template_note1.png",alt:"Note"}}),e._v(" Again, make sure the sockets are named consistently and are appended by a number. For this example I named them Muzzle_1, Muzzle_2, etc.")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:TurretSockets.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/8/8e/TurretSockets.png",alt:"TurretSockets.png"}})])]),e._v(" "),r("h3",{attrs:{id:"creating-the-base-classes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#creating-the-base-classes"}},[e._v("#")]),e._v(" Creating The Base Classes")]),e._v(" "),r("p",[e._v("So let's get those base classes created! We will begin with the Ship Base Class.")]),e._v(" "),r("p",[e._v("So once your project is open in the editor, go to File -> New C++ Class.")]),e._v(" "),r("p",[e._v("You will be prompted with a screen of what to inherit. We want our parent class to be the Pawn.")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:ParentClass.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/d/d5/ParentClass.png",alt:"ParentClass.png"}})])]),e._v(" "),r("p",[e._v("Then we want to give the class a name, ShipBase is what I used. You can name it anything.")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:NameClass.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/d/dc/NameClass.png",alt:"NameClass.png"}})])]),e._v(" "),r("p",[e._v("It will only take a moment for the engine to add the code file and structure to your project, so sit tight!")]),e._v(" "),r("p",[e._v("Once that is done, go ahead and repeat this section for the Turret. I named the class TurretBase.")]),e._v(" "),r("p",[e._v("So now you should have two classes created and the files should be open in your IDE.")]),e._v(" "),r("h2",{attrs:{id:"initializing-the-ship-and-turret-classes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#initializing-the-ship-and-turret-classes"}},[e._v("#")]),e._v(" Initializing the Ship and Turret Classes")]),e._v(" "),r("p",[e._v("Our two classes should look the same and have a few things in the code already like below.")]),e._v(" "),r("p",[e._v("ShipBase.cpp")]),e._v(" "),r("p",[e._v('#include "TurretTutorial.h"\n#include "ShipBase.h"\n \n \n// Sets default values\nAShipBase::AShipBase()\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n}\n \n// Called when the game starts or when spawned\nvoid AShipBase::BeginPlay()\n{\nSuper::BeginPlay();\n \n}\n \n// Called every frame\nvoid AShipBase::Tick( float DeltaTime )\n{\nSuper::Tick( DeltaTime );\n \n}\n \n// Called to bind functionality to input\nvoid AShipBase::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n{\nSuper::SetupPlayerInputComponent(InputComponent);\n \n}')]),e._v(" "),r("p",[e._v("ShipBase.h")]),e._v(" "),r("p",[e._v('// Fill out your copyright notice in the Description page of Project Settings.\n \n#pragma once\n \n#include "GameFramework/Pawn.h"\n#include "ShipBase.generated.h"\n \nUCLASS()\nclass TURRETTUTORIAL_API AShipBase : public APawn\n{\nGENERATED_BODY()\n \npublic:\n// Sets default values for this pawn\'s properties\nAShipBase();\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n// Called to bind functionality to input\nvirtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n \n \n \n};')]),e._v(" "),r("p",[e._v("So the next step is to get our ShipBase and TurretBase classes to actually work so we can extend these base classes out into Blueprints and do some fun stuff with them! The main reason why we are creating a base class for the ship and turret and then extending it out into Blueprints is observing a thing called Object Oriented Programming. I wont go into the semantics of it, but the idea is that we have a common parent class of a Ship and a Turret. We then can create as many variations of these base classes in either Blueprints or Code. This creates flexibility and eliminates having a ton of duplicate code!")]),e._v(" "),r("p",[e._v("In short the ShipBase and TurretBase classes will have all the common properties shared among any ships and any turrets.")]),e._v(" "),r("h3",{attrs:{id:"shipbase-class"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#shipbase-class"}},[e._v("#")]),e._v(" ShipBase Class")]),e._v(" "),r("p",[e._v("So let us get our ShipBase.h filled out! First we want to include our newly created TurretBase class.")]),e._v(" "),r("p",[e._v("ShipBase.h")]),e._v(" "),r("p",[e._v('// TurretBase Include\n#include "../Turrets/TurretBase.h"')]),e._v(" "),r("p",[e._v("Now we want to get everything else set up, including our Mesh of our ship, then build up the camera and get a few more things sorted. Take a look at the rest of the code below.")]),e._v(" "),r("p",[e._v("ShipBase.h")]),e._v(" "),r("p",[e._v('UCLASS()\nclass TURRETTUTORIAL_API AShipBase : public APawn\n{\nGENERATED_BODY()\n \npublic:\n \n/** StaticMesh component that will be the visuals for our flying ship */\nUPROPERTY(Category = Mesh, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))\nclass UStaticMeshComponent* HullMesh;\n \n/** Spring arm that will offset the camera */\nUPROPERTY(Category = Camera, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))\nclass USpringArmComponent* SpringArm;\n \n/** Camera component that will be our viewpoint */\nUPROPERTY(Category = Camera, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))\nclass UCameraComponent* Camera;\n \n// Sets default values for this actor\'s properties\nAShipBase(const FObjectInitializer& ObjectInitializer);\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \n/** Returns PlaneMesh subobject **/\nFORCEINLINE class UStaticMeshComponent* GetPlaneMesh() const { return HullMesh; }\n/** Returns SpringArm subobject **/\nFORCEINLINE class USpringArmComponent* GetSpringArm() const { return SpringArm; }\n/** Returns Camera subobject **/\nFORCEINLINE class UCameraComponent* GetCamera() const { return Camera; }\n \nprotected:\n \n// Camera variables so we can control our camera\nUPROPERTY(Category = Camera, EditDefaultsOnly)\nfloat SpringArmDistance;\nUPROPERTY(Category = Camera, EditDefaultsOnly)\nFVector SpringArmSocketOffset;\nUPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)\nfloat CameraMaxPitch;\nUPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)\nfloat CameraMinPitch;\nUPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)\nfloat CameraZoomAmount;\nUPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)\nfloat CameraZoomSpeed;\nUPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)\nfloat CameraMaxZoom;\nUPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)\nfloat CameraMinZoom;\n \n// Camera CURRENT variables\nfloat CurrentCameraZoomDistance;\n \n// Begin AActor overrides\nvirtual void SetupPlayerInputComponent(class UInputComponent * InputComponent) override;\n// End AActor overrides\n \nvoid CameraYawInput(float Val);\nvoid CameraPitchInput(float Val);\nvoid CameraZoom(float Val);\nvoid CameraZoomIn();\nvoid CameraZoomOut();')]),e._v(" "),r("p",[e._v("Now with the header file completed, we will now add to our ShipBase.cpp file. First were going to modify this original constructor of the class, which should look like this right now...")]),e._v(" "),r("p",[e._v("ShipBase.cpp")]),e._v(" "),r("p",[e._v("// Sets default values\nAShipBase::AShipBase()\n{\n// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\nPrimaryActorTick.bCanEverTick = true;\n \n}")]),e._v(" "),r("p",[e._v("And turn it into this...")]),e._v(" "),r("p",[e._v("ShipBase.cpp")]),e._v(" "),r("p",[e._v('AShipBase::AShipBase(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)\n{\n// Initialize all base values\n \n// Set camera control defaults\nSpringArmDistance = 1250.0f;\nSpringArmSocketOffset = FVector(0.f, 0.f, 380.f);\nCameraMaxPitch = 45.0f;\nCameraMinPitch = -45.0f;\nCameraMaxZoom = SpringArmDistance * 3;\nCameraMinZoom = 500.0f;\nCameraZoomAmount = 250.0f;\nCameraZoomSpeed = CameraZoomAmount / 3;\n \n// Create static mesh component\nHullMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("HullMesh"));\nRootComponent = HullMesh;\nSpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT("SpringArm"));\nSpringArm->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);\n \n// Create the spring arm component\nSpringArmDistance = 700.0f;\t// Sets up default SpringArmDistance\nSpringArmSocketOffset = FVector(0.f, 0.f, 60.f);\t//Sets up default SpringArm Offset\n \n \nSpringArm->TargetArmLength = SpringArmDistance;\nSpringArm->SocketOffset = SpringArmSocketOffset;\nSpringArm->bEnableCameraLag = false;\nSpringArm->CameraLagSpeed = 15.f;\n \n// Create camera component\nCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("Camera"));\nCamera->AttachToComponent(SpringArm, FAttachmentTransformRules::KeepRelativeTransform, USpringArmComponent::SocketName);\nCamera->bUsePawnControlRotation = false; // Don\'t rotate camera with the controller\n \nHullMesh->SetCollisionObjectType(ECC_Pawn);\nHullMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n \n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n}')]),e._v(" "),r("p",[e._v("Whew! That was a big change. But were not done just yet, we now should add in our input controls for our camera! Remember you have to match this code in the input controls of the engine!")]),e._v(" "),r("p",[e._v("ShipBase.cpp")]),e._v(" "),r("p",[e._v('void AShipBase::SetupPlayerInputComponent(class UInputComponent *InputComponent)\n{\ncheck(InputComponent);\nInputComponent->BindAxis("CameraYaw", this, &AShipBase::CameraYawInput);\nInputComponent->BindAxis("CameraPitch", this, &AShipBase::CameraPitchInput);\nInputComponent->BindAction("MouseWheelUp", IE_Pressed, this, &AShipBase::CameraZoomIn);\nInputComponent->BindAction("MouseWheelDown", IE_Pressed, this, &AShipBase::CameraZoomOut);\n}\n \nvoid AShipBase::CameraYawInput(float Val)\n{\nSpringArm->RelativeRotation.Yaw += Val;\n}\n \nvoid AShipBase::CameraPitchInput(float Val)\n{\nfloat NewPitch = (Val * -1.0f) + SpringArm->RelativeRotation.Pitch;\nSpringArm->RelativeRotation.Pitch = FMath::Clamp(NewPitch, CameraMinPitch, CameraMaxPitch);\n}\n \nvoid AShipBase::CameraZoom(float Val)\n{\nCurrentCameraZoomDistance = SpringArm->TargetArmLength;\nSpringArmDistance = CurrentCameraZoomDistance + (CameraZoomAmount * Val);\nfloat TargetArmDistance = FMath::Clamp(SpringArmDistance, CameraMinZoom, CameraMaxZoom);\nSpringArm->TargetArmLength = FMath::FInterpTo(CurrentCameraZoomDistance, TargetArmDistance, GetWorld()->GetDeltaSeconds(), CameraZoomSpeed);\n}\n \nvoid AShipBase::CameraZoomIn()\n{\nCameraZoom(1.0f);\n}\n \nvoid AShipBase::CameraZoomOut()\n{\nCameraZoom(-1.0f);\n}')]),e._v(" "),r("p",[e._v("Now were in business! With the initial set up of our ShipBase class, we now need to go on to getting our TurretBase class set up as well!")]),e._v(" "),r("h3",{attrs:{id:"turretbase-class"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#turretbase-class"}},[e._v("#")]),e._v(" TurretBase Class")]),e._v(" "),r("p",[e._v("So similarly in the ShipBase.h, we want to get out TurretBase.h file up to snuff. So lets get our class filled out properly...")]),e._v(" "),r("p",[e._v("TurretBase.h")]),e._v(" "),r("p",[e._v('UCLASS()\nclass TURRETTUTORIAL_API ATurretBase : public APawn, public ITurretInterface\n{\nGENERATED_BODY()\n \npublic:\t\n// Public Variables\nFRotator TurretLocalRot;\n \n// Sets default values for this actor\'s properties\nATurretBase(const FObjectInitializer& ObjectInitializer);\n \n/** StaticMesh component that will be the visuals for the turret */\nUPROPERTY(Category = Mesh, EditDefaultsOnly, BlueprintReadWrite, meta = (AllowPrivateAccess = "true"))\nclass UStaticMeshComponent* TurretHullMesh;\n \n/** StaticMesh component that will be the visuals for the barrels */\nUPROPERTY(Category = Mesh, EditDefaultsOnly, BlueprintReadWrite, meta = (AllowPrivateAccess = "true"))\nclass UStaticMeshComponent* TurretBarrelMesh;\n \n// Called when the game starts or when spawned\nvirtual void BeginPlay() override;\n \n// Called every frame\nvirtual void Tick( float DeltaSeconds ) override;\n \nvoid TurretLookAt();\n \n// Spawns Munitions\nUPROPERTY(Category = BlueprintSpawn, EditDefaultsOnly, BlueprintReadOnly)\nTSubclassOf<AMunitionsBase> MunitionsBP;\nTArray<FName> MuzzleArray;\nvoid GetMuzzleSockets();\nvoid SpawnMunitions(FName _MuzzleSocketName);\n \n//ITurretInterface\nvirtual void PrimaryFireControl() override;\n \nUPROPERTY(Category = Chasis, BlueprintReadWrite, VisibleAnywhere)\nfloat TurretYawSpeed;\nUPROPERTY(Category = Chasis, BlueprintReadWrite, VisibleAnywhere)\nfloat TurretMaxYaw;\nUPROPERTY(Category = Chasis, BlueprintReadWrite, VisibleAnywhere)\nfloat TurretMinYaw;\n \nUPROPERTY(Category = Barrel, BlueprintReadWrite, VisibleAnywhere)\nfloat TurretPitchSpeed;\nUPROPERTY(Category = Barrel, BlueprintReadWrite, VisibleAnywhere)\nfloat TurretMaxPitch;\nUPROPERTY(Category = Barrel, BlueprintReadWrite, VisibleAnywhere)\nfloat TurretMinPitch;\n \nUPROPERTY(Category = Control, BlueprintReadWrite, EditDefaultsOnly)\nbool IsOccupied;\nUPROPERTY(Category = Control, BlueprintReadOnly, VisibleAnywhere)\nbool IsTargeting;\n \nprivate:\nbool IsFiring;\nfloat CurrentChasisRot;\nfloat CurrentBarrelRot;\nfloat CurrentYawMin;\nfloat CurrentYawMax;\nFRotator CurrentTurretRot;\nFRotator TurretYawRot;\nFRotator TurretPitchRot;\n \n};')]),e._v(" "),r("p",[e._v("So now we want to do the same thing with the base constructor class that was generated for us as we did in the ShipBase.cpp file. We want to turn it into this...")]),e._v(" "),r("p",[e._v("TurretBase.cpp")]),e._v(" "),r("p",[e._v('// Sets default values\nATurretBase::ATurretBase(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)\n{\n \n// Create the static mesh component\nTurretHullMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("TurretHullMesh"));\nTurretBarrelMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("TurretBarrelMesh"));\nRootComponent = TurretHullMesh;\nTurretBarrelMesh->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);\n \n// Set default variables\nIsOccupied = false;\nIsFiring = false;\nTurretYawSpeed = 20.f;\nTurretMaxYaw = 180.f;\nTurretMinYaw = -180.f;\nTurretPitchSpeed = 20.f;\nTurretMaxPitch = 45.f;\nTurretMinPitch = -1.f;\n \nTurretLocalRot = FRotator(0.f, 0.f, 0.f);\nTurretYawRot = FRotator(0.f, 0.f, 0.f);\nTurretPitchRot = FRotator(0.f, 0.f, 0.f);\n \nCurrentYawMax = (TurretHullMesh->GetRelativeTransform().GetRotation().X) + TurretMaxYaw;\nCurrentYawMin = (TurretHullMesh->GetRelativeTransform().GetRotation().X) + TurretMinYaw;\n \nIsTargeting = false;\n \n// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\'t need it.\nPrimaryActorTick.bCanEverTick = true;\n \n}')]),e._v(" "),r("p",[e._v("Next we want to prepare our Tick event. What we are doing here is simply calling a function every frame that will handle the turrets logic to look at our camera's focal point!")]),e._v(" "),r("p",[e._v("TurretBase.cpp")]),e._v(" "),r("p",[e._v("// Called every frame\nvoid ATurretBase::Tick( float DeltaTime )\n{\nTurretLookAt();\nSuper::Tick( DeltaTime );\n}")]),e._v(" "),r("p",[e._v("With that complete lets actually just get in an empty class so we can compile. We will handle the TurretLookAt logic in just a bit. While we do that, lets get a few more skeleton functions out of the way.")]),e._v(" "),r("p",[e._v("TurretBase.cpp")]),e._v(" "),r("p",[e._v("void ATurretBase::TurretLookAt()\n{\n \n}\n \n/* ITurretInterface */\nvoid ATurretBase::PrimaryFireControl()\n{\n \n}\n \nvoid ATurretBase::GetMuzzleSockets()\n{\n \n}\n \nvoid ATurretBase::SpawnMunitions(FName _MuzzleSocketName)\n{\n \n}")]),e._v(" "),r("p",[e._v("With that, compile! We should have the base classes started! The next step is to get them extended into Blueprints to begin getting some results.")]),e._v(" "),r("h2",{attrs:{id:"extending-the-base-classes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#extending-the-base-classes"}},[e._v("#")]),e._v(" Extending The Base Classes")]),e._v(" "),r("p",[e._v("So now that were done getting the basics of the classes in, let's quickly extend those two classes into blueprints so we can set up the turret and the ship!")]),e._v(" "),r("p",[e._v("Let's do the ship first. It should be really straight forward and simple. Right click in the content browser and click Blueprint Class.")]),e._v(" "),r("p",[e._v("Now when it asks to pick a parent class, you want to go to the very bottom of the window, where it says All Classes, click that and then type in ShipBase (Or whatever you named it)")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:ExtendingShip.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/d/df/ExtendingShip.png",alt:"ExtendingShip.png"}})])]),e._v(" "),r("p",[e._v("Click Create, then name the blueprint what ever you want. I named it BP_Ship. Do the same thing for the TurretBase.")]),e._v(" "),r("p",[e._v("Once the blueprints are created, there is not much else to do for the BP_Ship. But there is something you need to take care of in the BP_Turret. Open it up, and go to the Viewport tab on the turret, then adjust the barrel mesh so it sits correctly on your turrets Chasis. In the end you should have something like the following two images.")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:BP_Ship.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/5/56/BP_Ship.png",alt:"BP Ship.png"}})]),e._v(" "),r("a",{attrs:{href:"/File:BP_Turret.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/1/19/BP_Turret.png",alt:"BP Turret.png"}})])]),e._v(" "),r("h2",{attrs:{id:"adding-turret-functionality"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#adding-turret-functionality"}},[e._v("#")]),e._v(" Adding Turret Functionality")]),e._v(" "),r("p",[e._v("Now with all the previous work set up and running, now we can focus on adding functionality to our turrets!")]),e._v(" "),r("h3",{attrs:{id:"turret-spawn-logic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#turret-spawn-logic"}},[e._v("#")]),e._v(" Turret Spawn Logic")]),e._v(" "),r("p",[e._v("So in this section we are going to get the code in to spawn the turrets onto our ship! This can be done with a simple addition to our ShipBase class file. What we are going to do is create a set of functions in our Ship class that will handle finding the turret sockets, spawning the turrets to those turret sockets, and then have a function to delete the spawned turrets properly so when the ship dies in your game, it will do the proper deletion.")]),e._v(" "),r("p",[e._v("So go back to your IDE and add the code below.")]),e._v(" "),r("p",[e._v("ShipBase.h")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("    // Spawn Turrets\nUPROPERTY(Category \\= BlueprintSpawn, EditDefaultsOnly, BlueprintReadOnly)\n\tTSubclassOf<ATurretBase\\> TurretBP;\nTArray<FName\\> TurretArray;\nTArray<ATurretBase\\*\\> SpawnedTurretArray;\n")])])]),r("p",[e._v("void GetTurretSockets();\nvoid SpawnTurret(FName _TurretSocketName);\nvoid DestroyTurrets();")]),e._v(" "),r("p",[e._v("Now got to ShipBase.cpp and lets fill out those three functions!")]),e._v(" "),r("p",[e._v("ShipBase.cpp")]),e._v(" "),r("p",[e._v("void AShipBase::GetTurretSockets() {\n// We store all the socket names into our own Turret Array\nTurretArray = HullMesh->GetAllSocketNames();\n// Then we iterate through that array and call our SpawnTurret() function and pass it our array's index\nfor (int i = 0; i < TurretArray.Num(); i++) {\nSpawnTurret(TurretArray[i]);\n}\n}\n \n/** Spawns the turrets onto the sockets of the ship */\nvoid AShipBase::SpawnTurret(FName _TurretSocketName)\n{\n// First we want to make sure these values are all zeroed out\nFVector SocketLocation;\nFTransform SocketTransform;\nSocketLocation = FVector(0, 0, 0);\nSocketLocation.Rotation() = FRotator(0, 0, 0);\n \n// Make sure the world exists first\nUWorld* const World = GetWorld();\nif (World && TurretBP != NULL)\n{\n// Set the spawn parameters\nFActorSpawnParameters SpawnParams;\nSpawnParams.Owner = this;\n \n// This is where we instantiate our new Turret! RailGun_T can be whatever you want to name it\nATurretBase* RailGun_T = GetWorld()->SpawnActor<ATurretBase>(TurretBP, SocketLocation, SocketLocation.Rotation());\n// Assign our newly spawned turret its rotation\nRailGun_T->TurretLocalRot = SocketLocation.Rotation();\n \n// Now we add that newly spawned turret to our array of pointers so we can reference it later\nSpawnedTurretArray.Add(RailGun_T);\n \n// Now we make sure our turret isn't null, and then attach it to our socket's location.\nif (RailGun_T != NULL)\n{\nRailGun_T->AttachToComponent(this->RootComponent, FAttachmentTransformRules::KeepRelativeTransform, _TurretSocketName);\n}\n}\n}\n \nvoid AShipBase::DestroyTurrets()\n{\n// Iterate over the turrets in the array we have them stored\nfor (int i = 0; i < SpawnedTurretArray.Num(); i++) {\nSpawnedTurretArray[i]->DetachFromControllerPendingDestroy();\nSpawnedTurretArray[i]->Destroy();\n}\n}")]),e._v(" "),r("p",[e._v("Now you just need to add our spawn function to the BeginPlay in ShipBase.cpp")]),e._v(" "),r("p",[e._v("// Called when the game starts or when spawned\nvoid AShipBase::BeginPlay()\n{\nSuper::BeginPlay();\n \nGetTurretSockets();\n}")]),e._v(" "),r("p",[e._v("Let us recap on what we did. First we went into the header file and created a few variables and three functions. The variables are important for a few reasons.")]),e._v(" "),r("ul",[r("li",[e._v("TSubclassOf"),r("ATurretBase",[e._v(" TurretBP;\n"),r("ul",[r("li",[e._v("This creates a pointer that we assign in our BP_Ship for any turret we want! We can create multiple of these pointers for when we have multiple different types of turrets.")])])])],1),e._v(" "),r("li",[e._v("TArray"),r("FName",[e._v(" TurretArray;\n"),r("ul",[r("li",[e._v("We did this to hold onto the sockets we find.")])])])],1),e._v(" "),r("li",[e._v("TArray<ATurretBase*> SpawnedTurretArray;\n"),r("ul",[r("li",[e._v("We created this to hold onto the spawned turrets so we can easily reference them later.")])])])]),e._v(" "),r("p",[e._v("Now for the functions, we have three.")]),e._v(" "),r("ol",[r("li",[e._v("void GetTurretSockets();\n"),r("ul",[r("li",[e._v("To get the turret sockets on the ship.")])])]),e._v(" "),r("li",[e._v("void SpawnTurret(FName _TurretSocketName);\n"),r("ul",[r("li",[e._v("To spawn a single turret, by passing it the socket we want it spawned to.")])])]),e._v(" "),r("li",[e._v("void DestroyTurrets();\n"),r("ul",[r("li",[e._v("To delete all the turrets we spawned for proper deletion for when the ship is deleted (during game-play)")])])])]),e._v(" "),r("p",[e._v("Now compile your code! Now if you go into the engine and double click your ship blueprint, in the details pane you should see a category called Blueprint Spawn. Inside that category is a picker, you want to click it and add in your Turret Blueprint.")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:BP_ShipDetails.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/3/3f/BP_ShipDetails.png",alt:"BP ShipDetails.png"}})])]),e._v(" "),r("p",[e._v("Now set the Default Pawn Class to your ship blueprint. Click Play and you should have a ship that is spawning turrets!")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:BP_ShipSpawning.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/7/79/BP_ShipSpawning.png",alt:"BP ShipSpawning.png"}})])]),e._v(" "),r("h3",{attrs:{id:"turret-control"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#turret-control"}},[e._v("#")]),e._v(" Turret Control")]),e._v(" "),r("p",[e._v("Now for the more complicated step in the logic department. Getting our turrets to look at our camera's focal point. This was the entire reason why your in this tutorial now aren't you?")]),e._v(" "),r("p",[e._v("Now before we go into the code I want to take a moment to explain what were going to try and do.")]),e._v(" "),r("p",[e._v("So what we want is for the turrets to look at wherever our cameras focal point is. So when we look right, the turrets should track our movement and attempt to point to where we are looking. In order to do this, they need to get our forward vector to know where exactly they are going to point. In order to figure out how much they need to rotate to get to our forward vector from the camera, they will need to take their forward vectors and normalize it against the cameras. Then all we do is take that normalized vector and apply it to our local rotation and voila! Our Turrets should now be looking at our camera's focal point!")]),e._v(" "),r("p",[e._v("It sounds pretty simple right? Well now it is! I'll be honest it took me awhile to figure this out on my own and get it working just right. So you remember that TurretLookAt() function we created? Well now it's time to fill that sucker out.")]),e._v(" "),r("p",[e._v("In the TurretBase.cpp file, go to where you have the skeleton of the function.")]),e._v(" "),r("p",[e._v("void ATurretBase::TurretLookAt()\n{\n// We want a pointer to hold our player controller.\nAPlayerController* PC = Cast<APlayerController>(Cast<APawn>(GetAttachParentActor())->GetController());\n// Then we make sure our player controller exists.\nif (PC)\n{\n// Set the Focal Point Distance\nfloat FocalDistance = 10000.0f;\n// Get Camera Vector & Rotator\nFVector CameraLocation = PC->PlayerCameraManager->GetCameraLocation();\nFRotator CameraRotation = PC->PlayerCameraManager->GetCameraRotation();\n// Get Turrets Vector & Rotator\nFVector TurretLocation = GetActorLocation();\nFRotator TurretRotation = GetActorRotation();\n \n// Handle Turret Rotation\nFVector FocalPoint = CameraLocation + (CameraRotation.Vector() * FocalDistance);\nFVector TurretToFocal = FocalPoint - TurretLocation;\nFVector TurretToFocalLocal = TurretRotation.UnrotateVector(TurretToFocal);\nFRotator TurretFocalLookDirection = TurretToFocalLocal.Rotation();\nFRotator TurretYaw = FRotator(0, TurretFocalLookDirection.Yaw, 0);\nCurrentTurretRot = GetActorRotation();\n \n// We check to see if the turret is within it's movement range, if it is, we add the rotation and do one last addition check.\nif (FMath::IsWithin(CurrentTurretRot.Yaw, TurretMinYaw, TurretMaxYaw))\n{\nTurretHullMesh->AddRelativeRotation(TurretYaw);\n// Now we check to see if it's pretty close to our target, when it is we toggle a boolean to be used later!\nif (TurretYaw.Yaw > 0.f)\n{\nIsTargeting = false;\n}\n}\nelse {\nIsTargeting = false;\n}\n \n// Now it's time to do the same for the turret's barrels pitch!\nFRotator TurretBarrelPitch = FRotator(TurretFocalLookDirection.Pitch, 0, 0);\nTurretBarrelPitch.Pitch = FMath::Clamp(TurretBarrelPitch.Pitch, TurretMinPitch, TurretMaxPitch);\nTurretBarrelMesh->SetRelativeRotation(TurretBarrelPitch);\n \n// Do the targeting check with the barrels as well!\nif (TurretBarrelPitch.Pitch == TurretFocalLookDirection.Pitch)\n{\nIsTargeting = true;\n}\nelse\n{\nIsTargeting = false;\n}\n}\n}")]),e._v(" "),r("p",[e._v("Now with that filled out, we want to go to our Tick() function and add our function call to it!")]),e._v(" "),r("p",[e._v("TurretBase.cpp")]),e._v(" "),r("p",[e._v("// Called every frame\nvoid ATurretBase::Tick( float DeltaTime )\n{\nTurretLookAt();\nSuper::Tick( DeltaTime );\n}")]),e._v(" "),r("p",[e._v("Compile and run the game! Now your turrets should rotate and the barrels should pitch! And that is how you get your turrets to follow your cameras focal point!")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:BP_TurretControl.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/c/c6/BP_TurretControl.png",alt:"BP TurretControl.png"}})])]),e._v(" "),r("h3",{attrs:{id:"turret-firing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#turret-firing"}},[e._v("#")]),e._v(" Turret Firing")]),e._v(" "),r("p",[e._v("Now, how about we get those turrets to fire? Everybody likes a good BOOM to their code! Now this section will be a little less informative. It's a challenge out to you to actually get the some of the set up work done! You've done it before, now you should have the tools to get the Munitions ready!")]),e._v(" "),r("p",[e._v("For how I got my projectiles set up, was that I followed the same steps in creating a MunitionsBase Class, and then I got it set up to hold a spherical mesh. Once that was done I made sure I added it to a collision channel for the projectiles.")]),e._v(" "),r("p",[e._v("Once you have the projectile class created, extend it into a blueprint!")]),e._v(" "),r("p",[e._v("Now that we have a munitions object to use, lets go back to our TurretBase.cpp. You remember earlier making a few more skeletons functions that we haven't filled out yet. Those functions were PrimaryFireControl(), GetMuzzleSockets(), and then SpawnMunitions().")]),e._v(" "),r("p",[e._v("It follows the similar path as to spawning the turrets. We want to find the muzzle sockets on the barrel mesh, add it to an array, then spawn the projectiles at the muzzle locations and add an impulse to the projectile.")]),e._v(" "),r("p",[e._v("TurretBase.cpp")]),e._v(" "),r("p",[e._v("/* ITurretInterface */\n// This acts as a gate for firing any projectiles. So if the turrets cannot see your cameras focal point they wont fire!\nvoid ATurretBase::PrimaryFireControl()\n{\nif (IsTargeting)\n{\nGetMuzzleSockets();\n}\n}\n \n// Same steps as to getting the sockets for the turrets!\nvoid ATurretBase::GetMuzzleSockets()\n{\nMuzzleArray = TurretBarrelMesh->GetAllSocketNames();\nfor (int i = 0; i < MuzzleArray.Num(); i++) {\nSpawnMunitions(MuzzleArray[i]);\n}\n}\n \n// Almost the same as spawning the turrets, but this time we check to make sure the projectile blueprint exists\nvoid ATurretBase::SpawnMunitions(FName _MuzzleSocketName)\n{\nif (MunitionsBP != NULL)\n{\n// Get the location and the rotation for the new projectile\nFVector SpawnLocation = TurretBarrelMesh->GetSocketLocation(_MuzzleSocketName);\nFRotator SpawnRotation = TurretBarrelMesh->GetSocketRotation(_MuzzleSocketName);\n \n// Making sure the world exists, if it does we spawn it!\nUWorld* const World = GetWorld();\nif (World && MunitionsBP) {\nAMunitionsBase* Projectile = World->SpawnActor<AMunitionsBase>(MunitionsBP, SpawnLocation, SpawnRotation);\n \n// We give the projectiles an owner! This can be used later for hit detection and the like!\nProjectile->OwningPlayer = GetController();\nProjectile->OwningActor = this->GetAttachParentActor();\n \n// This is completely option. I made a muzzle flash for fun. You can remove the below If statement if you want.\nif (MuzzleFX)\n{\nUParticleSystemComponent* MuzzleFlash = UGameplayStatics::SpawnEmitterAtLocation(this, MuzzleFX, SpawnLocation, SpawnRotation, true);\n}\n}\n}\n}")]),e._v(" "),r("p",[e._v("Now in order to make sure you can fire your turrets, we need to make sure we have a player input set up in the editor to control that. But one more step needs to be taken to tell the turrets that the player is firing! We can't just simply add the controls to the turrets themselves, we are going to take advantage of that Interface function, PrimaryFireControl()!")]),e._v(" "),r("p",[e._v("Now go to your ShipBase.cpp and add a input component.")]),e._v(" "),r("p",[e._v('InputComponent->BindAction("PrimaryFire", IE_Pressed, this, &AShipBase::ShipPrimaryFire);')]),e._v(" "),r("p",[e._v("Now we create the function! We are still in ShipBase.cpp. What were going to do here is loop through the SpawnedTurretArray and with the interface, tell them to execute the function PrimaryFireControl(). One purpose of Interfaces is to give us a way to call functions in another class or object when we don't want to hold onto the instantiated class in caller.")]),e._v(" "),r("p",[e._v("ShipBase.cpp")]),e._v(" "),r("p",[e._v("void AShipBase::ShipPrimaryFire() {\nfor (int i = 0; i < SpawnedTurretArray.Num(); i++) {\nITurretInterface* TheInterface = Cast<ITurretInterface>(SpawnedTurretArray[i]);\nif (TheInterface)\n{\nTheInterface->PrimaryFireControl();\n}\n}\n}")]),e._v(" "),r("p",[r("a",{attrs:{href:"/File:TurretFire.png"}},[r("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/1/1b/TurretFire.png",alt:"TurretFire.png"}})])]),e._v(" "),r("p",[e._v("Now before we continue, there is one last thing we need to do! You need to add a blank C++ class through the editor, you should name these files TurretInterface. Fill these files out like so.")]),e._v(" "),r("p",[e._v("TurretInterface.cpp")]),e._v(" "),r("p",[e._v('#include "TurretTutorial.h"\n#include "TurretInterface.h"\n \nUTurretInterface::UTurretInterface(const FObjectInitializer& ObjectInitializer)\n: Super(ObjectInitializer)\n{\n \n}\n \n// This is required for compiling, would also let you know if somehow you called\n// the base event/function rather the override version\nvoid ITurretInterface::PrimaryFireControl()\n{\n \n}')]),e._v(" "),r("p",[e._v("TurretInterface.h")]),e._v(" "),r("p",[e._v('#pragma once\n \n#include "TurretInterface.generated.h"\n \nUINTERFACE(MinimalAPI)\nclass UTurretInterface : public UInterface\n{\nGENERATED_UINTERFACE_BODY()\n};\n \nclass ITurretInterface\n{\nGENERATED_IINTERFACE_BODY()\n \npublic:\nvirtual void PrimaryFireControl() = 0;\n};')]),e._v(" "),r("p",[e._v("Now, with this you should be able to compile your project. These two files are primarily to set up the class, to be accessible globally but more importantly, allow the project to compile! Now let me spend just a moment to explain why the interface is useful and how it pertains to our application here. Interfaces in C++ allow you to set up game wide event triggers directly in C++ or the level blueprint. Now I wont spend the time explaining on how to open the C++ Interfaces to blueprints in this tutorial, but I may cover it in my second tutorial when I extend this out to support C++ Networking.")]),e._v(" "),r("p",[e._v("You can set up Interfaces like the one we just did for many things, for example, creating a special event such as a capital ship exploding and then having a multitude of different actors respond to it.")]),e._v(" "),r("h2",{attrs:{id:"conclusion"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),r("p",[e._v("There you have it! You now have a ship that can spawn turrets that will look to where your camera is pointing and also fire! Your just a couple steps away from creating a ship to ship combat game! This is just one out of a few ways of accomplishing this, and I do not claim this the most efficient but it is the solution I came up with. I'm particularly proud of it and find it a big achievement.")]),e._v(" "),r("p",[e._v("I do hope you found this tutorial helpful! If you have any questions or suggestions, feel free to PM me on the Unreal Engine Forums! It is after all my first tutorial and would love some feedback!")]),e._v(" "),r("p",[e._v("IntVoid")]),e._v(" "),r("p",[r("a",{attrs:{href:"/User:IntVoid",title:"User:IntVoid"}},[e._v("IntVoid")]),e._v(" ("),r("a",{attrs:{href:"/User_talk:IntVoid",title:"User talk:IntVoid"}},[e._v("talk")]),e._v(")")]),e._v(" "),r("p",[e._v('Retrieved from "'),r("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=C%2B%2B_Camera_Controlled_Turrets&oldid=22488",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=C%2B%2B_Camera_Controlled_Turrets&oldid=22488"),r("OutboundLink")],1),e._v('"')]),e._v(" "),r("p",[r("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Categories")]),e._v(":")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"/Category:Tutorials",title:"Category:Tutorials"}},[e._v("Tutorials")])]),e._v(" "),r("li",[r("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])])]),e._v(" "),r("p",[e._v("Hidden category:")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"/Category:Templates",title:"Category:Templates"}},[e._v("Templates")])])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=n.exports}}]);