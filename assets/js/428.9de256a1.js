(window.webpackJsonp=window.webpackJsonp||[]).push([[428],{427:function(e,n,t){"use strict";t.r(n);var o=t(28),r=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Custom Input Devices - Epic Wiki")]),e._v(" "),t("h1",{attrs:{id:"custom-input-devices"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#custom-input-devices"}},[e._v("#")]),e._v(" Custom Input Devices")]),e._v(" "),t("h2",{attrs:{id:"contents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#Overview"}},[e._v("1 Overview")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Example_Code"}},[e._v("2 Example Code")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#uPlugin_Ddefinition"}},[e._v("2.1 uPlugin Ddefinition")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Module_Build_File"}},[e._v("2.2 Module Build File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#IPlugin_Header_File"}},[e._v("2.3 IPlugin Header File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#PCH_File"}},[e._v("2.4 PCH File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Plugin_Header_File"}},[e._v("2.5 Plugin Header File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Plugin_Cpp_File"}},[e._v("2.6 Plugin Cpp File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Input_Device_Header_File"}},[e._v("2.7 Input Device Header File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Input_Device_Cpp_File"}},[e._v("2.8 Input Device Cpp File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Input_Device_Cpp_File_2"}},[e._v("2.9 Input Device Cpp File")])]),e._v(" "),t("li",[t("a",{attrs:{href:"#Input_Device_Cpp_File_3"}},[e._v("2.10 Input Device Cpp File")])])])])]),e._v(" "),t("h2",{attrs:{id:"overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),t("p",[e._v("This page will detail how to create custom Input Device plugins in order to add support for additional controller/input types. It will also show example code for adding additional Key/Gamepad Input Names. The code will show how to fire events from the existing Input Names via a MessageHandler and how to fire events from any Key/Gamepad Input directly.")]),e._v(" "),t("p",[e._v("The actor is a useful way of referencing the InputDevice to run arbitary methods. For some reason if the two actor classes are deleted this all fails to compile (Possibly related to *.generated.h files). If someone figures out why I would love to know (mspe044).")]),e._v(" "),t("h2",{attrs:{id:"example-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#example-code"}},[e._v("#")]),e._v(" Example Code")]),e._v(" "),t("p",[e._v('The code will show how to create a plugin for an input device named PsudoController which will simulate controller#1 pressing and holding the bottom face button (jump) and moving the right analog stick wildly. It will also create a new custom Gamepad Input called "Psudo Player Weight" and fire events for this input with a value of 75.0 (kg).')]),e._v(" "),t("p",[e._v("In your own code you will most likely link your plugin with a static/dynamic library which communicates with you Input Device. When the engine calls FPsudoControllerInputDevice::SendControllerEvents() you can then pass on any events/polled controller states using the MessageHandler in a generic way.")]),e._v(" "),t("h3",{attrs:{id:"uplugin-ddefinition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uplugin-ddefinition"}},[e._v("#")]),e._v(" uPlugin Ddefinition")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/PsudoController.uplugin")])]),e._v(" "),t("p",[e._v('{\n"FileVersion" : 0,\nÂ \n"FriendlyName" : "Psudo Controller Plugin",\n"Version" : 0,\n"VersionName" : "0.2",\n"CreatedBy" : "mspe044@gmail.com",\n"EngineVersion" : 1579795,\n"Description" : "I wish I was a real input!Â ðŸ˜¢",\n"Category" : "Tutorial",\nÂ \n"Modules" :\n[\n{\n"Name" : "PsudoController",\n"Type" : "Runtime",\n"LoadingPhase" : "PreDefault",\n"WhitelistPlatforms" : [ "Win64", "Win32" ]\n}\n]\n}')]),e._v(" "),t("h3",{attrs:{id:"module-build-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#module-build-file"}},[e._v("#")]),e._v(" Module Build File")]),e._v(" "),t("p",[e._v("This is where you link to any library supporting your Input Device. There is a sample method 'LoadYourThirdPartyLibraries()' to help you do this however the call to it is currently commented out.")]),e._v(" "),t("p",[e._v("This method will will link to a static library in "),t("strong",[e._v(".../Plugins/PsudoController/Source/PsudoController/ThirdParty/LibraryDirName/...")]),e._v(" with include files in the sub directory "),t("strong",[e._v(".../include/")]),e._v(" and library code in subdirectoires seprated by compile arcitecture I.E. "),t("strong",[e._v(".../Win64/VS2013/MyLibrary.lib")])]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/PsudoController.Build.cs")])]),e._v(" "),t("p",[e._v('namespace UnrealBuildTool.Rules\n{\nusing System.IO; // ToDo: Replace with standard mechenism\nÂ \npublic class PsudoController : ModuleRules\n{\npublic PsudoController(TargetInfo Target)\n{\nPCHUsage = PCHUsageMode.NoSharedPCHs;\nÂ \n// ... add public include paths required here ...\nPublicIncludePaths.AddRange( new string[] {\n"PsudoController/Public",\n"PsudoController/Classes",\n});\nÂ \n// ... add other private include paths required here ...\nPrivateIncludePaths.AddRange( new string[] {\n"PsudoController/Private",\n});\nÂ \n// ... add other public dependencies that you statically link with here ...\nPublicDependencyModuleNames.AddRange( new string[] {\n"Core",\n"CoreUObject",      // Provides Actors and Structs\n"Engine",           // Used by Actor\n"Slate",            // Used by InputDevice to fire bespoke FKey events\n"InputCore",        // Provides LOCTEXT and other Input features\n"InputDevice",      // Provides IInputInterface\n});\nÂ \n// ... add private dependencies that you statically link with here ...\nPrivateDependencyModuleNames.AddRange( new string[] {\n});\nÂ \n// ... add any modules that your module loads dynamically here ...\nDynamicallyLoadedModuleNames.AddRange( new string[] {\n});\nÂ \n//Â !!!!!!!!!! UNCOMMENT THIS IF YOU WANT TO CALL A LIBRARYÂ !!!!!!!!!!\n//LoadYourThirdPartyLibraries(Target);\n}\nÂ \npublic bool LoadYourThirdPartyLibraries(TargetInfo Target)\n{\nbool isLibrarySupported = false;\nÂ \n// This will give oyu a relitive path to the module ../PsudoController/\nstring ModulePath = Path.GetDirectoryName(RulesCompiler.GetModuleFilename(this.GetType().Name));\n// This will give you a relative path to ../PsudoController/ThirdParty/"LibraryDirName"/\nstring MyLibraryPath = Path.Combine(ModulePath, "ThirdParty", "LibraryDirName");\nÂ \n// Use this to keep Win32/Win64/e.t.c. library files in seprate subdirectories\nstring ArchitecturePath = "";\nÂ \n// When you are building for Win64\nif (Target.Platform == UnrealTargetPlatform.Win64 &&\nWindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)\n{\n// We will look for the library in ../PsudoController/ThirdParty/MyLibrary/Win64/VS20##/\nArchitecturePath = Path.Combine("Win64", "VS" + WindowsPlatform.GetVisualStudioCompilerVersionName());\nÂ \nisLibrarySupported = true;\n}\n// When you are building for Win32\nelse if (Target.Platform == UnrealTargetPlatform.Win32 &&\nWindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)\n{\n// We will look for the library in ../PsudoController/ThirdParty/MyLibrary/Win32/VS20##/\nArchitecturePath = Path.Combine("Win32", "VS" + WindowsPlatform.GetVisualStudioCompilerVersionName());\nÂ \nisLibrarySupported = true;\n}\n// Add mac/linux/mobile support in much the same way\nÂ \n// If the current build architecture was supported by the above if statements\nif (isLibrarySupported)\n{\n// Add the architecture spacific path to the library files\nPublicAdditionalLibraries.Add(Path.Combine(MyLibraryPath, "lib", ArchitecturePath, "MyLibrary.lib"));\n// Add a more generic path to the include header files\nPublicIncludePaths.Add(Path.Combine(MyLibraryPath, "include"));\n}\nÂ \n// Defination lets us know whether we successfully found our library!\nDefinitions.Add(string.Format("WITH_MY_LIBRARY_PATH_USE={0}", isLibrarySupported ? 1 : 0));\nÂ \nreturn isLibrarySupported;\n}\n}\n}')]),e._v(" "),t("h3",{attrs:{id:"iplugin-header-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#iplugin-header-file"}},[e._v("#")]),e._v(" IPlugin Header File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Public/IPsudoControllerPlugin.h")])]),e._v(" "),t("p",[e._v('#pragma once\nÂ \n#include "ModuleManager.h"\n#include "IInputDeviceModule.h"\nÂ \n#include "InputCoreTypes.h"\nÂ \n/**\n* The public interface to this module.  In most cases, this interface is only public to sibling modules\n* within this plugin.\n*/\nclass IPsudoControllerPlugin : public IInputDeviceModule\n{\npublic:\n/**\n* Singleton-like access to this module\'s interface.  This is just for convenience!\n* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.\n*\n* @return Returns singleton instance, loading the module on demand if needed\n*/\nstatic inline IPsudoControllerPlugin& Get() {\nreturn FModuleManager::LoadModuleChecked< IPsudoControllerPlugin >("PsudoController");\n}\nÂ \n/**\n* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.\n*\n* @return True if the module is loaded and ready to use\n*/\nstatic inline bool IsAvailable() {\nreturn FModuleManager::Get().IsModuleLoaded( "PsudoController" );\n}\nÂ \n// This is where I declare my fancy new output type\n//  - It\'s pretending to be a set of scales like a poor mans Wii Balance Board)\nstatic const FKey Psudo_WeighingScales;\n};')]),e._v(" "),t("h3",{attrs:{id:"pch-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pch-file"}},[e._v("#")]),e._v(" PCH File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerPrivatePCH")])]),e._v(" "),t("p",[e._v('// You should place include statements to your module\'s private header files here.  You only need to\n// add includes for headers that are used in most of your module\'s source files though.\nÂ \n#include "Core.h"\n#include "CoreUObject.h"\nÂ \n#include "IPsudoControllerPlugin.h"')]),e._v(" "),t("h3",{attrs:{id:"plugin-header-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin-header-file"}},[e._v("#")]),e._v(" Plugin Header File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerPlugin.h")])]),e._v(" "),t("p",[e._v('#pragma once\n#include "PsudoControllerPrivatePCH.h"\nÂ \nclass FPsudoControllerPlugin : public IPsudoControllerPlugin\n{\npublic:\n/** IPsudoControllerInterface implementation */\nvirtual TSharedPtr< class IInputDevice > CreateInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler);\nÂ \n//virtual void StartupModule() OVERRIDE; // This is not required as IInputDeviceModule handels it!\nvirtual void ShutdownModule() OVERRIDE;\nÂ \nTSharedPtr< class FPsudoControllerInputDevice > PsudoInputDevice;\n};')]),e._v(" "),t("h3",{attrs:{id:"plugin-cpp-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin-cpp-file"}},[e._v("#")]),e._v(" Plugin Cpp File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerPlugin.cpp")])]),e._v(" "),t("p",[e._v('#include "PsudoControllerPrivatePCH.h"\nÂ \n#include "Internationalization.h" // LOCTEXT\n#include "InputCoreTypes.h"\nÂ \n#include "PsudoControllerPlugin.h"\nÂ \n#include "Engine.h" // Are these both necessary?\n#include "EngineUserInterfaceClasses.h" // Are these both necessary?\nÂ \n#include "IPsudoControllerPlugin.h"\nÂ \n#include "PsudoController.generated.inl"\nÂ \nIMPLEMENT_MODULE(FPsudoControllerPlugin, PsudoController)\nDEFINE_LOG_CATEGORY_STATIC(PsudoControllerPlugin, Log, All);\nÂ \n#define LOCTEXT_NAMESPACE "InputKeys"\nÂ \nconst FKey IPsudoControllerPlugin::Psudo_WeighingScales("Psudo_WeighingScales");\nÂ \n// This function is called by *Application.cpp after startup to instantiate the modules InputDevice\nTSharedPtr< class IInputDevice > FPsudoControllerPlugin::CreateInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler)\n{\nUE_LOG(PsudoControllerPlugin, Log, TEXT("Create Input Device"));\nÂ \n// EKey: use these sparingly... only when you need a button/axis/motion that doesn\'t fit any of the input names that already exist\n//  - I\'m defineing my poor mans Wii Balance Board, it will be called "Psudo Player Weight" in the editor\nEKeys::AddKey(FKeyDetails(IPsudoControllerPlugin::Psudo_WeighingScales, LOCTEXT("Psudo_WeighingScales", "Psudo Player Weight"), FKeyDetails::Axis));\nconst_cast<UInputSettings*>(GetDefault<UInputSettings>())->AddAxisMapping(FInputAxisKeyMapping("PsudoWeighingScales", IPsudoControllerPlugin::Psudo_WeighingScales, 1.0F));\nÂ \nFPsudoControllerPlugin::PsudoInput = MakeShareable(new FPsudoControllerInputDevice(InMessageHandler));\nÂ \nreturn PsudoInput;\n}\nÂ \n#undef LOCTEXT_NAMESPACE\nÂ \n// This function may be called during shutdown to clean up the module.\nvoid FPsudoControllerPlugin::ShutdownModule()\n{\nFPsudoControllerPlugin::PsudoInput->~FPsudoControllerInputDevice();\nÂ \nUE_LOG(PsudoControllerPlugin, Log, TEXT("Shutdown Module"));\n}')]),e._v(" "),t("h3",{attrs:{id:"input-device-header-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-device-header-file"}},[e._v("#")]),e._v(" Input Device Header File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerInputDevice.h")])]),e._v(" "),t("p",[e._v("#pragma once\nÂ \n#include \"IInputDevice.h\"\nÂ \n#define MAX_NUM_PSUDO_INPUT_CONTROLLERS\t4 // We dont realy have any input controllers, this is a sham!Â ðŸ˜›\n#define NUM_PSUDO_INPUT_BUTTONS\t\t\t6 // I've only used the one button but w/evs\nÂ \n/**\n* Type definition for shared pointers to instances of FMessageEndpoint.\n*/\n// ToDo: Is this necessary?\ntypedef TSharedPtr<class FPsudoControllerInputDevice> FPsudoControllerInputDevicePtr;\nÂ \n/**\n* Type definition for shared references to instances of FMessageEndpoint.\n*/\n// ToDo: Is this necessary?\ntypedef TSharedRef<class FPsudoControllerInputDevice> FPsudoControllerInputDeviceRef;\nÂ \n/**\n* Interface class for WiiInput devices (wii devices)\n*/\nclass FPsudoControllerInputDevice : public IInputDevice\n{\npublic:\nFPsudoControllerInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& MessageHandler);\nÂ \n/** Tick the interface (e.g. check for new controllers) */\nvirtual void Tick(float DeltaTime) OVERRIDE;\nÂ \n/** Poll for controller state and send events if needed */\nvirtual void SendControllerEvents() OVERRIDE;\nÂ \n/** Set which MessageHandler will get the events from SendControllerEvents. */\nvirtual void SetMessageHandler(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler) OVERRIDE;\nÂ \n/** Exec handler to allow console commands to be passed through for debugging */\nvirtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) OVERRIDE;\nÂ \n// IForceFeedbackSystem pass through functions\nvirtual void SetChannelValue(int32 ControllerId, FForceFeedbackChannelType ChannelType, float Value) OVERRIDE;\nvirtual void SetChannelValues(int32 ControllerId, const FForceFeedbackValues &values) OVERRIDE;\nÂ \nvirtual ~FPsudoControllerInputDevice();\nprivate:\n// ToDo: Is this necessary?\nbool Active;\nÂ \n/** Delay before sending a repeat message after a button was first pressed */\nfloat InitialButtonRepeatDelay; // How long a button is held for before you send a 2nd event\nÂ \n/** Delay before sending a repeat message after a button has been pressed for a while */\nfloat ButtonRepeatDelay; // How long a button is held for before you send a 3rd/4th/e.t.c event\nÂ \nEControllerButtons::Type PsudoInputButtonMapping[NUM_PSUDO_INPUT_BUTTONS];\nÂ \n/** Last frame's button states, so we only send events on edges */\nbool PreviousButtonStates[NUM_PSUDO_INPUT_BUTTONS];\nÂ \n/** Next time a repeat event should be generated for each button */\ndouble NextRepeatTime[NUM_PSUDO_INPUT_BUTTONS];\nÂ \nTSharedRef< FGenericApplicationMessageHandler > MessageHandler;\n};")]),e._v(" "),t("h3",{attrs:{id:"input-device-cpp-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-device-cpp-file"}},[e._v("#")]),e._v(" Input Device Cpp File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerInputDevice.cpp")])]),e._v(" "),t("p",[e._v('#include "PsudoControllerPrivatePCH.h"\nÂ \n#include "GenericPlatformMath.h"\nÂ \n#include "PsudoControllerInputDevice.h"\nÂ \n#include "Slate.h"\nÂ \n#include "WindowsApplication.h"\n#include "WindowsWindow.h"\n#include "WindowsCursor.h"\n#include "GenericApplicationMessageHandler.h"\n#include "IInputDeviceModule.h"\n#include "IInputDevice.h"\nÂ \nDEFINE_LOG_CATEGORY_STATIC(LogPsudoControllerDevice, Log, All);\nÂ \nFPsudoControllerInputDevice::FPsudoControllerInputDevice(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler) : Active(true), MessageHandler(InMessageHandler) {\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Starting PsudoControllerInputDevice"));\nÂ \n// Initialize button repeat delays\nInitialButtonRepeatDelay = 0.2f;\nButtonRepeatDelay = 0.1f;\nÂ \n// Setting all buttons on my psudo controllers to \'not pressed\'\n// (You should check the inital state of your controllers)\nPreviousButtonStates[NUM_PSUDO_INPUT_BUTTONS] = { 0 };\n//NextRepeatTime[NUM_PSUDO_INPUT_BUTTONS] = { 0.0 };\nÂ \n// Initialize mapping of controller button mask to unreal button mask\n// - mapping 0-3 to the \'FaceButtons\'\n// --- \'X\',\'Square\',\'Circle\',\'Triangle\' for playstation\n// --- \'A\',\'X\',\'B\',\'Y\' on xbox\nPsudoInputButtonMapping[0] = EControllerButtons::FaceButtonTop;\t\t// PSUDO_BUTTON_ZERO\nPsudoInputButtonMapping[1] = EControllerButtons::FaceButtonBottom;\t// PSUDO_BUTTON_ONE\nPsudoInputButtonMapping[2] = EControllerButtons::FaceButtonLeft;\t// PSUDO_BUTTON_TWO\nPsudoInputButtonMapping[3] = EControllerButtons::FaceButtonRight;\t// PSUDO_BUTTON_THREE\n// - mapping 4-5 to the left joystick (traditionally used for movement controls)\nPsudoInputButtonMapping[4] = EControllerButtons::LeftAnalogX;\t\t// PSUDO_BUTTON_FOUR\nPsudoInputButtonMapping[5] = EControllerButtons::LeftAnalogY;\t\t// PSUDO_BUTTON_FIVE\n}\nÂ \nvoid FPsudoControllerInputDevice::Tick(float DeltaTime) {\n// This will spam the log heavily, comment it out for real pluginsÂ ðŸ˜ƒ\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("TickÂ %f"), DeltaTime);\n}\nÂ \nvoid FPsudoControllerInputDevice::SendControllerEvents() {\n// Here is where we check the state of our input device proberbly by calling a method in your third party libary...\n//  - I dont have a real device (xbox controller, wiimote, e.t.c.) in this tutorialÂ ðŸ˜¢ so we will just pretend!!!\nÂ \n// I could make libary to read from a fancy set of \'matrix\' cerebellum jacks and iterate over each of those \'controllers\'.. but ill save that for the next tutorial\nint controllerIndex = 0; // Apparantly I was lazy so there is only one controller firing events today!\nÂ \nconst double CurrentTime = FPlatformTime::Seconds();\nconst float CurrentTimeFloat = FPlatformTime::ToSeconds(FPlatformTime::Cycles()); // Works with FMath functions\nÂ \n// This weard statement simulates user holding down the button 1/3 of the time\nif (FMath::Fmod(CurrentTimeFloat, 1.5f) < .5f) {\n// If the button was pressed this tick\nif (!PreviousButtonStates[1]) {\n// Fire button pressed event\nMessageHandler->OnControllerButtonPressed(PsudoInputButtonMapping[1], controllerIndex, false);\nÂ \n// this button was pressed - set the button\'s NextRepeatTime to the InitialButtonRepeatDelay\nNextRepeatTime[1] = CurrentTime + InitialButtonRepeatDelay;\nPreviousButtonStates[1] = true;\n// If the buttons has been held long enough to fire a nth event\n} else if (NextRepeatTime[1] <= CurrentTime) {\n// Fire button held event\nMessageHandler->OnControllerButtonPressed(PsudoInputButtonMapping[1], controllerIndex, true);\nÂ \n// set the button\'s NextRepeatTime to the ButtonRepeatDelay\nNextRepeatTime[1] = CurrentTime + ButtonRepeatDelay;\n}\n// If the button was released this tick\n}\nelse if (PreviousButtonStates[1]) {\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Release"));\n// Fire button released event\nMessageHandler->OnControllerButtonReleased(PsudoInputButtonMapping[1], controllerIndex, false);\nPreviousButtonStates[1] = false;\n}\nÂ \n// This simulates the user moving the stick left and right repeatedly\nfloat xMove = FMath::Sin(CurrentTimeFloat * .223f * 2 * PI);\n// Fire analog input event\nMessageHandler->OnControllerAnalog(PsudoInputButtonMapping[4], controllerIndex, xMove);\nÂ \n// This simulates the user moving the stick up and down repeatedly\nfloat yMove = FMath::Cos(CurrentTimeFloat * .278f * 2 * PI);\n// Fire analog input event\nMessageHandler->OnControllerAnalog(PsudoInputButtonMapping[5], controllerIndex, yMove);\nÂ \n// This will spam the log heavily, comment it out for real pluginsÂ ðŸ˜ƒ\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Sending Controller Events jump%d, x%f, y%f"), PreviousButtonStates[1], xMove, yMove);\nÂ \n// This is how you fire your fancypantz new controller events... the ones you added because you couldn\'t find an existing EControllerButton that matched your needs!\nFSlateApplication::Get().OnControllerAnalog(IPsudoControllerPlugin::Psudo_WeighingScales, controllerIndex, 75); // This will spam 75(kg) to my fancy new output type!\n}\nÂ \nvoid FPsudoControllerInputDevice::SetMessageHandler(const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler) {\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Set Message Handler"));\nMessageHandler = InMessageHandler;\n}\nÂ \nbool FPsudoControllerInputDevice::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) {\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Execute Console Command:Â %s"), Cmd);\nÂ \n// Put your fancy custom console command code here...\n// ToDo: use this to let you fire psudo controller events\nÂ \nreturn true;\n}\nÂ \n// IForceFeedbackSystem pass through functions\n//  - I *believe* this is a handel for the game to communicate back to your third party libary (i.e. game tells joystick to increase force feedback/vibrate/turn on/off a light)\nvoid FPsudoControllerInputDevice::SetChannelValue(int32 ControllerId, FForceFeedbackChannelType ChannelType, float Value) {\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Set Force FeedbackÂ %f"), Value);\n}\nvoid FPsudoControllerInputDevice::SetChannelValues(int32 ControllerId, const FForceFeedbackValues &values) {\n// This will spam the log heavily, comment it out for real pluginsÂ ðŸ˜ƒ\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Set Force Feedback Values"));\n}\nÂ \n// This is where you nicely clean up your plugin when its told to shut down!\n//  - USE THIS PLEASE!!! no one likes memory leaks >_<\nFPsudoControllerInputDevice::~FPsudoControllerInputDevice() {\nUE_LOG(LogPsudoControllerDevice, Log, TEXT("Closing PsudoControllerInputDevice"));\n}')]),e._v(" "),t("h3",{attrs:{id:"input-device-cpp-file-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-device-cpp-file-2"}},[e._v("#")]),e._v(" Input Device Cpp File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Classes/PsudoActor.cpp")])]),e._v(" "),t("p",[e._v('// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.\n#include "PsudoControllerPrivatePCH.h"\nÂ \n#include "Engine.h"\n#include "PsudoActorObject.h"\nÂ \n#include "PsudoControllerPlugin.h"\n#include "PsudoControllerInputDevice.h"\nÂ \nDEFINE_LOG_CATEGORY_STATIC(LogPsudoActor, Log, All);\nÂ \n// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.\nÂ \nAPsudoActorObject::APsudoActorObject(const class FPostConstructInitializeProperties& PCIP) : Super(PCIP) {\nUE_LOG(LogPsudoActor, Log, TEXT("Construct"));\n}\nÂ \nvoid APsudoActorObject::FunkyMethod() {\nUE_LOG(LogPsudoActor, Log, TEXT("FunkyMethod()"));\n}')]),e._v(" "),t("h3",{attrs:{id:"input-device-cpp-file-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#input-device-cpp-file-3"}},[e._v("#")]),e._v(" Input Device Cpp File")]),e._v(" "),t("p",[t("strong",[e._v("/Plugins/PsudoController/Source/PsudoController/Classes/PsudoActor.h")])]),e._v(" "),t("p",[e._v('#pragma once\n#include "GameFramework/Actor.h"\n#include "PsudoActorObject.generated.h"\nÂ \nUCLASS(MinimalAPI, hidecategories = (Input))\nclass APsudoActorObject : public AActor\n{\nGENERATED_UCLASS_BODY()\nÂ \nUFUNCTION(BlueprintCallable, Category = "Development")\nvirtual void FunkyMethod();\n};')]),e._v(" "),t("p",[t("a",{attrs:{href:"/index.php?title=User:Mspe044&action=edit&redlink=1",title:"User:Mspe044 (page does not exist)"}},[e._v("mspe044")]),e._v(" ("),t("a",{attrs:{href:"/index.php?title=User_talk:Mspe044&action=edit&redlink=1",title:"User talk:Mspe044 (page does not exist)"}},[e._v("talk")]),e._v(")")]),e._v(" "),t("p",[e._v('Retrieved from "'),t("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=Custom_Input_Devices&oldid=10252",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=Custom_Input_Devices&oldid=10252"),t("OutboundLink")],1),e._v('"')]),e._v(" "),t("p",[t("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"/Category:Code",title:"Category:Code"}},[e._v("Code")])])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);n.default=r.exports}}]);