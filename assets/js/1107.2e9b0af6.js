(window.webpackJsonp=window.webpackJsonp||[]).push([[1107],{556:function(e,t,a){"use strict";a.r(t);var r=a(28),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("UE4 Transform Calculus - Part 1 - Epic Wiki")]),e._v(" "),a("h1",{attrs:{id:"ue4-transform-calculus-part-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ue4-transform-calculus-part-1"}},[e._v("#")]),e._v(" UE4 Transform Calculus - Part 1")]),e._v(" "),a("h2",{attrs:{id:"contents"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#UE4_Transform_Calculus_-_Part_1"}},[e._v("1 UE4 Transform Calculus - Part 1")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Motivation"}},[e._v("1.1 Motivation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Target_Audience"}},[e._v("1.2 Target Audience")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Why_.E2.80.9CCalculus.3F.E2.80.9D"}},[e._v("1.3 Why ‚ÄúCalculus?‚Äù")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Rigid_Body_Hierarchies"}},[e._v("1.4 Rigid Body Hierarchies")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Hierarchies_as_Attachments"}},[e._v("1.4.1 Hierarchies as Attachments")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Hierarchies_as_Frames_of_Reference"}},[e._v("1.4.2 Hierarchies as Frames of Reference")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Transform_Calculus"}},[e._v("1.5 Transform Calculus")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Transforming_Vectors_and_Points"}},[e._v("1.6 Transforming Vectors and Points")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Summary"}},[e._v("1.7 Summary")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Footnotes"}},[e._v("1.7.1 Footnotes")])])])])])])]),e._v(" "),a("h1",{attrs:{id:"ue4-transform-calculus-part-1-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ue4-transform-calculus-part-1-2"}},[e._v("#")]),e._v(" UE4 Transform Calculus - Part 1")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("Slate often has to deal with deep and wide hierarchies of widgets, expressing the sizes and positions of children in terms of their parents. Sometimes these are simple relationships like text in a button, but sometimes those relationships are much more complex, like a graph editing panel that might be panning and zooming across a virtual canvas.")]),e._v(" "),a("p",[e._v("As hierarchies get deeper, this relationship becomes layered. For instance, if we apply a global DPI (dots per inch) scale to our application, which itself sits in a window at some arbitrary location on the desktop, there are a series of zooms and offsets that combine to form the final position of a widget on the screen.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img1.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/3/33/Calc1img1.png",alt:"Calc1img1.png"}})])]),e._v(" "),a("p",[a("em",[e._v("[The complex relationship of slate widgets. A UE4 Editor view displaying blueprint widgets within a virtual panel within a tabwell within a window, all having a global application scale applied. The Blueprint editor must reason about the widgets in "),a("strong",[e._v("virtual canvas space")]),e._v(", implement mouse events in "),a("strong",[e._v("desktop space")]),e._v(", and render the widgets in "),a("strong",[e._v("window space")]),e._v(".]")])]),e._v(" "),a("p",[e._v("Slate must not only be able to unwind these hierarchies internally, but also provide straightforward ways for widget authors to reason about widgets in multiple spaces (ie, local, virtual canvas, window, desktop). With the addition of "),a("a",{attrs:{href:"https://docs.unrealengine.com/latest/INT/Engine/UMG/UserGuide/Styling/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Render Transforms"),a("OutboundLink")],1),e._v(" to Slate, the math for computing a child‚Äôs relationship to its parent became much more involved than a simple scale and offset.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img2.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/2/2c/Calc1img2.png",alt:"Calc1img2.png"}})])]),e._v(" "),a("p",[a("em",[e._v("[SlateViewer can apply an arbitrary render transform to the entire application. Now what‚Äôs the relationship of one of these widgets to its parent, or the window, or the desktop?]")])]),e._v(" "),a("p",[e._v("In fact, the historical simplicity of a child widget‚Äôs transform with respect to its parent in Slate contributed to an overall daunting task of updating hundreds of widgets to support arbitrary render transforms. We chose to focus on the core widgets that most widgets are composed of, but lots of legacy functions still exist in Slate that are used by other widgets that don‚Äôt support render transforms. This series of posts will focus on a new notation for manipulating transforms, along with a C++ implementation in UE4 that Slate is using to assist with this sometimes mind-bending task.")]),e._v(" "),a("h2",{attrs:{id:"target-audience"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#target-audience"}},[e._v("#")]),e._v(" Target Audience")]),e._v(" "),a("p",[e._v("For this discussion, I assume you are already aware of basic "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Linear_algebra",target:"_blank",rel:"noopener noreferrer"}},[e._v("linear algebra"),a("OutboundLink")],1),e._v(" and have at least cursory experience working with rigid body hierarchies in code. You should be comfortable with vectors and matrices, be able to perform basic calculations with them, and be familiar with the idea of using them to represent transformations like translation, rotation, scale, shear, etc. Some familiarity with alternate representations like quaternions etc may also be useful when we start discussing the code implementation. If you‚Äôve ever tried to use a physics engine or render something in OpenGL or Direct3D, you likely have more than enough exposure to these concepts.")]),e._v(" "),a("p",[e._v("I will generally try to keep a conversational tone, but will occasionally stray into math-heavy territory. When I do, I‚Äôll try to summarize the salient points and provide links to read up more if you‚Äôd like. The reason for ‚Äúgetting mathy‚Äù sometimes is to establish the mathematical foundation for the notation we are developing, not to rigorously prove it. I‚Äôm a programmer, not a mathematician.")]),e._v(" "),a("h2",{attrs:{id:"why-calculus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-calculus"}},[e._v("#")]),e._v(" Why ‚ÄúCalculus?‚Äù")]),e._v(" "),a("p",[e._v("So, a word about why I chose the term ‚ÄúTransform Calculus‚Äù instead of something less presumptive (like Framework or API). This document in fact describes a "),a("a",{attrs:{href:"http://www.encyclopediaofmath.org/index.php/Logical_calculus",target:"_blank",rel:"noopener noreferrer"}},[e._v("logical calculus"),a("OutboundLink")],1),e._v(", or a formalization of a logical theory[1]. These are concepts that provide a mathematical notation for uniformly expressing and manipulating transforms that transcends the representation (ie, a matrix or quaternion).")]),e._v(" "),a("p",[e._v("There happens to be an implementation in UE4, but that implementation is secondary to the underlying concepts. Also, the implementation sometimes has to make compromises to work within the C++ language and UE4 Core types, so is not a pure expression of these concepts.")]),e._v(" "),a("p",[e._v("To be clear, I'm not inventing anything \"novel\", I‚Äôm just wrapped some well-known math concepts in a higher level abstraction. That said, I do feel all the focus on notation is a critical part of the journey, as one can't use the library effectively without understanding the notation. For that reason, simply referring to this as a Framework or API seemed insufficient.")]),e._v(" "),a("p",[e._v("One could perhaps more accurately refer to this an an "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Algebra_over_a_field",target:"_blank",rel:"noopener noreferrer"}},[e._v("algebra"),a("OutboundLink")],1),e._v(", as it‚Äôs closed over the affine vector space. But I don‚Äôt prove this, and frankly I‚Äôve been using the term calculus for years, so it seemed too late to turn back now. C‚Äôest la vie.¬†üòÉ")]),e._v(" "),a("h2",{attrs:{id:"rigid-body-hierarchies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rigid-body-hierarchies"}},[e._v("#")]),e._v(" Rigid Body Hierarchies")]),e._v(" "),a("p",[e._v("Slate UI hierarchies are conceptually identical to rigid body hierarchies that physics engines utilize. We‚Äôll start with a quick overview of rigid body hierarchies to establish the concepts. I expect anyone reading this to be familiar already, so I won‚Äôt dwell on details.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img3.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/8/86/Calc1img3.png",alt:"Calc1img3.png"}})])]),e._v(" "),a("h3",{attrs:{id:"hierarchies-as-attachments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hierarchies-as-attachments"}},[e._v("#")]),e._v(" Hierarchies as Attachments")]),e._v(" "),a("p",[e._v("One way to think about the hierarchy is as each part being ‚Äúattached‚Äù to its parent by a transformation. This transformation places a child part relative to its parent. To place a part in the world we start at the root of the tree (‚Äúworld space‚Äù) and successively transform the part all the way down to the leaf node where the part is located.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1imgIV.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/7/70/Calc1imgIV.png",alt:"Calc1imgIV.png"}})])]),e._v(" "),a("p",[e._v("If one thinks of these transformations as simple offsets, then it is easy to conceptualize. However, most rigid body systems allow more complex transformations like scale, rotate, and/or shear. Reasoning about parts‚Äô relations to each other in such a hierarchy can quickly become very complicated.")]),e._v(" "),a("h3",{attrs:{id:"hierarchies-as-frames-of-reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hierarchies-as-frames-of-reference"}},[e._v("#")]),e._v(" Hierarchies as Frames of Reference")]),e._v(" "),a("p",[e._v("Another way to look at the hierarchy is that each part is a camera, and the transformation is taking the part from it‚Äôs local the coordinate system into that of the parent. So each part is essentially in it‚Äôs own coordinate system, or "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Frame_of_reference",target:"_blank",rel:"noopener noreferrer"}},[e._v("‚Äúframe of reference‚Äù"),a("OutboundLink")],1),e._v(" relative to its parent. The representation is logically equivalent to the attachment point of view described above, but instead of viewing all parts as placed at different points in the same coordinate system, each part has its own local coordinate system. This makes it easier to conceptualize the parent-child relationship as more than a simple offset. To place a child in the world, we chain, or composite, these transformations in succession just as we did when thinking of them as attachments.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/File:Calc1img5.png"}},[a("img",{attrs:{src:"https://d26ilriwvtzlb.cloudfront.net/9/97/Calc1img5.png",alt:"Calc1img5.png"}})])]),e._v(" "),a("h2",{attrs:{id:"transform-calculus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transform-calculus"}},[e._v("#")]),e._v(" Transform Calculus")]),e._v(" "),a("p",[e._v("This notion of a hierarchy as a chain of transformations taking us from one frame of reference to another is very powerful. In linear algebra, a frame of reference is like a vector "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Basis_%28linear_algebra%29",target:"_blank",rel:"noopener noreferrer"}},[e._v("basis"),a("OutboundLink")],1),e._v("[2], and the transformation to another frame of reference is a "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Change_of_basis",target:"_blank",rel:"noopener noreferrer"}},[e._v("change of basis"),a("OutboundLink")],1),e._v(". In code, we often represent this transformation as a matrix and composite them using matrix multiplication[3]. For efficiency, we sometimes represent a transform using narrower representations like euler angles, quaternions, translations, or even scalars. Regardless of the representation we use, a transformation is essentially a function over a vector space that maps one frame of reference to another. We can represent this function along with operations to manipulate it using a common notation, or calculus:")]),e._v(" "),a("p",[e._v("Transform Calculus Operations")]),e._v(" "),a("p",[e._v("Transformation")]),e._v(" "),a("p",[e._v("TA->B(V)")]),e._v(" "),a("p",[e._v("Evaluating T transforms V from frame A to frame B")]),e._v(" "),a("ul",[a("li",[e._v("Frame A is the ‚Äúinput frame‚Äù")]),e._v(" "),a("li",[e._v("Frame B is the ‚Äúoutput frame‚Äù")])]),e._v(" "),a("p",[a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Inverse_function",target:"_blank",rel:"noopener noreferrer"}},[e._v("Inversion"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("TA->B-1 ‚áí TB->A")]),e._v(" "),a("p",[e._v("T-1 reverses the input and output frames, so A->B becomes B->A.")]),e._v(" "),a("p",[a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Composition_of_relations",target:"_blank",rel:"noopener noreferrer"}},[e._v("Composition"),a("OutboundLink")],1),e._v(" (‚äï)")]),e._v(" "),a("p",[e._v("TA->B‚äïTB->C ‚áí TA->C")]),e._v(" "),a("p",[e._v("composition forms a ‚Äúchain‚Äù, going from frame A to frame B to frame C.")]),e._v(" "),a("p",[e._v("Note that composition (‚äï) is a "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Transitive_relation",target:"_blank",rel:"noopener noreferrer"}},[e._v("transitive relation"),a("OutboundLink")],1),e._v(" -- the output frame of the first must match the input frame of the second, otherwise the composition is invalid:")]),e._v(" "),a("p",[e._v("Composition is Transitive")]),e._v(" "),a("p",[e._v("TA->B‚äïTB->C")]),e._v(" "),a("p",[e._v("Valid (output Frame B matches input Frame B)")]),e._v(" "),a("p",[e._v("TA->B‚äïTC->B")]),e._v(" "),a("p",[e._v("Invalid (output Frame B mismatches input Frame C)")]),e._v(" "),a("p",[e._v("TA->B‚äïTC->B-1 ‚áí TA->B‚äïTB->C")]),e._v(" "),a("p",[e._v("Valid (inversion swaps the input and output Frame)")]),e._v(" "),a("p",[e._v("I‚Äôm using the mysterious symbol for composition because it is a conceptual operation, and the calculation is not important right now. For instance, something like the multiply or addition operator might seem attractive to use instead, but could be misleading. For instance, two matrices are indeed composited using multiplication, but two translation vectors are composited using addition. However, they are both conceptually a composition of two transformations. I want to convey the concept of composition without focusing on the specific math required to achieve it, which is more tied to the representation used for the transform. I‚Äôll discuss this more in the next post.")]),e._v(" "),a("p",[e._v("Let‚Äôs go back to our rigid body tank example and express some transformations using this new calculus:")]),e._v(" "),a("p",[e._v("Tgun->world = Tgun->turret‚äïTturret->chassis‚äïTchassis->world")]),e._v(" "),a("p",[e._v("Tgun->wheel1 = Tgun->turret‚äïTturret->chassis‚äïTwheel1->chassis-1")]),e._v(" "),a("p",[e._v("This is makes logical sense: to determine the transformation from the gun‚Äôs frame of reference to the world‚Äôs, chain the gun-to-turret transform to the turret-to-chassis transform to the chassis-to-world transform. Each step moves UP the hierarchy to the root. Note in the second example how we use the inverse to go back DOWN the hierarchy to get to the lower wheel1 node, preserving the transitive chain of operations.")]),e._v(" "),a("h2",{attrs:{id:"transforming-vectors-and-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transforming-vectors-and-points"}},[e._v("#")]),e._v(" Transforming Vectors and Points")]),e._v(" "),a("p",[e._v("As discussed, a transformation is a mapping function over the vector space. But we use points to describe geometry. So what‚Äôs the difference between a vector and a point? Well, a point is a distinct location in space, while a vector is a displacement between two points (like a vertex normal). Luckily, both points AND vectors can be represented using "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Homogeneous_coordinates",target:"_blank",rel:"noopener noreferrer"}},[e._v("homogeneous coordinates"),a("OutboundLink")],1),e._v(", the former with a homogeneous coordinate of 1, and the latter with a 0[4]. By thinking of our transforms as operating on "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Affine_space",target:"_blank",rel:"noopener noreferrer"}},[e._v("affine spaces"),a("OutboundLink")],1),e._v(" using homogeneous coordinates, we can transform points and vectors the same way:")]),e._v(" "),a("p",[e._v("TA->B(P) ‚áí Transformation of homogeneous point P from frame A to frame B")]),e._v(" "),a("p",[e._v("TA->B(V) ‚áí Transformation of homogeneous vector V from frame A to frame B")]),e._v(" "),a("h2",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),a("p",[e._v("We have outlined a formal notation, or calculus, for expressing a rigid body hierarchy as a tree of coordinate transformations taking us from the frame of reference of a child node to its parent. We can composite and invert these transformations using a logical notation that allows us to reason about any node from the perspective of any other node, regardless of how that transform is represented. Finally, we can apply these transformations to a set of vectors or points to reason about specific geometry associated with those nodes. This is something Slate has to do all the time.")]),e._v(" "),a("p",[e._v("In the next post I‚Äôll discuss how these operations are actually implemented using several transformation representations available in UE4 and demonstrate how the calculus allows us to simplify real-world code by expressing the concept rather than focusing on the math itself.")]),e._v(" "),a("p",[a("a",{attrs:{href:"/UE4_Transform_Calculus_-_Part_2",title:"UE4 Transform Calculus - Part 2"}},[e._v("Continue to Part 2 >")])]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"footnotes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#footnotes"}},[e._v("#")]),e._v(" Footnotes")]),e._v(" "),a("p",[e._v("1I‚Äôm applying symbols for particular operations/semantics, so I guess it‚Äôs technically a "),a("a",{attrs:{href:"http://www.encyclopediaofmath.org/index.php/Logical_calculus",target:"_blank",rel:"noopener noreferrer"}},[e._v("logico-mathematical calculus"),a("OutboundLink")],1),e._v(", but who really cares?")]),e._v(" "),a("p",[e._v("2 Technically, it‚Äôs an "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Affine_space",target:"_blank",rel:"noopener noreferrer"}},[e._v("affine space"),a("OutboundLink")],1),e._v(" as we also need an offset to place the basis at a point in space, but the mathematical properties we are concerned with are equivalent, as affine spaces are in fact "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Linear_subspace",target:"_blank",rel:"noopener noreferrer"}},[e._v("vector subspaces"),a("OutboundLink")],1),e._v(". However, studying vector bases leads us more directly to the properties we want to consider.")]),e._v(" "),a("p",[e._v("3This is known as composition of "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Linear_map",target:"_blank",rel:"noopener noreferrer"}},[e._v("linear transformations"),a("OutboundLink")],1),e._v(", which form what is called an "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Associative_algebra",target:"_blank",rel:"noopener noreferrer"}},[e._v("associative algebra"),a("OutboundLink")],1),e._v(". This algebra gives us many useful properties like "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Associative_property",target:"_blank",rel:"noopener noreferrer"}},[e._v("associativity"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"http://en.wikipedia.org/wiki/Distributive_property",target:"_blank",rel:"noopener noreferrer"}},[e._v("distributivity"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("4This "),a("a",{attrs:{href:"http://math.stackexchange.com/questions/89621/how-to-multiply-vector-3-with-4by4-matrix-more-precisely-position-transformat",target:"_blank",rel:"noopener noreferrer"}},[e._v("StackExchange link"),a("OutboundLink")],1),e._v(" gives a good technical explanation without getting too mathy..")]),e._v(" "),a("p",[e._v('Retrieved from "'),a("a",{attrs:{href:"https://wiki.unrealengine.com/index.php?title=UE4_Transform_Calculus_-_Part_1&oldid=14360",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://wiki.unrealengine.com/index.php?title=UE4_Transform_Calculus_-_Part_1&oldid=14360"),a("OutboundLink")],1),e._v('"')]),e._v(" "),a("p",[a("a",{attrs:{href:"/Special:Categories",title:"Special:Categories"}},[e._v("Category")]),e._v(":")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"/Category:Epic_Created_Content",title:"Category:Epic Created Content"}},[e._v("Epic Created Content")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://tracking.unrealengine.com/track.png",alt:""}})])])}),[],!1,null,null,null);t.default=o.exports}}]);