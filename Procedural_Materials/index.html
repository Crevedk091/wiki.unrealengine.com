<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>wiki.unrealengine.com</title>
    <meta name="description" content="A static site pulled from the internet archive">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css" as="style"><link rel="preload" href="/wiki.unrealengine.com/assets/js/app.aaf63946.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/2.4f53495e.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/925.29374d17.js" as="script">
    <link rel="stylesheet" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki.unrealengine.com/" class="home-link router-link-active"><!----> <span class="site-name">wiki.unrealengine.com</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Procedural Materials - Epic Wiki</p> <h1 id="procedural-materials"><a href="#procedural-materials" class="header-anchor">#</a> Procedural Materials</h1> <p>From Epic Wiki</p> <p>Jump to: <a href="#mw-head">navigation</a>, <a href="#p-search">search</a></p> <h1 id="goal-of-this-article"><a href="#goal-of-this-article" class="header-anchor">#</a> Goal of this article</h1> <p>With this article you will learn how to make and use of dynamic materials to create procedurally generated texture that during runtime is writable and readable in C++. This article will be catered to C++ programmers, and currently there is no support for blueprints.</p> <h2 id="contents"><a href="#contents" class="header-anchor">#</a> Contents</h2> <ul><li><a href="#Goal_of_this_article">1 Goal of this article</a></li> <li><a href="#Setup">2 Setup</a> <ul><li><a href="#What_you_will_need">2.1 What you will need</a></li> <li><a href="#Texture_Setup">2.2 Texture Setup</a> <ul><li><a href="#Motivation">2.2.1 Motivation</a></li></ul></li> <li><a href="#Material_Setup">2.3 Material Setup</a> <ul><li><a href="#Motivation_2">2.3.1 Motivation</a></li></ul></li> <li><a href="#Enqueue_Render_Task">2.4 Enqueue Render Task</a> <ul><li><a href="#Explanation">2.4.1 Explanation</a></li></ul></li> <li><a href="#Dynamic_Texture_.26_Dynamic_Material">2.5 Dynamic Texture &amp; Dynamic Material</a></li> <li><a href="#Manipulating_the_texture">2.6 Manipulating the texture</a></li> <li><a href="#Implemenations">2.7 Implemenations</a></li> <li><a href="#Complete_example">2.8 Complete example</a></li></ul></li></ul> <h1 id="setup"><a href="#setup" class="header-anchor">#</a> Setup</h1> <h2 id="what-you-will-need"><a href="#what-you-will-need" class="header-anchor">#</a> What you will need</h2> <ul><li>A texture that with the following properties: (<em>Editor</em>)
<ul><li>No compression (B8G8R8A8) <em>making it humanly readable and writable</em>.</li> <li>No mipmaps</li> <li>No sRGB applied</li></ul></li> <li>A material with a Texture Sample 2D parameter (<em>Editor</em>)</li> <li>A function for enqueueing tasks on the render thread. (<em>C++</em>)</li> <li>Create the dynamic texture and link it with the dynamic material (<em>C++</em>)</li> <li>Manipulate the texture (<em>C++</em>)</li></ul> <h2 id="texture-setup"><a href="#texture-setup" class="header-anchor">#</a> Texture Setup</h2> <p><a href="/index.php?title=File:DynamicTexture.JPG"><img src="https://d3ar1piqh1oeli.cloudfront.net/5/5a/DynamicTexture.JPG/300px-DynamicTexture.JPG" alt=""></a></p> <p>Image</p> <p>First you will need to import a texture with your desired dimensions. In its' settings change the following:</p> <ul><li>Mip Gen Settings -&gt; <strong>NoMipmaps</strong></li> <li>sRGB -&gt; <strong>false</strong></li> <li>Compression Settings -&gt; <strong>TC Vector Displacementmap</strong></li></ul> <h3 id="motivation"><a href="#motivation" class="header-anchor">#</a> Motivation</h3> <p>Unreal4 auto-compresses the textures when imported. They usually default to DXT5 which is not appropriate for us to edit. It skews the data and we're unable to get predictable results and values from the texture. By setting the Compression Settings to <strong>TC Vector Displacementmap</strong> we are guaranteed no compression.<br>
We are setting the Gamma (sRGB) to false because it also skews the data. Gamma is useful for expanding the color palette in the region we humans are able to detect change. But since we're going to edit the texture it will obscure the pixel values which will make it harder for us to establish a proper prediction and estimation when working with the texture.<br>
By setting the Mip Gen Settings to <strong>NoMipmaps</strong> we tell the engine that we are not going to be needing any mipmaps of our texture. This is to prevent bugs when the engine tries to downscale the texture (which we will dynamically write to and read from).</p> <h2 id="material-setup"><a href="#material-setup" class="header-anchor">#</a> Material Setup</h2> <p><a href="/index.php?title=File:DynamicTextureParam.JPG"><img src="https://d3ar1piqh1oeli.cloudfront.net/d/d7/DynamicTextureParam.JPG/300px-DynamicTextureParam.JPG" alt="DynamicTextureParam.JPG"></a></p> <ul><li>Create a Texture Sample Parameter 2D node in the material</li> <li>Change the <em>Sampler Type</em> to <strong>Linear Color</strong></li> <li>Change the <em>Parameter Name</em> to <strong>DynamicTextureParam</strong> (or whatever name you set in SetTextureParameterValue())</li></ul> <h3 id="motivation-2"><a href="#motivation-2" class="header-anchor">#</a> Motivation</h3> <p>The material setup can be as advanced as you wish, all you're going to need to keep in mind is that the texture from the dynamic parameter will be just that; dynamic. The picture illustrates how a simple setup may look (Use the colors of the dynamic texture and sample them with TexCoords). Something to keep in mind: If you don't set the <em>Sampler Type</em> to <strong>Linear Color</strong> you will encounter an error prompting you to change it accordingly. Later you will write to this parameter through C++.</p> <h2 id="enqueue-render-task"><a href="#enqueue-render-task" class="header-anchor">#</a> Enqueue Render Task</h2> <p><syntaxhighlight lang="cpp">void UpdateTextureRegions(UTexture2D* Texture, int32 MipIndex, uint32 NumRegions, FUpdateTextureRegion2D* Regions, uint32 SrcPitch, uint32 SrcBpp, uint8* SrcData, bool bFreeData) { if (Texture &amp;&amp; Texture-&gt;Resource) { struct FUpdateTextureRegionsData { FTexture2DResource* Texture2DResource; int32 MipIndex; uint32 NumRegions; FUpdateTextureRegion2D* Regions; uint32 SrcPitch; uint32 SrcBpp; uint8* SrcData; };</syntaxhighlight></p> <p>FUpdateTextureRegionsData* RegionData = new FUpdateTextureRegionsData;</p> <p>RegionData-&gt;Texture2DResource = (FTexture2DResource*)Texture-&gt;Resource; RegionData-&gt;MipIndex = MipIndex; RegionData-&gt;NumRegions = NumRegions; RegionData-&gt;Regions = Regions; RegionData-&gt;SrcPitch = SrcPitch; RegionData-&gt;SrcBpp = SrcBpp; RegionData-&gt;SrcData = SrcData;</p> <p>ENQUEUE_UNIQUE_RENDER_COMMAND_TWOPARAMETER( UpdateTextureRegionsData, FUpdateTextureRegionsData*, RegionData, RegionData, bool, bFreeData, bFreeData, { for (uint32 RegionIndex = 0; RegionIndex &lt; RegionData-&gt;NumRegions; ++RegionIndex) { int32 CurrentFirstMip = RegionData-&gt;Texture2DResource-&gt;GetCurrentFirstMip(); if (RegionData-&gt;MipIndex &gt;= CurrentFirstMip) { RHIUpdateTexture2D( RegionData-&gt;Texture2DResource-&gt;GetTexture2DRHI(), RegionData-&gt;MipIndex - CurrentFirstMip, RegionData-&gt;Regions[RegionIndex], RegionData-&gt;SrcPitch, RegionData-&gt;SrcData + RegionData-&gt;Regions[RegionIndex].SrcY * RegionData-&gt;SrcPitch + RegionData-&gt;Regions[RegionIndex].SrcX * RegionData-&gt;SrcBpp ); } } if (bFreeData) { FMemory::Free(RegionData-&gt;Regions); FMemory::Free(RegionData-&gt;SrcData); } delete RegionData; }); } }</p> <h3 id="explanation"><a href="#explanation" class="header-anchor">#</a> Explanation</h3> <p>This function is a straight copy-paste from <a href="/index.php?title=Dynamic_Textures" title="Dynamic Textures">here</a>, which is where you can read some more about it if you wish to know the ins- and outs of how it works and what it does.</p> <h2 id="dynamic-texture-dynamic-material"><a href="#dynamic-texture-dynamic-material" class="header-anchor">#</a> Dynamic Texture &amp; Dynamic Material</h2> <p>It does not matter where you do this; as long as it is only done once. A good start-off point would be to have this code in <strong>PostInitializeComponents()</strong>.</p> <p><syntaxhighlight lang="cpp"> //Convert the static material in our mesh into a dynamic one, and store it (please note that if you have more than one material that you wish to mark dynamic, do so here). mDynamicMaterials.Add(StaticMeshComponent-&gt;CreateAndSetMaterialInstanceDynamic(0)); //Create a dynamic texture with the default compression (B8G8R8A8) mDynamicTexture = UTexture2D::CreateTransient(w, h); //Make sure it won't be compressed mDynamicTexture-&gt;CompressionSettings = TextureCompressionSettings::TC_VectorDisplacementmap; //Turn off Gamma-correction mDynamicTexture-&gt;SRGB = 0; //Guarantee no garbage collection by adding it as a root reference mDynamicTexture-&gt;AddToRoot(); //Update the texture with new variable values. mDynamicTexture-&gt;UpdateResource(); //Grab the colorvalues from our existing texture (the one we created at <strong>Texture Setup</strong>) and copy it into a uint8* mTextureColors variable. int32 w, h; w = textureToReadFrom-&gt;GetSizeX(); h = textureToReadFrom-&gt;GetSizeY(); FTexture2DMipMap&amp; readMip = textureToReadFrom-&gt;PlatformData-&gt;Mips[0]; mDataSize = w * h * 4; // * 4 because we're working with uint8's - which are 4 bytes large mDataSqrtSize = w * 4; // * 4 because we're working with uint8's - which are 4 bytes large readMip.BulkData.GetCopy((void**)&amp;mTextureColors); // Initalize our dynamic pixel array with data size mDynamicColors = new uint8[mDataSize]; // Copy our current texture's colors into our dynamic colors FMemory::Memcpy(mDynamicColors, mTextureColors, mDataSize); // Create a new texture region with the width and height of our dynamic texture mUpdateTextureRegion = new FUpdateTextureRegion2D(0, 0, 0, 0, w, h); // Set the Paramater in our material to our texture mDynamicMaterials[0]-&gt;SetTextureParameterValue(&quot;DynamicTextureParam&quot;, mDynamicTexture); </syntaxhighlight></p> <p>And the setup is complete. We now have three things:</p> <ul><li>An array of uint8's which acts as a copy of our static texture</li> <li>A dynamic texture which is read/write enabled</li> <li>A dynamic material which is read/write enabled</li></ul> <h2 id="manipulating-the-texture"><a href="#manipulating-the-texture" class="header-anchor">#</a> Manipulating the texture</h2> <p>This is the final piece of the puzzle, which also happens to be the easiest. All you need to do now is to manipulate the array of mDynamicColors and set the individual color values. Worth noting; the entire array exists of BGRA-values, which means that every fourth index is the color B for the current pixel. Here's a small example: <syntaxhighlight lang="cpp"> mDynamicColors[0] = 255; // Set the Blue channel in pixel nr. 0 to 255 mDynamicColors[1] = 120; // Set the Green channel in pixel nr. 0 to 120 mDynamicColors[2] = 120; // Set the Red channel in pixel nr. 0 to 120 mDynamicColors[3] = 120; // Set the Alpha channel in pixel nr. 0 to 120 mDynamicColors[4] = 120; // Set the Blue channel in pixel nr. 1 to 120 // etc etc // Array example: int pixelAmount = mDataSize / 4; for (int i = 0; i &lt; pixelAmount; ++i) { int blue = i * 4 + 0; int green = i * 4 + 1; int red = i * 4 + 2; int alpha = i * 4 + 3; mDynamicColors[red] = 120; // Set pixel's red value to 120 } </syntaxhighlight> And now writing the newly set pixels to our texture: <syntaxhighlight lang="cpp"> void AYourSpecificActor::Tick(float DeltaTime) { Super::Tick(DeltaTime); UpdateTextureRegions(mDynamicTexture, 0, 1, mUpdateTextureRegion, mDataSqrtSize, (uint32)4, mDynamicColors, false); mDynamicMaterials[0]-&gt;SetTextureParameterValue(&quot;DynamicTextureParam&quot;, mDynamicTexture); } </syntaxhighlight></p> <h2 id="implemenations"><a href="#implemenations" class="header-anchor">#</a> Implemenations</h2> <p><a href="https://gist.github.com/makuto/bf87e5ccd0b15b0859608c9b745ac5f1" target="_blank" rel="noopener noreferrer">Simple Dynamic Texture Implementation (Public Domain)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="complete-example"><a href="#complete-example" class="header-anchor">#</a> Complete example</h2> <p>This code is a snippet from our own game. It should be pretty straight forward what it does. Please note that this is copyrighted.</p> <p>The .h file <syntaxhighlight lang="cpp"></syntaxhighlight></p> <ol><li><p>pragma once</p></li> <li><p>include &quot;GameFramework/Actor.h&quot;</p></li> <li><p>include &quot;WLavaActor.generated.h&quot;</p></li></ol> <p>/**</p> <p>*
*/</p> <p>UCLASS() class SPELLSWORN_API AWLavaActor : public AStaticMeshActor { GENERATED_UCLASS_BODY()</p> <p>virtual void BeginPlay() override; virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override; virtual void PostInitializeComponents() override; virtual void Tick(float DeltaTime) override; void PropagateLava(); int GetLavaValue(const FVector&amp; aWorldPosition) const;</p> <p>void SetMeltRateDivisor(float aDivisor) { mMeltRateDivisor = aDivisor; } float GetDynamicMeltRate() const { return mMeltRate + mMeltRate * mMeltRateDivisor * .2f; }</p> <p>int32 GetRowSize() const { return mRowSize; } int32 GetCellSize() const { return mCellSize; } UFUNCTION() void BeginPropagateLava(); UFUNCTION() void EndPropagateLava(); void UpdateLava();</p> <p>UFUNCTION() void ResetColors();</p> <p>private: FTimerHandle mTimerHandle_PropagateLava;</p> <p>UPROPERTY(EditAnywhere, Category = &quot;TextureToArray&quot;) class UWTextureToArray* LavaPixelArray; TArray<uint8>* ExportedLavaValues;</uint8></p> <p>UPROPERTY(EditAnywhere, Category = &quot;WLavaActor&quot;) float mMeltRate; UPROPERTY(EditAnywhere, Category = &quot;WLavaActor&quot;) uint8 mMeltWhenNeighborIsBelow; UPROPERTY(EditAnywhere, Category = &quot;WLavaActor&quot;) float mMeltValue;</p> <p>int32 mCellSize; int32 mRowSize; int32 mArraySize; TArray<int32> mArrayOfIndexes;</int32></p> <p>TArray&lt;class UMaterialInstanceDynamic*&gt; mDynamicMaterials; UPROPERTY() UTexture2D *mDynamicTexture; FUpdateTextureRegion2D* mUpdateTextureRegion; uint8* mDynamicColors; float* mDynamicColorsFloat; uint32 mDataSize; uint32 mDataSqrtSize;</p> <p>UPROPERTY(ReplicatedUsing=OnRep_CurrentMeltTime) float mCurrentMeltTime; float mPreviousMeltTime; float mMeltRateDivisor;</p> <p>UFUNCTION() void OnRep_CurrentMeltTime();</p> <p>UPROPERTY(Replicated) bool bPropagating; float mPropagateTime;</p> <p>}; </p> <p>The .cpp file <syntaxhighlight lang="cpp"></syntaxhighlight></p> <ol><li><p>include &quot;Spellsworn.h&quot;</p></li> <li><p>include &quot;WLavaActor.h&quot;</p></li> <li><p>include &quot;WGameState.h&quot;</p></li> <li><p>include &quot;WGameMode.h&quot;</p></li> <li><p>include &quot;StaticMeshResources.h&quot;</p></li> <li><p>include &quot;Misc/TextureToArray/WTextureToArray.h&quot;</p></li> <li><p>define RED 2</p></li> <li><p>define GREEN 1</p></li> <li><p>define BLUE 0</p></li> <li><p>define ALPHA 3</p></li> <li><p>define ALPHA_CHECK 200</p></li></ol> <p>void UpdateTextureRegions(UTexture2D* Texture, int32 MipIndex, uint32 NumRegions, FUpdateTextureRegion2D* Regions, uint32 SrcPitch, uint32 SrcBpp, uint8* SrcData, bool bFreeData) { if (Texture &amp;&amp; Texture-&gt;Resource) { struct FUpdateTextureRegionsData { FTexture2DResource* Texture2DResource; int32 MipIndex; uint32 NumRegions; FUpdateTextureRegion2D* Regions; uint32 SrcPitch; uint32 SrcBpp; uint8* SrcData; };</p> <p>FUpdateTextureRegionsData* RegionData = new FUpdateTextureRegionsData;</p> <p>RegionData-&gt;Texture2DResource = (FTexture2DResource*)Texture-&gt;Resource; RegionData-&gt;MipIndex = MipIndex; RegionData-&gt;NumRegions = NumRegions; RegionData-&gt;Regions = Regions; RegionData-&gt;SrcPitch = SrcPitch; RegionData-&gt;SrcBpp = SrcBpp; RegionData-&gt;SrcData = SrcData;</p> <p>ENQUEUE_UNIQUE_RENDER_COMMAND_TWOPARAMETER( UpdateTextureRegionsData, FUpdateTextureRegionsData*, RegionData, RegionData, bool, bFreeData, bFreeData, { for (uint32 RegionIndex = 0; RegionIndex &lt; RegionData-&gt;NumRegions; ++RegionIndex) { int32 CurrentFirstMip = RegionData-&gt;Texture2DResource-&gt;GetCurrentFirstMip(); if (RegionData-&gt;MipIndex &gt;= CurrentFirstMip) { RHIUpdateTexture2D( RegionData-&gt;Texture2DResource-&gt;GetTexture2DRHI(), RegionData-&gt;MipIndex - CurrentFirstMip, RegionData-&gt;Regions[RegionIndex], RegionData-&gt;SrcPitch, RegionData-&gt;SrcData + RegionData-&gt;Regions[RegionIndex].SrcY * RegionData-&gt;SrcPitch + RegionData-&gt;Regions[RegionIndex].SrcX * RegionData-&gt;SrcBpp ); } } if (bFreeData) { FMemory::Free(RegionData-&gt;Regions); FMemory::Free(RegionData-&gt;SrcData); } delete RegionData; }); } }</p> <p>AWLavaActor::AWLavaActor(const class FObjectInitializer&amp; PCIP) : Super(PCIP) { PrimaryActorTick.bCanEverTick = true; mMeltRate = 0.05f; mMeltWhenNeighborIsBelow = 127; mMeltRateDivisor = 0.0f; SetReplicates(true); bPropagating = false; mDynamicColors = nullptr; mDynamicColorsFloat = nullptr; mUpdateTextureRegion = nullptr; }</p> <p>void AWLavaActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>&amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps);</FLifetimeProperty></p> <p>DOREPLIFETIME(AWLavaActor, mCurrentMeltTime); DOREPLIFETIME(AWLavaActor, bPropagating); }</p> <p>void AWLavaActor::BeginPlay() { Super::BeginPlay();</p> <p>UWorld* world = GetWorld(); if (world) { AWGameState* gameState = world-&gt;GetGameState<AWGameState>(); if (gameState) { gameState-&gt;mRestartRoundDelegate.RemoveAll(this); gameState-&gt;mRestartRoundDelegate.AddUObject(this, &amp;AWLavaActor::BeginPropagateLava); gameState-&gt;mStartShopDelegate.RemoveAll(this); gameState-&gt;mStartShopDelegate.AddUObject(this, &amp;AWLavaActor::EndPropagateLava); } } }</AWGameState></p> <p>void AWLavaActor::OnRep_CurrentMeltTime() { if (mCurrentMeltTime - mPreviousMeltTime &gt; 2.f) { //GetWorld()-&gt;GetTimerManager().ClearTimer(mTimerHandle_PropagateLava); //GetWorld()-&gt;GetTimerManager().SetTimer(mTimerHandle_PropagateLava, this, &amp;AWLavaActor::PropagateLava, GetDynamicMeltRate(), false);</p> <p>int timesToPropagate = (mCurrentMeltTime - mPreviousMeltTime) / mMeltRate; for (int i = 0; i &lt; timesToPropagate; ++i) { PropagateLava(); } } }</p> <p>void AWLavaActor::EndPlay(const EEndPlayReason::Type EndPlayReason) { //PRINT(&quot;Destroying lava actor&quot;); UWorld* world = GetWorld(); if (world) { AWGameState* gameState = world-&gt;GetGameState<AWGameState>(); if (gameState) { gameState-&gt;mRestartRoundDelegate.RemoveAll(this); gameState-&gt;mStartShopDelegate.RemoveAll(this); } } delete[] mDynamicColors; mDynamicColors = nullptr; delete[] mDynamicColorsFloat; mDynamicColorsFloat = nullptr; delete mUpdateTextureRegion; mUpdateTextureRegion = nullptr; Super::EndPlay(EndPlayReason); }</AWGameState></p> <p>void AWLavaActor::PostInitializeComponents() { Super::PostInitializeComponents(); if (mDynamicColors) delete[] mDynamicColors; if (mDynamicColorsFloat) delete[] mDynamicColorsFloat; if (mUpdateTextureRegion) delete mUpdateTextureRegion; if (!LavaPixelArray) return;</p> <p>ExportedLavaValues = LavaPixelArray-&gt;GetArray(); int32 w, h; w = FMath::Sqrt(ExportedLavaValues-&gt;Num() / 4); h = w;</p> <p>if (!IsRunningDedicatedServer()) { mDynamicMaterials.Empty(); mDynamicMaterials.Add(GetStaticMeshComponent()-&gt;CreateAndSetMaterialInstanceDynamic(0)); mDynamicTexture = UTexture2D::CreateTransient(w, h); mDynamicTexture-&gt;CompressionSettings = TextureCompressionSettings::TC_VectorDisplacementmap; mDynamicTexture-&gt;SRGB = 0; mDynamicTexture-&gt;AddToRoot(); mDynamicTexture-&gt;UpdateResource();</p> <p>mUpdateTextureRegion = new FUpdateTextureRegion2D(0, 0, 0, 0, w, h);</p> <p>mDynamicMaterials[0]-&gt;SetTextureParameterValue(&quot;DynamicTextureParam&quot;, mDynamicTexture); } mDataSize = w * h * 4; mDataSqrtSize = w * 4; mArraySize = w * h; mRowSize = w; mDynamicColors = new uint8[mDataSize]; mDynamicColorsFloat = new float[mArraySize];</p> <p>ResetColors(); }</p> <p>void AWLavaActor::BeginPropagateLava() { bPropagating = true; mPropagateTime = 0; mCurrentMeltTime = mPreviousMeltTime = 0.0f; //GetWorld()-&gt;GetTimerManager().ClearTimer(mTimerHandle_PropagateLava); //GetWorld()-&gt;GetTimerManager().SetTimer(mTimerHandle_PropagateLava, this, &amp;AWLavaActor::PropagateLava, GetDynamicMeltRate(), false); ResetColors(); }</p> <p>void AWLavaActor::EndPropagateLava() { bPropagating = false; mPropagateTime = 0; mCurrentMeltTime = mPreviousMeltTime = 0.0f; //GetWorld()-&gt;GetTimerManager().ClearTimer(mTimerHandle_PropagateLava); ResetColors(); }</p> <p>void AWLavaActor::ResetColors() { mArrayOfIndexes.Empty(); FMemory::Memcpy(mDynamicColors, ExportedLavaValues-&gt;GetData(), mDataSize);</p> <p>for (int i = 0; i &lt; mArraySize; ++i) { mDynamicColorsFloat[i] = static_cast<float>(mDynamicColors[i * 4 + RED]); if (mDynamicColors[i * 4 + RED] &gt; mDynamicColors[i * 4 + BLUE]) mArrayOfIndexes.Add(i); }</float></p> <p>UpdateLava(); }</p> <p>int AWLavaActor::GetLavaValue(const FVector&amp; aWorldPosition) const { if (!mDynamicColors) return 0; FVector origin; FVector bounds; GetActorBounds(false, origin, bounds); FVector corner = origin - bounds; FVector relativePosition = aWorldPosition - corner; float cellSize = (bounds.X*2) / FMath::Max<float>(1.f, mRowSize); int32 cellX = FMath::Clamp(FMath::RoundToInt(relativePosition.X / FMath::Max(1.f, cellSize)), 0, mRowSize); int32 cellY = FMath::Clamp(FMath::RoundToInt(relativePosition.Y / FMath::Max(1.f, cellSize)), 0, mRowSize); int32 cellIndex = FMath::Clamp<int32>(cellX + mRowSize * cellY, 0, mArraySize - 1); uint8 value = FMath::Max<uint8>(mDynamicColors[cellIndex * 4 + RED], mDynamicColors[cellIndex * 4 + BLUE]); if(mDynamicColors[cellIndex * 4 + ALPHA] &lt; ALPHA_CHECK) return 0;</uint8></int32></float></p> <p>return value; }</p> <p>void AWLavaActor::PropagateLava() { mPreviousMeltTime = mCurrentMeltTime; mCurrentMeltTime += mMeltRate;</p> <p>//GetWorld()-&gt;GetTimerManager().ClearTimer(mTimerHandle_PropagateLava); //GetWorld()-&gt;GetTimerManager().SetTimer(mTimerHandle_PropagateLava, this, &amp;AWLavaActor::PropagateLava, GetDynamicMeltRate(), false);</p> <p>struct Neighbor { Neighbor(int indx, float v) :index(indx), val(v){} int index; float val; }; for (int32 i = 0; i &lt; mArrayOfIndexes.Num(); ++i) { int index = mArrayOfIndexes[i]; int colorIndex = index * 4; uint8 colorValue = mDynamicColors[colorIndex + RED]; if (colorValue &lt;= mDynamicColors[colorIndex + BLUE] || mDynamicColors[colorIndex + ALPHA] &lt; ALPHA_CHECK) { mArrayOfIndexes.RemoveAt(i--); continue; }</p> <p>int x = index % mRowSize; int y = FMath::FloorToInt(index / mRowSize); Neighbor neighbors[12] = { Neighbor((mRowSize * (y - 1) + (x - 0)) * 4, 1.00f), // Below Neighbor((mRowSize * (y - 1) + (x - 1)) * 4, 0.75f), // Below Left Neighbor((mRowSize * (y - 0) + (x - 1)) * 4, 1.00f), // Left Neighbor((mRowSize * (y + 1) + (x - 1)) * 4, 0.75f), // Above Left Neighbor((mRowSize * (y + 1) + (x + 0)) * 4, 1.00f), // Above Neighbor((mRowSize * (y + 1) + (x + 1)) * 4, 0.75f), // Above Right Neighbor((mRowSize * (y - 0) + (x + 1)) * 4, 1.00f), // Right Neighbor((mRowSize * (y - 1) + (x - 0)) * 4, 0.75f), // Below right Neighbor((mRowSize * (y - 2) + (x - 0)) * 4, 0.50f), // Below * 2 Neighbor((mRowSize * (y - 0) + (x - 2)) * 4, 0.50f), // Left * 2 Neighbor((mRowSize * (y + 2) + (x - 0)) * 4, 0.50f), // Above * 2 Neighbor((mRowSize * (y + 0) + (x + 2)) * 4, 0.50f), // Right * 2 };</p> <p>for (uint8 n = 0; n &lt; 12; ++n) { if (n &gt;= 0 &amp;&amp; n &lt; mDataSize) { colorValue = mDynamicColors[colorIndex + RED]; if (colorValue &lt;= 0) break;</p> <p>int rVal = mDynamicColors[neighbors[n].index + RED]; if (rVal &lt; mMeltWhenNeighborIsBelow) { float propVal = mMeltValue * neighbors[n].val/* * (mDynamicColorsFloat[index] / 255.f)*/; mDynamicColorsFloat[index] -= propVal; mDynamicColorsFloat[index] = FMath::Max<float>(mDynamicColorsFloat[index], 0.f); mDynamicColors[colorIndex + RED] = static_cast<uint8>(FMath::FloorToInt(mDynamicColorsFloat[index])); } } } }</uint8></float></p> <p>UpdateLava(); }</p> <p>void AWLavaActor::Tick(float DeltaTime) { Super::Tick(DeltaTime);</p> <p>if(bPropagating) { mPropagateTime += DeltaTime; float dynamicMeltRate = GetDynamicMeltRate(); while(mPropagateTime &gt;= dynamicMeltRate) { mPropagateTime -= dynamicMeltRate; PropagateLava(); } } }</p> <p>void AWLavaActor::UpdateLava() { if (!IsRunningDedicatedServer()) { UpdateTextureRegions(mDynamicTexture, 0, 1, mUpdateTextureRegion, mDataSqrtSize, (uint32)4, mDynamicColors, false); mDynamicMaterials[0]-&gt;SetTextureParameterValue(&quot;DynamicTextureParam&quot;, mDynamicTexture); } } </p> <p>Retrieved from &quot;<a href="https://wiki.unrealengine.com/index.php?title=Procedural_Materials&amp;oldid=379" target="_blank" rel="noopener noreferrer">https://wiki.unrealengine.com/index.php?title=Procedural_Materials&amp;oldid=379<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&quot;</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/wiki.unrealengine.com/assets/js/app.aaf63946.js" defer></script><script src="/wiki.unrealengine.com/assets/js/2.4f53495e.js" defer></script><script src="/wiki.unrealengine.com/assets/js/925.29374d17.js" defer></script>
  </body>
</html>
