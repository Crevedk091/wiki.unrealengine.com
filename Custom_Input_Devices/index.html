<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>wiki.unrealengine.com</title>
    <meta name="description" content="A static site pulled from the internet archive">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css" as="style"><link rel="preload" href="/wiki.unrealengine.com/assets/js/app.aaf63946.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/2.4f53495e.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/428.9de256a1.js" as="script">
    <link rel="stylesheet" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki.unrealengine.com/" class="home-link router-link-active"><!----> <span class="site-name">wiki.unrealengine.com</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Custom Input Devices - Epic Wiki</p> <h1 id="custom-input-devices"><a href="#custom-input-devices" class="header-anchor">#</a> Custom Input Devices</h1> <h2 id="contents"><a href="#contents" class="header-anchor">#</a> Contents</h2> <ul><li><a href="#Overview">1 Overview</a></li> <li><a href="#Example_Code">2 Example Code</a> <ul><li><a href="#uPlugin_Ddefinition">2.1 uPlugin Ddefinition</a></li> <li><a href="#Module_Build_File">2.2 Module Build File</a></li> <li><a href="#IPlugin_Header_File">2.3 IPlugin Header File</a></li> <li><a href="#PCH_File">2.4 PCH File</a></li> <li><a href="#Plugin_Header_File">2.5 Plugin Header File</a></li> <li><a href="#Plugin_Cpp_File">2.6 Plugin Cpp File</a></li> <li><a href="#Input_Device_Header_File">2.7 Input Device Header File</a></li> <li><a href="#Input_Device_Cpp_File">2.8 Input Device Cpp File</a></li> <li><a href="#Input_Device_Cpp_File_2">2.9 Input Device Cpp File</a></li> <li><a href="#Input_Device_Cpp_File_3">2.10 Input Device Cpp File</a></li></ul></li></ul> <h2 id="overview"><a href="#overview" class="header-anchor">#</a> Overview</h2> <p>This page will detail how to create custom Input Device plugins in order to add support for additional controller/input types. It will also show example code for adding additional Key/Gamepad Input Names. The code will show how to fire events from the existing Input Names via a MessageHandler and how to fire events from any Key/Gamepad Input directly.</p> <p>The actor is a useful way of referencing the InputDevice to run arbitary methods. For some reason if the two actor classes are deleted this all fails to compile (Possibly related to *.generated.h files). If someone figures out why I would love to know (mspe044).</p> <h2 id="example-code"><a href="#example-code" class="header-anchor">#</a> Example Code</h2> <p>The code will show how to create a plugin for an input device named PsudoController which will simulate controller#1 pressing and holding the bottom face button (jump) and moving the right analog stick wildly. It will also create a new custom Gamepad Input called &quot;Psudo Player Weight&quot; and fire events for this input with a value of 75.0 (kg).</p> <p>In your own code you will most likely link your plugin with a static/dynamic library which communicates with you Input Device. When the engine calls FPsudoControllerInputDevice::SendControllerEvents() you can then pass on any events/polled controller states using the MessageHandler in a generic way.</p> <h3 id="uplugin-ddefinition"><a href="#uplugin-ddefinition" class="header-anchor">#</a> uPlugin Ddefinition</h3> <p><strong>/Plugins/PsudoController/PsudoController.uplugin</strong></p> <p>{
&quot;FileVersion&quot; : 0,
Â 
&quot;FriendlyName&quot; : &quot;Psudo Controller Plugin&quot;,
&quot;Version&quot; : 0,
&quot;VersionName&quot; : &quot;0.2&quot;,
&quot;CreatedBy&quot; : &quot;mspe044@gmail.com&quot;,
&quot;EngineVersion&quot; : 1579795,
&quot;Description&quot; : &quot;I wish I was a real input!Â ðŸ˜¢&quot;,
&quot;Category&quot; : &quot;Tutorial&quot;,
Â 
&quot;Modules&quot; :
[
{
&quot;Name&quot; : &quot;PsudoController&quot;,
&quot;Type&quot; : &quot;Runtime&quot;,
&quot;LoadingPhase&quot; : &quot;PreDefault&quot;,
&quot;WhitelistPlatforms&quot; : [ &quot;Win64&quot;, &quot;Win32&quot; ]
}
]
}</p> <h3 id="module-build-file"><a href="#module-build-file" class="header-anchor">#</a> Module Build File</h3> <p>This is where you link to any library supporting your Input Device. There is a sample method 'LoadYourThirdPartyLibraries()' to help you do this however the call to it is currently commented out.</p> <p>This method will will link to a static library in <strong>.../Plugins/PsudoController/Source/PsudoController/ThirdParty/LibraryDirName/...</strong> with include files in the sub directory <strong>.../include/</strong> and library code in subdirectoires seprated by compile arcitecture I.E. <strong>.../Win64/VS2013/MyLibrary.lib</strong></p> <p><strong>/Plugins/PsudoController/Source/PsudoController/PsudoController.Build.cs</strong></p> <p>namespace UnrealBuildTool.Rules
{
using System.IO; // ToDo: Replace with standard mechenism
Â 
public class PsudoController : ModuleRules
{
public PsudoController(TargetInfo Target)
{
PCHUsage = PCHUsageMode.NoSharedPCHs;
Â 
// ... add public include paths required here ...
PublicIncludePaths.AddRange( new string[] {
&quot;PsudoController/Public&quot;,
&quot;PsudoController/Classes&quot;,
});
Â 
// ... add other private include paths required here ...
PrivateIncludePaths.AddRange( new string[] {
&quot;PsudoController/Private&quot;,
});
Â 
// ... add other public dependencies that you statically link with here ...
PublicDependencyModuleNames.AddRange( new string[] {
&quot;Core&quot;,
&quot;CoreUObject&quot;,      // Provides Actors and Structs
&quot;Engine&quot;,           // Used by Actor
&quot;Slate&quot;,            // Used by InputDevice to fire bespoke FKey events
&quot;InputCore&quot;,        // Provides LOCTEXT and other Input features
&quot;InputDevice&quot;,      // Provides IInputInterface
});
Â 
// ... add private dependencies that you statically link with here ...
PrivateDependencyModuleNames.AddRange( new string[] {
});
Â 
// ... add any modules that your module loads dynamically here ...
DynamicallyLoadedModuleNames.AddRange( new string[] {
});
Â 
//Â !!!!!!!!!! UNCOMMENT THIS IF YOU WANT TO CALL A LIBRARYÂ !!!!!!!!!!
//LoadYourThirdPartyLibraries(Target);
}
Â 
public bool LoadYourThirdPartyLibraries(TargetInfo Target)
{
bool isLibrarySupported = false;
Â 
// This will give oyu a relitive path to the module ../PsudoController/
string ModulePath = Path.GetDirectoryName(RulesCompiler.GetModuleFilename(this.GetType().Name));
// This will give you a relative path to ../PsudoController/ThirdParty/&quot;LibraryDirName&quot;/
string MyLibraryPath = Path.Combine(ModulePath, &quot;ThirdParty&quot;, &quot;LibraryDirName&quot;);
Â 
// Use this to keep Win32/Win64/e.t.c. library files in seprate subdirectories
string ArchitecturePath = &quot;&quot;;
Â 
// When you are building for Win64
if (Target.Platform == UnrealTargetPlatform.Win64 &amp;&amp;
WindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)
{
// We will look for the library in ../PsudoController/ThirdParty/MyLibrary/Win64/VS20##/
ArchitecturePath = Path.Combine(&quot;Win64&quot;, &quot;VS&quot; + WindowsPlatform.GetVisualStudioCompilerVersionName());
Â 
isLibrarySupported = true;
}
// When you are building for Win32
else if (Target.Platform == UnrealTargetPlatform.Win32 &amp;&amp;
WindowsPlatform.Compiler == WindowsCompiler.VisualStudio2013)
{
// We will look for the library in ../PsudoController/ThirdParty/MyLibrary/Win32/VS20##/
ArchitecturePath = Path.Combine(&quot;Win32&quot;, &quot;VS&quot; + WindowsPlatform.GetVisualStudioCompilerVersionName());
Â 
isLibrarySupported = true;
}
// Add mac/linux/mobile support in much the same way
Â 
// If the current build architecture was supported by the above if statements
if (isLibrarySupported)
{
// Add the architecture spacific path to the library files
PublicAdditionalLibraries.Add(Path.Combine(MyLibraryPath, &quot;lib&quot;, ArchitecturePath, &quot;MyLibrary.lib&quot;));
// Add a more generic path to the include header files
PublicIncludePaths.Add(Path.Combine(MyLibraryPath, &quot;include&quot;));
}
Â 
// Defination lets us know whether we successfully found our library!
Definitions.Add(string.Format(&quot;WITH_MY_LIBRARY_PATH_USE={0}&quot;, isLibrarySupported ? 1 : 0));
Â 
return isLibrarySupported;
}
}
}</p> <h3 id="iplugin-header-file"><a href="#iplugin-header-file" class="header-anchor">#</a> IPlugin Header File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Public/IPsudoControllerPlugin.h</strong></p> <p>#pragma once
Â 
#include &quot;ModuleManager.h&quot;
#include &quot;IInputDeviceModule.h&quot;
Â 
#include &quot;InputCoreTypes.h&quot;
Â 
/**
* The public interface to this module.  In most cases, this interface is only public to sibling modules
* within this plugin.
*/
class IPsudoControllerPlugin : public IInputDeviceModule
{
public:
/**
* Singleton-like access to this module's interface.  This is just for convenience!
* Beware of calling this during the shutdown phase, though.  Your module might have been unloaded already.
*
* @return Returns singleton instance, loading the module on demand if needed
*/
static inline IPsudoControllerPlugin&amp; Get() {
return FModuleManager::LoadModuleChecked&lt; IPsudoControllerPlugin &gt;(&quot;PsudoController&quot;);
}
Â 
/**
* Checks to see if this module is loaded and ready.  It is only valid to call Get() if IsAvailable() returns true.
*
* @return True if the module is loaded and ready to use
*/
static inline bool IsAvailable() {
return FModuleManager::Get().IsModuleLoaded( &quot;PsudoController&quot; );
}
Â 
// This is where I declare my fancy new output type
//  - It's pretending to be a set of scales like a poor mans Wii Balance Board)
static const FKey Psudo_WeighingScales;
};</p> <h3 id="pch-file"><a href="#pch-file" class="header-anchor">#</a> PCH File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerPrivatePCH</strong></p> <p>// You should place include statements to your module's private header files here.  You only need to
// add includes for headers that are used in most of your module's source files though.
Â 
#include &quot;Core.h&quot;
#include &quot;CoreUObject.h&quot;
Â 
#include &quot;IPsudoControllerPlugin.h&quot;</p> <h3 id="plugin-header-file"><a href="#plugin-header-file" class="header-anchor">#</a> Plugin Header File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerPlugin.h</strong></p> <p>#pragma once
#include &quot;PsudoControllerPrivatePCH.h&quot;
Â 
class FPsudoControllerPlugin : public IPsudoControllerPlugin
{
public:
/** IPsudoControllerInterface implementation */
virtual TSharedPtr&lt; class IInputDevice &gt; CreateInputDevice(const TSharedRef&lt; FGenericApplicationMessageHandler &gt;&amp; InMessageHandler);
Â 
//virtual void StartupModule() OVERRIDE; // This is not required as IInputDeviceModule handels it!
virtual void ShutdownModule() OVERRIDE;
Â 
TSharedPtr&lt; class FPsudoControllerInputDevice &gt; PsudoInputDevice;
};</p> <h3 id="plugin-cpp-file"><a href="#plugin-cpp-file" class="header-anchor">#</a> Plugin Cpp File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerPlugin.cpp</strong></p> <p>#include &quot;PsudoControllerPrivatePCH.h&quot;
Â 
#include &quot;Internationalization.h&quot; // LOCTEXT
#include &quot;InputCoreTypes.h&quot;
Â 
#include &quot;PsudoControllerPlugin.h&quot;
Â 
#include &quot;Engine.h&quot; // Are these both necessary?
#include &quot;EngineUserInterfaceClasses.h&quot; // Are these both necessary?
Â 
#include &quot;IPsudoControllerPlugin.h&quot;
Â 
#include &quot;PsudoController.generated.inl&quot;
Â 
IMPLEMENT_MODULE(FPsudoControllerPlugin, PsudoController)
DEFINE_LOG_CATEGORY_STATIC(PsudoControllerPlugin, Log, All);
Â 
#define LOCTEXT_NAMESPACE &quot;InputKeys&quot;
Â 
const FKey IPsudoControllerPlugin::Psudo_WeighingScales(&quot;Psudo_WeighingScales&quot;);
Â 
// This function is called by *Application.cpp after startup to instantiate the modules InputDevice
TSharedPtr&lt; class IInputDevice &gt; FPsudoControllerPlugin::CreateInputDevice(const TSharedRef&lt; FGenericApplicationMessageHandler &gt;&amp; InMessageHandler)
{
UE_LOG(PsudoControllerPlugin, Log, TEXT(&quot;Create Input Device&quot;));
Â 
// EKey: use these sparingly... only when you need a button/axis/motion that doesn't fit any of the input names that already exist
//  - I'm defineing my poor mans Wii Balance Board, it will be called &quot;Psudo Player Weight&quot; in the editor
EKeys::AddKey(FKeyDetails(IPsudoControllerPlugin::Psudo_WeighingScales, LOCTEXT(&quot;Psudo_WeighingScales&quot;, &quot;Psudo Player Weight&quot;), FKeyDetails::Axis));
const_cast&lt;UInputSettings*&gt;(GetDefault&lt;UInputSettings&gt;())-&gt;AddAxisMapping(FInputAxisKeyMapping(&quot;PsudoWeighingScales&quot;, IPsudoControllerPlugin::Psudo_WeighingScales, 1.0F));
Â 
FPsudoControllerPlugin::PsudoInput = MakeShareable(new FPsudoControllerInputDevice(InMessageHandler));
Â 
return PsudoInput;
}
Â 
#undef LOCTEXT_NAMESPACE
Â 
// This function may be called during shutdown to clean up the module.
void FPsudoControllerPlugin::ShutdownModule()
{
FPsudoControllerPlugin::PsudoInput-&gt;~FPsudoControllerInputDevice();
Â 
UE_LOG(PsudoControllerPlugin, Log, TEXT(&quot;Shutdown Module&quot;));
}</p> <h3 id="input-device-header-file"><a href="#input-device-header-file" class="header-anchor">#</a> Input Device Header File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerInputDevice.h</strong></p> <p>#pragma once
Â 
#include &quot;IInputDevice.h&quot;
Â 
#define MAX_NUM_PSUDO_INPUT_CONTROLLERS	4 // We dont realy have any input controllers, this is a sham!Â ðŸ˜›
#define NUM_PSUDO_INPUT_BUTTONS			6 // I've only used the one button but w/evs
Â 
/**
* Type definition for shared pointers to instances of FMessageEndpoint.
*/
// ToDo: Is this necessary?
typedef TSharedPtr&lt;class FPsudoControllerInputDevice&gt; FPsudoControllerInputDevicePtr;
Â 
/**
* Type definition for shared references to instances of FMessageEndpoint.
*/
// ToDo: Is this necessary?
typedef TSharedRef&lt;class FPsudoControllerInputDevice&gt; FPsudoControllerInputDeviceRef;
Â 
/**
* Interface class for WiiInput devices (wii devices)
*/
class FPsudoControllerInputDevice : public IInputDevice
{
public:
FPsudoControllerInputDevice(const TSharedRef&lt; FGenericApplicationMessageHandler &gt;&amp; MessageHandler);
Â 
/** Tick the interface (e.g. check for new controllers) */
virtual void Tick(float DeltaTime) OVERRIDE;
Â 
/** Poll for controller state and send events if needed */
virtual void SendControllerEvents() OVERRIDE;
Â 
/** Set which MessageHandler will get the events from SendControllerEvents. */
virtual void SetMessageHandler(const TSharedRef&lt; FGenericApplicationMessageHandler &gt;&amp; InMessageHandler) OVERRIDE;
Â 
/** Exec handler to allow console commands to be passed through for debugging */
virtual bool Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice&amp; Ar) OVERRIDE;
Â 
// IForceFeedbackSystem pass through functions
virtual void SetChannelValue(int32 ControllerId, FForceFeedbackChannelType ChannelType, float Value) OVERRIDE;
virtual void SetChannelValues(int32 ControllerId, const FForceFeedbackValues &amp;values) OVERRIDE;
Â 
virtual ~FPsudoControllerInputDevice();
private:
// ToDo: Is this necessary?
bool Active;
Â 
/** Delay before sending a repeat message after a button was first pressed */
float InitialButtonRepeatDelay; // How long a button is held for before you send a 2nd event
Â 
/** Delay before sending a repeat message after a button has been pressed for a while */
float ButtonRepeatDelay; // How long a button is held for before you send a 3rd/4th/e.t.c event
Â 
EControllerButtons::Type PsudoInputButtonMapping[NUM_PSUDO_INPUT_BUTTONS];
Â 
/** Last frame's button states, so we only send events on edges */
bool PreviousButtonStates[NUM_PSUDO_INPUT_BUTTONS];
Â 
/** Next time a repeat event should be generated for each button */
double NextRepeatTime[NUM_PSUDO_INPUT_BUTTONS];
Â 
TSharedRef&lt; FGenericApplicationMessageHandler &gt; MessageHandler;
};</p> <h3 id="input-device-cpp-file"><a href="#input-device-cpp-file" class="header-anchor">#</a> Input Device Cpp File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Private/PsudoControllerInputDevice.cpp</strong></p> <p>#include &quot;PsudoControllerPrivatePCH.h&quot;
Â 
#include &quot;GenericPlatformMath.h&quot;
Â 
#include &quot;PsudoControllerInputDevice.h&quot;
Â 
#include &quot;Slate.h&quot;
Â 
#include &quot;WindowsApplication.h&quot;
#include &quot;WindowsWindow.h&quot;
#include &quot;WindowsCursor.h&quot;
#include &quot;GenericApplicationMessageHandler.h&quot;
#include &quot;IInputDeviceModule.h&quot;
#include &quot;IInputDevice.h&quot;
Â 
DEFINE_LOG_CATEGORY_STATIC(LogPsudoControllerDevice, Log, All);
Â 
FPsudoControllerInputDevice::FPsudoControllerInputDevice(const TSharedRef&lt; FGenericApplicationMessageHandler &gt;&amp; InMessageHandler) : Active(true), MessageHandler(InMessageHandler) {
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Starting PsudoControllerInputDevice&quot;));
Â 
// Initialize button repeat delays
InitialButtonRepeatDelay = 0.2f;
ButtonRepeatDelay = 0.1f;
Â 
// Setting all buttons on my psudo controllers to 'not pressed'
// (You should check the inital state of your controllers)
PreviousButtonStates[NUM_PSUDO_INPUT_BUTTONS] = { 0 };
//NextRepeatTime[NUM_PSUDO_INPUT_BUTTONS] = { 0.0 };
Â 
// Initialize mapping of controller button mask to unreal button mask
// - mapping 0-3 to the 'FaceButtons'
// --- 'X','Square','Circle','Triangle' for playstation
// --- 'A','X','B','Y' on xbox
PsudoInputButtonMapping[0] = EControllerButtons::FaceButtonTop;		// PSUDO_BUTTON_ZERO
PsudoInputButtonMapping[1] = EControllerButtons::FaceButtonBottom;	// PSUDO_BUTTON_ONE
PsudoInputButtonMapping[2] = EControllerButtons::FaceButtonLeft;	// PSUDO_BUTTON_TWO
PsudoInputButtonMapping[3] = EControllerButtons::FaceButtonRight;	// PSUDO_BUTTON_THREE
// - mapping 4-5 to the left joystick (traditionally used for movement controls)
PsudoInputButtonMapping[4] = EControllerButtons::LeftAnalogX;		// PSUDO_BUTTON_FOUR
PsudoInputButtonMapping[5] = EControllerButtons::LeftAnalogY;		// PSUDO_BUTTON_FIVE
}
Â 
void FPsudoControllerInputDevice::Tick(float DeltaTime) {
// This will spam the log heavily, comment it out for real pluginsÂ ðŸ˜ƒ
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;TickÂ %f&quot;), DeltaTime);
}
Â 
void FPsudoControllerInputDevice::SendControllerEvents() {
// Here is where we check the state of our input device proberbly by calling a method in your third party libary...
//  - I dont have a real device (xbox controller, wiimote, e.t.c.) in this tutorialÂ ðŸ˜¢ so we will just pretend!!!
Â 
// I could make libary to read from a fancy set of 'matrix' cerebellum jacks and iterate over each of those 'controllers'.. but ill save that for the next tutorial
int controllerIndex = 0; // Apparantly I was lazy so there is only one controller firing events today!
Â 
const double CurrentTime = FPlatformTime::Seconds();
const float CurrentTimeFloat = FPlatformTime::ToSeconds(FPlatformTime::Cycles()); // Works with FMath functions
Â 
// This weard statement simulates user holding down the button 1/3 of the time
if (FMath::Fmod(CurrentTimeFloat, 1.5f) &lt; .5f) {
// If the button was pressed this tick
if (!PreviousButtonStates[1]) {
// Fire button pressed event
MessageHandler-&gt;OnControllerButtonPressed(PsudoInputButtonMapping[1], controllerIndex, false);
Â 
// this button was pressed - set the button's NextRepeatTime to the InitialButtonRepeatDelay
NextRepeatTime[1] = CurrentTime + InitialButtonRepeatDelay;
PreviousButtonStates[1] = true;
// If the buttons has been held long enough to fire a nth event
} else if (NextRepeatTime[1] &lt;= CurrentTime) {
// Fire button held event
MessageHandler-&gt;OnControllerButtonPressed(PsudoInputButtonMapping[1], controllerIndex, true);
Â 
// set the button's NextRepeatTime to the ButtonRepeatDelay
NextRepeatTime[1] = CurrentTime + ButtonRepeatDelay;
}
// If the button was released this tick
}
else if (PreviousButtonStates[1]) {
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Release&quot;));
// Fire button released event
MessageHandler-&gt;OnControllerButtonReleased(PsudoInputButtonMapping[1], controllerIndex, false);
PreviousButtonStates[1] = false;
}
Â 
// This simulates the user moving the stick left and right repeatedly
float xMove = FMath::Sin(CurrentTimeFloat * .223f * 2 * PI);
// Fire analog input event
MessageHandler-&gt;OnControllerAnalog(PsudoInputButtonMapping[4], controllerIndex, xMove);
Â 
// This simulates the user moving the stick up and down repeatedly
float yMove = FMath::Cos(CurrentTimeFloat * .278f * 2 * PI);
// Fire analog input event
MessageHandler-&gt;OnControllerAnalog(PsudoInputButtonMapping[5], controllerIndex, yMove);
Â 
// This will spam the log heavily, comment it out for real pluginsÂ ðŸ˜ƒ
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Sending Controller Events jump%d, x%f, y%f&quot;), PreviousButtonStates[1], xMove, yMove);
Â 
// This is how you fire your fancypantz new controller events... the ones you added because you couldn't find an existing EControllerButton that matched your needs!
FSlateApplication::Get().OnControllerAnalog(IPsudoControllerPlugin::Psudo_WeighingScales, controllerIndex, 75); // This will spam 75(kg) to my fancy new output type!
}
Â 
void FPsudoControllerInputDevice::SetMessageHandler(const TSharedRef&lt; FGenericApplicationMessageHandler &gt;&amp; InMessageHandler) {
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Set Message Handler&quot;));
MessageHandler = InMessageHandler;
}
Â 
bool FPsudoControllerInputDevice::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice&amp; Ar) {
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Execute Console Command:Â %s&quot;), Cmd);
Â 
// Put your fancy custom console command code here...
// ToDo: use this to let you fire psudo controller events
Â 
return true;
}
Â 
// IForceFeedbackSystem pass through functions
//  - I *believe* this is a handel for the game to communicate back to your third party libary (i.e. game tells joystick to increase force feedback/vibrate/turn on/off a light)
void FPsudoControllerInputDevice::SetChannelValue(int32 ControllerId, FForceFeedbackChannelType ChannelType, float Value) {
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Set Force FeedbackÂ %f&quot;), Value);
}
void FPsudoControllerInputDevice::SetChannelValues(int32 ControllerId, const FForceFeedbackValues &amp;values) {
// This will spam the log heavily, comment it out for real pluginsÂ ðŸ˜ƒ
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Set Force Feedback Values&quot;));
}
Â 
// This is where you nicely clean up your plugin when its told to shut down!
//  - USE THIS PLEASE!!! no one likes memory leaks &gt;_&lt;
FPsudoControllerInputDevice::~FPsudoControllerInputDevice() {
UE_LOG(LogPsudoControllerDevice, Log, TEXT(&quot;Closing PsudoControllerInputDevice&quot;));
}</p> <h3 id="input-device-cpp-file-2"><a href="#input-device-cpp-file-2" class="header-anchor">#</a> Input Device Cpp File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Classes/PsudoActor.cpp</strong></p> <p>// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.
#include &quot;PsudoControllerPrivatePCH.h&quot;
Â 
#include &quot;Engine.h&quot;
#include &quot;PsudoActorObject.h&quot;
Â 
#include &quot;PsudoControllerPlugin.h&quot;
#include &quot;PsudoControllerInputDevice.h&quot;
Â 
DEFINE_LOG_CATEGORY_STATIC(LogPsudoActor, Log, All);
Â 
// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.
Â 
APsudoActorObject::APsudoActorObject(const class FPostConstructInitializeProperties&amp; PCIP) : Super(PCIP) {
UE_LOG(LogPsudoActor, Log, TEXT(&quot;Construct&quot;));
}
Â 
void APsudoActorObject::FunkyMethod() {
UE_LOG(LogPsudoActor, Log, TEXT(&quot;FunkyMethod()&quot;));
}</p> <h3 id="input-device-cpp-file-3"><a href="#input-device-cpp-file-3" class="header-anchor">#</a> Input Device Cpp File</h3> <p><strong>/Plugins/PsudoController/Source/PsudoController/Classes/PsudoActor.h</strong></p> <p>#pragma once
#include &quot;GameFramework/Actor.h&quot;
#include &quot;PsudoActorObject.generated.h&quot;
Â 
UCLASS(MinimalAPI, hidecategories = (Input))
class APsudoActorObject : public AActor
{
GENERATED_UCLASS_BODY()
Â 
UFUNCTION(BlueprintCallable, Category = &quot;Development&quot;)
virtual void FunkyMethod();
};</p> <p><a href="/index.php?title=User:Mspe044&amp;action=edit&amp;redlink=1" title="User:Mspe044 (page does not exist)">mspe044</a> (<a href="/index.php?title=User_talk:Mspe044&amp;action=edit&amp;redlink=1" title="User talk:Mspe044 (page does not exist)">talk</a>)</p> <p>Retrieved from &quot;<a href="https://wiki.unrealengine.com/index.php?title=Custom_Input_Devices&amp;oldid=10252" target="_blank" rel="noopener noreferrer">https://wiki.unrealengine.com/index.php?title=Custom_Input_Devices&amp;oldid=10252<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&quot;</p> <p><a href="/Special:Categories" title="Special:Categories">Category</a>:</p> <ul><li><a href="/Category:Code" title="Category:Code">Code</a></li></ul> <p><img src="https://tracking.unrealengine.com/track.png" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/wiki.unrealengine.com/assets/js/app.aaf63946.js" defer></script><script src="/wiki.unrealengine.com/assets/js/2.4f53495e.js" defer></script><script src="/wiki.unrealengine.com/assets/js/428.9de256a1.js" defer></script>
  </body>
</html>
