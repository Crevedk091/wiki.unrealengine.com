 Interfaces And Blueprints - Epic Wiki             

 

Interfaces And Blueprints
=========================

From Epic Wiki

Jump to: [navigation](#mw-head), [search](#p-search)

[Template:Rating](/index.php?title=Template:Rating&action=edit&redlink=1 "Template:Rating (page does not exist)") Using interfaces with C++ and Blueprints can be a little tricky when the interface is implemented purely in Blueprints. Currently, when a Blueprint implements an Interface the C++ InterfaceCast<> type cast does not work.

**Interface Cast Method** <syntaxhighlight lang="cpp"> auto MyInterface = InterfaceCast<IMyInterface>(ActorInstance); if (MyInterface) {

 // Other code

} </syntaxhighlight>

What you need to do instead is:

(Originally discovered by Lion032, [source](https://answers.unrealengine.com/questions/43038/buginerfacecast-returns-null-for-blueprint-classes.html))

**Implements Interface Method** <syntaxhighlight lang="cpp"> if (ActorInstance->GetClass()->ImplementsInterface(UMyInterface::StaticClass())) {

 // Other code

} </syntaxhighlight>

This will work for both C++ implemented interfaces and Blueprint implemented interfaces. From here, you can use the static Execute versions of the interface functions.

**Header:** <syntaxhighlight lang="cpp"> UINTERFACE(MinimalAPI) class UMyInterface : public UInterface {

 GENERATED\_UINTERFACE\_BODY()

};

class IMyInterface {

 GENERATED\_IINTERFACE\_BODY()

public:

 UFUNCTION(BlueprintImplementableEvent)
 void MyInterfaceFunction();

}; </syntaxhighlight>

**Interface function example:** <syntaxhighlight lang="cpp"> if (ActorInstance->GetClass()->ImplementsInterface(UMyInterface::StaticClass())) {

 IMyInterface::Execute\_MyInterfaceFunction(ActorInstance);

} </syntaxhighlight>

It is likely that the static Execute functions are generated by the Unreal Header Tool (UHT) only for interface functions that declare UFUNCTION(). This means that you can't make a virtual interface function which uses UFUNCTION() and intellisense won't pick them up.

  

More Complete Example (Passing Self as Reference):
--------------------------------------------------

**MyInterface.H:** <syntaxhighlight lang="cpp">

class AMyActor;

  
UINTERFACE(Category = "My Interface", BlueprintType, meta = (DisplayName = "My Interface")) class MYMODULE\_API UMyInterface : public UInterface { GENERATED\_UINTERFACE\_BODY() };

class MYMODULE\_API IMyInterface { GENERATED\_IINTERFACE\_BODY() public: /// My Initialization Interface. UFUNCTION(Category = "My Interface", BlueprintNativeEvent, BlueprintCallable, meta = (DisplayName = "On My Interface Execute") void OnInitialized(const AMyActor\* Context); };

</syntaxhighlight>

**MyActor.H:** <syntaxhighlight lang="cpp"> UFUNCTION(Category = "My Interface", BlueprintNativeEvent, BlueprintCallable, meta = (DisplayName = "On My Interface Call")) void OnInitialized(const AMyActor\* Context); </syntaxhighlight>

**MyActor.CPP:** <syntaxhighlight lang="cpp">

void AMyActor::OnInitialized\_Implementation(const AMyActor\* Context) {

if (Context != this) {return;}

TArray<AActor\*>Interfaces; // Pick only Actors with Interface, instead of iterating whole World: UGameplayStatics::GetAllActorsWithInterface(this,UMyInterface::StaticClass(),Interfaces);

for (const auto &Actor : Interfaces) {

// Try to Execute on C++ layer: const auto &Interface = Cast<IMyInterface>(Actor); if (Interface) {Interface->Execute\_OnInitialized(Actor,Context);} else

// Else, Execute Interface on Blueprint layer instead: if (Actor->GetClass()->ImplementsInterface(UMyInterface::StaticClass())) { IMyInterface::Execute\_OnInitialized(Actor,Context); }

}

}

void AMyActor::BeginPlay() { Super::BeginPlay();

// Fire off the Native Event, which is going to be received by all the other Actors: Execute\_OnInitialized(this,this);

}

</syntaxhighlight>

Notes: Example above is implemented with old **GENERATED\_UCLASS\_BODY()** instead of new **GENERATED\_BODY()** one. If you want your Actor to receive C++ Interface calls instead of from Blueprint layer, your Actor must inherit from both AActor class and your Interface class, like so: <syntaxhighlight lang="cpp"> class MYMODULE\_API AMyActor : public AActor, public IMyInterface {...} </syntaxhighlight>

  

Update and pointer to more detailed discussion
----------------------------------------------

Thanks for this wiki; I think it is essential on getting interfaces to work properly. I wrote a longer discussion of what I think is going on with Blueprint and C++ interfaces at [https://answers.unrealengine.com/questions/214147/grand-unified-cblueprint-cast-interface-explanatio.html](https://answers.unrealengine.com/questions/214147/grand-unified-cblueprint-cast-interface-explanatio.html) which I thought readers of this topic might find useful. -Xarol

[James Tan](/index.php?title=User:Solid_Snake&action=edit&redlink=1 "User:Solid Snake (page does not exist)") , [Bruno Xavier](/index.php?title=User:BrUnO_XaVIeR&action=edit&redlink=1 "User:BrUnO XaVIeR (page does not exist)")

Retrieved from "[https://wiki.unrealengine.com/index.php?title=Interfaces\_And\_Blueprints&oldid=717](https://wiki.unrealengine.com/index.php?title=Interfaces_And_Blueprints&oldid=717)"

[Categories](/index.php?title=Special:Categories "Special:Categories"):

*   [Tutorials](/index.php?title=Category:Tutorials&action=edit&redlink=1 "Category:Tutorials (page does not exist)")
*   [Code](/index.php?title=Category:Code "Category:Code")
*   [Community Created Content](/index.php?title=Category:Community_Created_Content "Category:Community Created Content")