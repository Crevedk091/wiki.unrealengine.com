<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>wiki.unrealengine.com</title>
    <meta name="description" content="A static site pulled from the internet archive">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css" as="style"><link rel="preload" href="/wiki.unrealengine.com/assets/js/app.aaf63946.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/2.4f53495e.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/1125.ad8826c7.js" as="script">
    <link rel="stylesheet" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki.unrealengine.com/" class="home-link router-link-active"><!----> <span class="site-name">wiki.unrealengine.com</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>UT3 Weapons Tutorial - Flak Cannon - Epic Wiki</p> <h1 id="ut3-weapons-tutorial-flak-cannon"><a href="#ut3-weapons-tutorial-flak-cannon" class="header-anchor">#</a> UT3 Weapons Tutorial - Flak Cannon</h1> <h2 id="contents"><a href="#contents" class="header-anchor">#</a> Contents</h2> <ul><li><a href="#UT3_Weapons_Tutorial_-_Flak_Cannon">1 UT3 Weapons Tutorial - Flak Cannon</a> <ul><li><a href="#Requirements">1.1 Requirements</a></li> <li><a href="#Features">1.2 Features</a></li> <li><a href="#Notes">1.3 Notes</a></li> <li><a href="#Contact">1.4 Contact</a></li> <li><a href="#Flak_Cannon">1.5 Flak Cannon</a> <ul><li><a href="#Primary_Fire">1.5.1 Primary Fire</a></li> <li><a href="#Secondary_Fire">1.5.2 Secondary Fire</a></li> <li><a href="#Shard_Projectile">1.5.3 Shard Projectile</a></li> <li><a href="#Main_Shard_Projectile">1.5.4 Main Shard Projectile</a></li> <li><a href="#Shell_Projectile">1.5.5 Shell Projectile</a></li></ul></li> <li><a href="#Implementation">1.6 Implementation</a> <ul><li><a href="#Common_code">1.6.1 Common code</a></li> <li><a href="#Creating_Flak_Cannon_Classes">1.6.2 Creating Flak Cannon Classes</a></li> <li><a href="#Setting_up_weapon_asset_references">1.6.3 Setting up weapon asset references</a></li> <li><a href="#Basic_Parameters">1.6.4 Basic Parameters</a></li> <li><a href="#Playtesting">1.6.5 Playtesting</a></li> <li><a href="#Adding_bounce_effects">1.6.6 Adding bounce effects</a> <ul><li><a href="#Bounce_Effect_Rotation">1.6.6.1 Bounce Effect Rotation</a></li></ul></li> <li><a href="#Making_projectile_become_affected_by_gravity_after_bounce">1.6.7 Making projectile become affected by gravity after bounce</a></li> <li><a href="#Limiting_projectile_bounce_count">1.6.8 Limiting projectile bounce count</a></li> <li><a href="#Increasing_projectile_lifespan_after_bounce">1.6.9 Increasing projectile lifespan after bounce</a></li> <li><a href="#Reducing_projectile.27s_damage_over_time">1.6.10 Reducing projectile's damage over time</a></li> <li><a href="#Making_projectile_apply_damage_only_when_moving_fast_enough">1.6.11 Making projectile apply damage only when moving fast enough</a></li> <li><a href="#Flak_Cannon_main_shard">1.6.12 Flak Cannon main shard</a> <ul><li><a href="#Adjusting_damage_based_on_how_much_in-the-face_the_shot_was">1.6.12.1 Adjusting damage based on how much in-the-face the shot was</a></li></ul></li> <li><a href="#Making_Flak_Shell_spawn_additional_shards_on_explosion">1.6.13 Making Flak Shell spawn additional shards on explosion</a></li> <li><a href="#Spawning_multiple_shards_at_once">1.6.14 Spawning multiple shards at once</a> <ul><li><a href="#Projectile_firing_pattern">1.6.14.1 Projectile firing pattern</a> <ul><li><a href="#Projectile_firing_pattern_randomization">1.6.14.1.1 Projectile firing pattern randomization</a></li></ul></li></ul></li> <li><a href="#Camera_Shake">1.6.15 Camera Shake</a></li></ul></li> <li><a href="#Source_Code">1.7 Source Code</a></li></ul></li></ul> <h1 id="ut3-weapons-tutorial-flak-cannon-2"><a href="#ut3-weapons-tutorial-flak-cannon-2" class="header-anchor">#</a> UT3 Weapons Tutorial - Flak Cannon</h1> <p>This tutorial will show you how to create Flak Cannon from Unreal Tournament 3 using C++ only.</p> <p>NOTE:</p> <ul><li>UT has just upgraded to UE 4.2.1, this tutorial will be verified for compatibility shortly.</li></ul> <h2 id="requirements"><a href="#requirements" class="header-anchor">#</a> Requirements</h2> <p>Some existing C++ &amp; Unreal Engine knowledge is needed.</p> <ul><li>Engine version: 4.2</li> <li>Skill level: intermediate</li> <li>Unreal Tournament commit: <a href="https://github.com/EpicGames/UnrealTournament/commit/9fe9fc679a26a0ea816e9fd3db080255394bf4dc" target="_blank" rel="noopener noreferrer">9fe9fc679a26a0ea816e9fd3db080255394bf4dc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="features"><a href="#features" class="header-anchor">#</a> Features</h2> <ul><li>Spawnng multiple projectiles at once</li> <li>Controlled firing pattern for multiple projectiles</li> <li>Making projectiles spawn other projectiles upon explosion</li> <li>Adjusting projectile damage based on distance and hit location</li> <li>Adjusting projectile damage over time</li></ul> <h2 id="notes"><a href="#notes" class="header-anchor">#</a> Notes</h2> <ul><li>When overriding a function in subclass always add a definition to the header file as well.</li> <li>Functions with <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Functions/Specifiers/BlueprintNativeEvent/index.html" target="_blank" rel="noopener noreferrer">BlueprintNativeEvent<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> attribute generate additional virtual function called &quot;FunctionName_Implementation&quot;. Override the _Implementation one instead.</li> <li>Code snippets are located in grey expandable boxes. Click Expand on the right to see the code.</li> <li>Yellow lines in code snippets highlight only the code that needs to be changed.</li></ul> <h2 id="contact"><a href="#contact" class="header-anchor">#</a> Contact</h2> <ul><li><a href="https://forums.unrealtournament.com/showthread.php?11233-UT3-Flak-Cannon-Tutorial&amp;p=82857#post82857" target="_blank" rel="noopener noreferrer">unrealtournament.com forum thread<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>--<a href="/User:Neai" title="User:Neai">Neai</a> (<a href="/index.php?title=User_talk:Neai&amp;action=edit&amp;redlink=1" title="User talk:Neai (page does not exist)">talk</a>) 17:49, 30 June 2014 (UTC)</p> <h2 id="flak-cannon"><a href="#flak-cannon" class="header-anchor">#</a> Flak Cannon</h2> <p>We'll start by defining what features we want to implement:</p> <h3 id="primary-fire"><a href="#primary-fire" class="header-anchor">#</a> Primary Fire</h3> <ol><li>Fire 9 shard projectiles at once</li> <li>Main shard should be fired at crosshair</li> <li>Remaining shards should be fired in a random'ish circle around the main shard</li> <li>The firing pattern should spread shards evenly inside the firing cone</li></ol> <h3 id="secondary-fire"><a href="#secondary-fire" class="header-anchor">#</a> Secondary Fire</h3> <ol><li>Fire an explosive shell projectile</li></ol> <h3 id="shard-projectile"><a href="#shard-projectile" class="header-anchor">#</a> Shard Projectile</h3> <ol><li>Bounces up to 2 times</li> <li>Is not affected by gravity until it bounces</li> <li>Can deal damage only when moving fast enough</li></ol> <h3 id="main-shard-projectile"><a href="#main-shard-projectile" class="header-anchor">#</a> Main Shard Projectile</h3> <p>Same as shard projectile except that:</p> <ol><li>Bounces up to 3 times</li> <li>Deals additional damage &amp; momentum when firing at point blank at center of enemy</li></ol> <h3 id="shell-projectile"><a href="#shell-projectile" class="header-anchor">#</a> Shell Projectile</h3> <ol><li>High trajectory</li> <li>Explodes upon contact</li> <li>Upon explosion spawns 5 shards</li></ol> <h2 id="implementation"><a href="#implementation" class="header-anchor">#</a> Implementation</h2> <p>To implement such projectile weapon we should create subclasses of <strong>AUTWeapon</strong>, <strong>AUTProjectile</strong>, <strong>UUTDamageType</strong> and <strong>AUTWeaponAttachment</strong>.</p> <h3 id="common-code"><a href="#common-code" class="header-anchor">#</a> Common code</h3> <p>We will implement some of the features in generic classes which can be later used for other weapons. To keep the tutorial code friendly to engine &amp; game code updates, we will create our own generic subclasses of UTWeapon &amp; UTProjectile instead of modifying them.</p> <p>Lets start by creating an abstract subclass of <strong>AUTWeapon</strong> called <strong>AUTWeapon_Boom</strong>. This will be our common base class for UT3 weapons.</p> <ol><li><p>// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.</p></li> <li><p>#pragma once</p></li> <li><p>#include &quot;UTWeapon.h&quot;</p></li> <li><p>#include &quot;UTWeapon_Boom.generated.h&quot;</p></li> <li><p>UCLASS(Abstract, NotPlaceable)</p></li> <li><p>class AUTWeapon_Boom : public AUTWeapon</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code>GENERATED\_UCLASS\_BODY()
</code></pre></div></li> <li><p>};</p></li></ol> <p>We will also need an abstract subclass of <strong>AUTProjectile</strong> called <strong>AUTProjectile_Boom</strong>. This will be our common base class for UT3 projectiles.</p> <ol><li><p>// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.</p></li> <li><p>#pragma once</p></li> <li><p>#include &quot;UTProjectile.h&quot;</p></li> <li><p>#include &quot;UTProjectile_Boom.generated.h&quot;</p></li> <li><p>UCLASS(Abstract, NotPlaceable)</p></li> <li><p>class AUTProjectile_Boom : public AUTProjectile</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code>GENERATED\_UCLASS\_BODY()
</code></pre></div></li> <li><p>};</p></li></ol> <p>Since we are going to use property values from UT3, we will need to adjust them to UT4 player scale. In UT3 player is 88 units high, in UT4 player is 192 units high. Therefore we need to multiply all projectile velocities, damage radiuses, momentums, etc, to get the same results in UT4. Add the following definition to <strong>UnrealTournament.h</strong> so it's accessible from everywhere:</p> <ol><li><p>// Ratio for scaling UT3 distance-related values</p></li> <li><p>// See AUTCharacter CapsuleComponent HalfHeight</p></li> <li><p>#define UT3_TO_UT4_SCALE (96.f / 44.f)</p></li></ol> <h3 id="creating-flak-cannon-classes"><a href="#creating-flak-cannon-classes" class="header-anchor">#</a> Creating Flak Cannon Classes</h3> <p>Next, lets create classes for all the elements of Flak Cannon:</p> <ol><li>Weapon
<ol><li>Create subclass of <strong>AUTWeapon_Boom</strong> called <strong>AUTWeap_FlakCannon</strong></li></ol></li> <li>3rd person weapon attachment
<ol><li>Create subclass of <strong>AUTWeaponAttachment</strong> called <strong>AUTAttachment_FlakCannon</strong></li></ol></li> <li>Projectiles
<ol><li>Create subclass of <strong>AUTProjectile_Boom</strong> called <strong>AUTProj_FlakShell</strong></li> <li>Create subclass of <strong>AUTProjectile_Boom</strong> called <strong>AUTProj_FlakShard</strong></li> <li>Create subclass of <strong>AUTProj_FlakShard</strong> called <strong>AUTProj_FlakShardMain</strong></li></ol></li> <li>Damage Types
<ol><li>Create subclass of <strong>UUTDamageType</strong> called <strong>UTDmgType_FlakShell</strong></li> <li>Create subclass of <strong>UUTDamageType</strong> called <strong>UTDmgType_FlakShard</strong></li></ol></li></ol> <h3 id="setting-up-weapon-asset-references"><a href="#setting-up-weapon-asset-references" class="header-anchor">#</a> Setting up weapon asset references</h3> <p>It's a good idea to have a functional weapon at the start, even if the custom logic isn't there yet. We will link all the parts together and assign visual properties. Assigning asset references to properties is very easy in blueprints, but we can do it in C++ as well.</p> <p><strong>AUTWeap_FlakCannon.cpp</strong> - Setup asset references</p> <ol><li><p>// Copyright 1998-2014 Epic Games, Inc. All Rights Reserved.</p></li> <li><p>#include &quot;UnrealTournament.h&quot;</p></li> <li><p>#include &quot;UTWeap_FlakCannon.h&quot;</p></li> <li><p>#include &quot;UTProj_FlakShard.h&quot;</p></li> <li><p>#include &quot;UTProj_FlakShell.h&quot;</p></li> <li><p>#include &quot;UTProj_FlakShardMain.h&quot;</p></li> <li><p>#include &quot;UTAttachment_FlakCannon.h&quot;</p></li> <li><p>AUTWeap_FlakCannon::AUTWeap_FlakCannon(const FPostConstructInitializeProperties&amp; PCIP)</p></li> <li><p>: Super(PCIP)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code>// Asset references
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>struct FConstructorStatics
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USkeletalMesh\&gt; SkeletalMesh;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UAnimBlueprintGeneratedClass\&gt; AnimBlueprintGeneratedClass;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UAnimMontage\&gt; FireAnimation0;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UAnimMontage\&gt; FireAnimation1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UAnimMontage\&gt; BringUpAnim;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UAnimMontage\&gt; PutDownAnim;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USoundCue\&gt; FireSound0;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USoundCue\&gt; FireSound1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USoundCue\&gt; PickupSound;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UParticleSystem\&gt; MuzzleFlash;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FConstructorStatics()
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		: SkeletalMesh(TEXT(&quot;SkeletalMesh'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Meshes/SK\_WP\_FlakCannon\_1P.SK\_WP\_FlakCannon\_1P'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, AnimBlueprintGeneratedClass(TEXT(&quot;AnimBlueprintGeneratedClass'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Anim/Flak\_AnimBP.Flak\_AnimBP\_C'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, FireAnimation0(TEXT(&quot;AnimMontage'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Anim/Flak\_Fire\_Montage.Flak\_Fire\_Montage'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, FireAnimation1(TEXT(&quot;AnimMontage'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Anim/Flak\_Fire\_Montage.Flak\_Fire\_Montage'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, BringUpAnim(TEXT(&quot;AnimMontage'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Anim/Flak\_Equip.Flak\_Equip'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, PutDownAnim(TEXT(&quot;AnimMontage'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Anim/Flak\_PutDown.Flak\_PutDown'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, FireSound0(TEXT(&quot;SoundCue'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Audio/CUE/A\_FlakCannon\_FireCue.A\_FlakCannon\_FireCue'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, FireSound1(TEXT(&quot;SoundCue'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Audio/CUE/A\_FlakCannon\_FireAltCue.A\_FlakCannon\_FireAltCue'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, PickupSound(TEXT(&quot;SoundCue'/Game/RestrictedAssets/Proto/UT3\_Pickups/Audio/Weapons/Cue/A\_Pickup\_Weapons\_Flak\_Cue.A\_Pickup\_Weapons\_Flak\_Cue'&quot;))MuzzleFlash(TEXT(&quot;ParticleSystem'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Effects/P\_WP\_FlakCannon\_Muzzle\_Flash.P\_WP\_FlakCannon\_Muzzle\_Flash'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>};
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>static FConstructorStatics ConstructorStatics;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Mesh
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Mesh\-\&gt;SkeletalMesh \= ConstructorStatics.SkeletalMesh.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Mesh\-\&gt;AnimBlueprintGeneratedClass \= ConstructorStatics.AnimBlueprintGeneratedClass.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Mesh\-\&gt;RelativeLocation \= FVector(\-2.349056, \-3.957190, \-5.411549);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Mesh\-\&gt;RelativeScale3D \= FVector(0.750000, 0.750000, 0.750000);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireAnimation.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireAnimation\[0\] \= ConstructorStatics.FireAnimation0.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireAnimation\[1\] \= ConstructorStatics.FireAnimation1.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>BringUpAnim \= ConstructorStatics.BringUpAnim.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>PutDownAnim \= ConstructorStatics.PutDownAnim.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Muzzle Flash
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UParticleSystemComponent\&gt; MuzzleComponent \= PCIP.CreateDefaultSubobject&lt;UParticleSystemComponent\&gt;(this, TEXT(&quot;FlakCannon-MuzzleFlash&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MuzzleComponent\-\&gt;Template \= ConstructorStatics.MuzzleFlash.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MuzzleComponent\-\&gt;AttachTo(Mesh, FName(TEXT(&quot;MuzzleFlashSocket&quot;)));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MuzzleFlash.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MuzzleFlash\[0\] \= MuzzleComponent;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MuzzleFlash\[1\] \= MuzzleComponent;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// 3rd person
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AttachmentType \= AUTAttachment\_FlakCannon::StaticClass();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Sounds
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireSound.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireSound\[0\] \= ConstructorStatics.FireSound0.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireSound\[1\] \= ConstructorStatics.FireSound1.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>PickupSound \= ConstructorStatics.PickupSound.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// UI
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Group \= 7;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>IconCoordinates \= FTextureUVs(131.000000, 429.000000, 132.000000, 52.000000);
</code></pre></div></li> <li><p>}</p></li></ol> <p>Notice that assets are loaded statically only once. Asset paths can be copy-pasted straight from editor.</p> <p><strong>AUTAttachment_FlakCannon.cpp</strong> - Setup asset references</p> <ol><li><p>#include &quot;UnrealTournament.h&quot;</p></li> <li><p>#include &quot;UTAttachment_FlakCannon.h&quot;</p></li> <li><p>AUTAttachment_FlakCannon::AUTAttachment_FlakCannon(const class FPostConstructInitializeProperties&amp; PCIP)</p></li> <li><div class="language- extra-class"><pre><code> : Super(PCIP)
</code></pre></div></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> // Structure to hold one-time initialization
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> struct FConstructorStatics
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USkeletalMesh\&gt; SkeletalMesh;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FConstructorStatics()
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		: SkeletalMesh(TEXT(&quot;SkeletalMesh'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Meshes/SK\_WP\_FlakCannon\_3P\_Mid.SK\_WP\_FlakCannon\_3P\_Mid'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>};
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>static FConstructorStatics ConstructorStatics;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Mesh\-\&gt;SkeletalMesh \= ConstructorStatics.SkeletalMesh.Object;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTProj_FlakShell.cpp</strong> - Setup asset references</p> <ol><li><p>#include &quot;UnrealTournament.h&quot;</p></li> <li><p>#include &quot;UTProjectileMovementComponent.h&quot;</p></li> <li><p>#include &quot;UTProj_FlakShell.h&quot;</p></li> <li><p>#include &quot;UTProj_FlakShard.h&quot;</p></li> <li><p>#include &quot;UTDmgType_FlakShell.h&quot;</p></li> <li><p>AUTProj_FlakShell::AUTProj_FlakShell(const class FPostConstructInitializeProperties&amp; PCIP)</p></li> <li><div class="language- extra-class"><pre><code> : Super(PCIP)
</code></pre></div></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code>// Structure to hold one-time initialization
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>struct FConstructorStatics
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UParticleSystem\&gt; ExplosionEffect;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USoundCue\&gt; ExplosionSound;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USoundCue\&gt; AmbientSound;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UParticleSystem\&gt; TrailEffect;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FConstructorStatics()
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		: ExplosionEffect(TEXT(&quot;ParticleSystem'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Effects/P\_WP\_Flak\_Alt\_Explosion.P\_WP\_Flak\_Alt\_Explosion'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, ExplosionSound(TEXT(&quot;SoundCue'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Audio/CUE/A\_FlakCannon\_FireAltImpactExplodeCue.A\_FlakCannon\_FireAltImpactExplodeCue'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, AmbientSound(TEXT(&quot;SoundCue'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Audio/CUE/A\_FlakCannon\_FireAltInAirCue.A\_FlakCannon\_FireAltInAirCue'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, TrailEffect(TEXT(&quot;ParticleSystem'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Effects/P\_WP\_Flak\_Alt\_Smoke\_Trail.P\_WP\_Flak\_Alt\_Smoke\_Trail'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>};
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>static FConstructorStatics ConstructorStatics;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Visuals
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UAudioComponent\&gt; AmbientSound \= PCIP.CreateDefaultSubobject&lt;UAudioComponent\&gt;(this, TEXT(&quot;FlakShell-Ambient&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AmbientSound\-\&gt;Sound \= ConstructorStatics.AmbientSound.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AmbientSound\-\&gt;VolumeMultiplier \= 0.5;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AmbientSound\-\&gt;AttachTo(RootComponent);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UParticleSystemComponent\&gt; TrailComponent \= PCIP.CreateDefaultSubobject&lt;UParticleSystemComponent\&gt;(this, TEXT(&quot;FlakShell-Trail&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TrailComponent\-\&gt;Template \= ConstructorStatics.TrailEffect.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TrailComponent\-\&gt;SetRelativeLocation(FVector(\-3, 0, 0));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TrailComponent\-\&gt;SetRelativeScale3D(FVector(1.5, 1.5, 1.5));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TrailComponent\-\&gt;AttachTo(RootComponent);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UPointLightComponent\&gt; LightComponent \= PCIP.CreateDefaultSubobject&lt;UPointLightComponent\&gt;(this, TEXT(&quot;FlakShell-Light&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;Intensity \= 150;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;AttenuationRadius \= 250;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;LightColor \= FColor(47, 209, 255);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;SetCastShadows(false);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;AttachTo(RootComponent);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>ExplosionEffect \= ConstructorStatics.ExplosionEffect.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>ExplosionSound \= ConstructorStatics.ExplosionSound.Object;
</code></pre></div></li> <li><p>}</p></li></ol> <p>The mesh is actually set up as part of particle emitter, hence there's no static mesh component.</p> <p><strong>AUTProj_FlakShard.cpp</strong> - Setup asset references</p> <ol><li><p>#include &quot;UnrealTournament.h&quot;</p></li> <li><p>#include &quot;UTProjectileMovementComponent.h&quot;</p></li> <li><p>#include &quot;UTProj_FlakShard.h&quot;</p></li> <li><p>#include &quot;UTDmgType_FlakShard.h&quot;</p></li> <li><p>AUTProj_FlakShard::AUTProj_FlakShard(const class FPostConstructInitializeProperties&amp; PCIP)</p></li> <li><div class="language- extra-class"><pre><code> : Super(PCIP)
</code></pre></div></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> // Structure to hold one-time initialization
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>struct FConstructorStatics
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UParticleSystem\&gt; BounceEffect;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;USoundCue\&gt; BounceSound;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UStaticMesh\&gt; StaticMesh;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UMaterial\&gt; StaticMeshMaterial0;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ConstructorHelpers::FObjectFinder&lt;UParticleSystem\&gt; TrailEffect;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FConstructorStatics()
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		: BounceEffect(TEXT(&quot;ParticleSystem'/Game/RestrictedAssets/Weapons/Flak/Assets/Flak\_Hit\_Spark.Flak\_Hit\_Spark'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, BounceSound(TEXT(&quot;SoundCue'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Audio/CUE/A\_FlakCannon\_FireImpactDirtCue.A\_FlakCannon\_FireImpactDirtCue'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, StaticMesh(TEXT(&quot;StaticMesh'/Game/RestrictedAssets/Proto/UT3\_Weapons/WP\_FlakCannon/Meshes/S\_Flak\_Chunk.S\_Flak\_Chunk'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, StaticMeshMaterial0(TEXT(&quot;Material'/Game/RestrictedAssets/Weapons/Flak/Assets/M\_Shard.M\_Shard'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		, TrailEffect(TEXT(&quot;ParticleSystem'/Game/RestrictedAssets/Weapons/Flak/Assets/Trail.Trail'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>};
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>static FConstructorStatics ConstructorStatics;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Visuals
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UStaticMeshComponent\&gt; StaticMeshComponent \= PCIP.CreateDefaultSubobject&lt;UStaticMeshComponent\&gt;(this, TEXT(&quot;FlakShard-StaticMesh&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>StaticMeshComponent\-\&gt;StaticMesh \= ConstructorStatics.StaticMesh.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>StaticMeshComponent\-\&gt;bGenerateOverlapEvents \= false;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>StaticMeshComponent\-\&gt;SetCollisionProfileName(UCollisionProfile::NoCollision\_ProfileName);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>StaticMeshComponent\-\&gt;SetMaterial(0, ConstructorStatics.StaticMeshMaterial0.Object);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>StaticMeshComponent\-\&gt;SetRelativeScale3D(FVector(0.25, 0.25, 0.25));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>StaticMeshComponent\-\&gt;AttachTo(RootComponent);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UParticleSystemComponent\&gt; TrailComponent \= PCIP.CreateDefaultSubobject&lt;UParticleSystemComponent\&gt;(this, TEXT(&quot;FlakShard-Trail&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TrailComponent\-\&gt;Template \= ConstructorStatics.TrailEffect.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TrailComponent\-\&gt;AttachTo(RootComponent);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubobjectPtr&lt;UPointLightComponent\&gt; LightComponent \= PCIP.CreateDefaultSubobject&lt;UPointLightComponent\&gt;(this, TEXT(&quot;FlakShard-Light&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;Intensity \= 100;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;AttenuationRadius \= 100;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;LightColor \= FColor(255, 133, 35);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;SetCastShadows(false);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>LightComponent\-\&gt;AttachTo(RootComponent);
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="basic-parameters"><a href="#basic-parameters" class="header-anchor">#</a> Basic Parameters</h3> <p>We're going to use parameter values from UT3. Set them in constructors:</p> <p><strong>AUTProj_FlakShell.cpp</strong> - We will use high TossZ value to give the projectile high trajectory. This way player can aim at distant opponents without having to aim at the sky.</p> <ol><li><div class="language- extra-class"><pre><code> // Movement
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;InitialSpeed \= 1200.f \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;MaxSpeed \= 1200.f \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;ProjectileGravityScale \= 1.0f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> CollisionComp\-\&gt;InitSphereRadius(10);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TossZ \= 305 \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Damage
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MyDamageType \= UUTDmgType\_FlakShell::StaticClass();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>DamageParams.BaseDamage \= 100;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>DamageParams.OuterRadius \= 200 \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Momentum \= 75000 \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>InitialLifeSpan \= 6;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Lets make it rotate</p> <ol><li><div class="language- extra-class"><pre><code> // Movement
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TSubobjectPtr&lt;URotatingMovementComponent\&gt; RotatingMovement \= PCIP.CreateDefaultSubobject&lt;URotatingMovementComponent\&gt;(this, TEXT(&quot;FlakShard-RotatingMovement&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> RotatingMovement\-\&gt;RotationRate \= FRotator(0, 0, 270);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;InitialSpeed \= 3500.f \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;MaxSpeed \= 3500.f \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;ProjectileGravityScale \= 0.f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;bRotationFollowsVelocity \= false;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>ProjectileMovement\-\&gt;bShouldBounce \= true;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Damage
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MyDamageType \= UUTDmgType\_FlakShard::StaticClass();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>DamageParams.BaseDamage \= 18.f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Momentum \= 14000 \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>InitialLifeSpan \= 2.f;
</code></pre></div></li></ol> <p><strong>AUTWeap_FlakCannon.cpp</strong> - Setting up fire modes</p> <ol><li><div class="language- extra-class"><pre><code> // Firing
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjClass.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjClass\[0\] \= AUTProj\_FlakShardMain::StaticClass();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjClass\[1\] \= AUTProj\_FlakShell::StaticClass();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> FireInterval.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> FireInterval\[0\] \= 1.1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> FireInterval\[1\] \= 1.1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AmmoCost.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AmmoCost\[0\] \= 1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AmmoCost\[1\] \= 1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Ammo \= 10;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>MaxAmmo \= 30;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FireOffset \= FVector(75.f, 18.f, \-15.f);
</code></pre></div></li></ol> <h3 id="playtesting"><a href="#playtesting" class="header-anchor">#</a> Playtesting</h3> <p>At this point we can test the weapon ingame, although it doesn't have custom logic yet. To test the weapon add an <strong>WeaponBase</strong> Blueprint to level and in its properties make it use our <strong>AUTWeap_FlakCannon</strong>.</p> <h3 id="adding-bounce-effects"><a href="#adding-bounce-effects" class="header-anchor">#</a> Adding bounce effects</h3> <p><strong>AUTProjectile_Boom.h</strong> - Add properties for Bounce Effect assets</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Bounce effect \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= Projectile)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UParticleSystem\* BounceEffect;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Sound played when projectile bounces off wall \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= Projectile)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> USoundBase\* BounceSound;
</code></pre></div></li></ol> <p><strong>AUTProjectile_Boom.cpp</strong> - Override OnBounce to make it play bounce effects</p> <ol><li><p>void AUTProjectile_Boom::OnBounce(const struct FHitResult&amp; ImpactResult, const FVector&amp; ImpactVelocity)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> Super::OnBounce(ImpactResult, ImpactVelocity);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Spawn bounce effect
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (GetNetMode() !\= NM\_DedicatedServer)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), BounceEffect, ImpactResult.Location, ImpactResult.ImpactNormal.Rotation(), true);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Play bounce sound
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>if (BounceSound !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	UUTGameplayStatics::UTPlaySound(GetWorld(), BounceSound, this, SRT\_IfSourceNotReplicated, false);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Add default assets to constructor</p> <ol><li><div class="language- extra-class"><pre><code> BounceEffect \= ConstructorStatics.BounceEffect.Object;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> BounceSound \= ConstructorStatics.BounceSound.Object;
</code></pre></div></li></ol> <p>After those changes, shards will spark on bounce and play sound effect.</p> <h4 id="bounce-effect-rotation"><a href="#bounce-effect-rotation" class="header-anchor">#</a> Bounce Effect Rotation</h4> <p>Notice that the sparks asset used will spawn in incorrect direction. This is because we're spawning in HitNormal direction, which has X axis pointing away from surface, and the emitter is spawning projectiles in Z axis direction, which in this case will be parallel to floor. The correct fix is to adjust the emitter asset so it spawns in X direction. We can however add a temporary workaround.</p> <p><strong>AUTProjectile_Boom.h</strong> - Lets add a BounceEffectRotation property</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Bounce effect \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= Projectile)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> FRotator BounceEffectRotation;
</code></pre></div></li></ol> <p><strong>AUTProjectile_Boom.cpp</strong> - We will use it to rotate HitNormal used for BounceEffect spawn rotation</p> <ol><li><p>void AUTProjectile_Boom::OnBounce(const struct FHitResult&amp; ImpactResult, const FVector&amp; ImpactVelocity)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> Super::OnBounce(ImpactResult, ImpactVelocity);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Spawn bounce effect
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (GetNetMode() !\= NM\_DedicatedServer)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), BounceEffect, ImpactResult.Location, BounceEffectRotation.RotateVector(ImpactResult.ImpactNormal).Rotation(), true);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Play bounce sound
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>if (BounceSound !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	UUTGameplayStatics::UTPlaySound(GetWorld(), BounceSound, this, SRT\_IfSourceNotReplicated, false);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Set default BounceEffectRotation in constructor</p> <ol><li><div class="language- extra-class"><pre><code> BounceEffectRotation \= FRotator(90, 0, 0);
</code></pre></div></li></ol> <h3 id="making-projectile-become-affected-by-gravity-after-bounce"><a href="#making-projectile-become-affected-by-gravity-after-bounce" class="header-anchor">#</a> Making projectile become affected by gravity after bounce</h3> <p>We want the shards to fly unaffected by gravity initially. Only after bounce they should fall towards floor.</p> <p><strong>AUTProj_FlakShard.cpp</strong> - To do so, lets override OnBounce</p> <ol><li><p>void AUTProj_FlakShard::OnBounce(const struct FHitResult&amp; ImpactResult, const FVector&amp; ImpactVelocity)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> Super::OnBounce(ImpactResult, ImpactVelocity);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Set gravity on bounce
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;ProjectileGravityScale \= 1.f;
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="limiting-projectile-bounce-count"><a href="#limiting-projectile-bounce-count" class="header-anchor">#</a> Limiting projectile bounce count</h3> <p>Next we will limit number of bounces to 2, as this is how UT3 Flak Shards work.</p> <p><strong>AUTProj_FlakShard.h</strong> - Add 2 new properties to define max number of bounces and current number of bounces</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Limit number of bounces \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> int32 BounceLimit;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Current number of times this projectile bounced \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> int32 BounceCount;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Set default number of bounces in constructor</p> <ol><li><div class="language- extra-class"><pre><code> BounceLimit \= 2;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Count the number of bounces in OnBounce and disable bouncing once limit is reached</p> <ol><li><p>void AUTProj_FlakShard::OnBounce(const struct FHitResult&amp; ImpactResult, const FVector&amp; ImpactVelocity)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> Super::OnBounce(ImpactResult, ImpactVelocity);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Set gravity on bounce
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;ProjectileGravityScale \= 1.f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Limit number of bounces
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (++BounceCount \== BounceLimit)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ProjectileMovement\-\&gt;bShouldBounce \= false;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="increasing-projectile-lifespan-after-bounce"><a href="#increasing-projectile-lifespan-after-bounce" class="header-anchor">#</a> Increasing projectile lifespan after bounce</h3> <p>We want to ensure that shards will fly for a bit after bouncing. Each projectile has a InitialLifeSpan property set that will limit how long this projectile can exist. Combined with velocity it affects maximum shooting distance.</p> <p><strong>AUTProj_FlakShard.h</strong> - Add 2 new properties for increasing lifespan after bounce and an extra one after final bounce</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Increment lifespan on bounce by this amount \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float BounceLifeSpanIncrement;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Increment lifespan when projectile stops by this amount \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float BounceFinalLifeSpanIncrement;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Set default values for bonus lifespan</p> <ol><li><div class="language- extra-class"><pre><code> BounceLifeSpanIncrement \= 0.5f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> BounceFinalLifeSpanIncrement \= 0.25f;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Count the number of bounces in OnBounce and disable bouncing once limit is reached</p> <ol><li><p>void AUTProj_FlakShard::OnBounce(const struct FHitResult&amp; ImpactResult, const FVector&amp; ImpactVelocity)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> Super::OnBounce(ImpactResult, ImpactVelocity);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Set gravity on bounce
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ProjectileMovement\-\&gt;ProjectileGravityScale \= 1.f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Extend lifespan on bounce
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> SetLifeSpan(GetLifeSpan() + BounceLifeSpanIncrement);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Limit number of bounces
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>if (++BounceCount \== BounceLimit)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ProjectileMovement\-\&gt;bShouldBounce \= false;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	SetLifeSpan(GetLifeSpan() + BounceFinalLifeSpanIncrement);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="reducing-projectile-s-damage-over-time"><a href="#reducing-projectile-s-damage-over-time" class="header-anchor">#</a> Reducing projectile's damage over time</h3> <p>Flak Shards lose 5 damage per second of flight. To implement that we'll need to add function that calculate actual damage instead of using only properties. While we're at it, we'll add dynamic momentum calculation as well, which will come handy later.</p> <p><strong>AUTProjectile_Boom.h</strong> - Add DamageAttenuation property that will deteermine amount of damage lost per second, and 2 new functions.</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Damage reduction per second, down to minimum damage\*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= Damage)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float DamageAttenuation;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Base damage calculation \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UFUNCTION(BlueprintCallable, Category \= Projectile)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> virtual float GetDamage(AActor\* OtherActor, const FVector&amp; HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Momentum calculation \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>UFUNCTION(BlueprintCallable, Category \= Projectile)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>virtual float GetMomentum(AActor\* OtherActor, const FVector&amp; HitLocation);
</code></pre></div></li></ol> <p><strong>AUTProjectile_Boom.cpp</strong> - If DamageAttenuation is set, GetDamage() will return reduced damage.</p> <ol><li><p>float AUTProjectile_Boom::GetDamage(AActor* OtherActor, const FVector&amp; HitLocation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (DamageAttenuation \&gt; 0)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	return FMath::Max(DamageParams.BaseDamage \- (GetWorld()\-\&gt;TimeSeconds \- CreationTime) \* DamageAttenuation, DamageParams.MinimumDamage);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> return DamageParams.BaseDamage;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTProjectile_Boom.cpp</strong> - GetMomentum() will return standard momentum by default.</p> <ol><li><p>float AUTProjectile_Boom::GetMomentum(AActor* OtherActor, const FVector&amp; HitLocation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> return Momentum;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTProjectile_Boom.cpp</strong> - To adjust damage &amp; momentum of explosions, override Explode_Implementation().</p> <ol><li><p>void AUTProjectile_Boom::Explode_Implementation(const FVector&amp; HitLocation, const FVector&amp; HitNormal)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (!bExploded)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	if (DamageParams.OuterRadius \&gt; 0.0f)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		TArray&lt;AActor\*\&gt; IgnoreActors;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		if (ImpactedActor !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			IgnoreActors.Add(ImpactedActor);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		const float AdjustedDamage \= GetDamage(NULL, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		const float AdjustedMomentum \= GetMomentum(NULL, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		UUTGameplayStatics::UTHurtRadius(this, AdjustedDamage, DamageParams.MinimumDamage, AdjustedMomentum, HitLocation, DamageParams.InnerRadius, DamageParams.OuterRadius, DamageParams.DamageFalloff, MyDamageType, IgnoreActors, this, InstigatorController);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	if (Role \== ROLE\_Authority)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		bTearOff \= true;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	bExploded \= true;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	UUTGameplayStatics::UTPlaySound(GetWorld(), ExplosionSound, this, ESoundReplicationType::SRT\_IfSourceNotReplicated);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	if (GetNetMode() !\= NM\_DedicatedServer)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ExplosionEffect, GetActorLocation(), HitNormal.Rotation(), true);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	ShutDown();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <p>In current version of UT we had to copy paste entire function from AUT_projectile, as applying radius damage is not split into own function yet.</p> <p><strong>AUTWeapon_Boom.cpp</strong> - To adjust damage &amp; momentum of direct damage, override DamageImpactedActor_Implementation</p> <ol><li><p>void AUTProjectile_Boom::DamageImpactedActor_Implementation(AActor* OtherActor, UPrimitiveComponent* OtherComp, const FVector&amp; HitLocation, const FVector&amp; HitNormal)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> const float AdjustedDamage \= GetDamage(OtherActor, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> const float AdjustedMomentum \= GetMomentum(OtherActor, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // treat as point damage if projectile has no radius
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (DamageParams.OuterRadius \&gt; 0.0f)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	FUTRadialDamageEvent Event;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	Event.Params \= DamageParams;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.Params.MinimumDamage \= AdjustedDamage; // force full damage for direct hit
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.DamageTypeClass \= MyDamageType;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.Origin \= HitLocation;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.BaseMomentumMag \= AdjustedMomentum;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	new(Event.ComponentHits) FHitResult(OtherActor, OtherComp, HitLocation, HitNormal);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.ComponentHits\[0\].TraceStart \= HitLocation \- GetVelocity();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.ComponentHits\[0\].TraceEnd \= HitLocation + GetVelocity();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	OtherActor\-\&gt;TakeDamage(AdjustedDamage, Event, InstigatorController, this);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>else
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FUTPointDamageEvent Event;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.Damage \= AdjustedDamage;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.DamageTypeClass \= MyDamageType;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.HitInfo \= FHitResult(OtherActor, OtherComp, HitLocation, HitNormal);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.ShotDirection \= GetVelocity().SafeNormal();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Event.Momentum \= Event.ShotDirection \* AdjustedMomentum;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	OtherActor\-\&gt;TakeDamage(AdjustedDamage, Event, InstigatorController, this);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Finally set default DamageAttentuation in Flak Shard constructor</p> <ol><li><div class="language- extra-class"><pre><code> DamageAttenuation \= 5.f;
</code></pre></div></li></ol> <h3 id="making-projectile-apply-damage-only-when-moving-fast-enough"><a href="#making-projectile-apply-damage-only-when-moving-fast-enough" class="header-anchor">#</a> Making projectile apply damage only when moving fast enough</h3> <p>Flak Shards deal damage only when moving over 400 UU/s. This way shards that lost much of the velocity after bounce won't hit you.</p> <p><strong>AUTProj_FlakShard.h</strong> - Add MinDamageSpeed property to determine minimum speed required to apply damage.</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Minimum speed at which damage can be applied \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float MinDamageSpeed;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - Set default MinDamageSpeed in FlakShard constructor.</p> <ol><li><div class="language- extra-class"><pre><code> MinDamageSpeed \= 400.f \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShard.cpp</strong> - With our custom GetDamage() function in place, override it in FlakShard to adjust its damage.</p> <ol><li><p>float AUTProj_FlakShard::GetDamage(AActor* OtherActor, const FVector&amp; HitLocation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> // Apply damage only when moving fast enough
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (GetVelocity().Size() \&gt; MinDamageSpeed)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	return Super::GetDamage(OtherActor, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> return 0.f;
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="flak-cannon-main-shard"><a href="#flak-cannon-main-shard" class="header-anchor">#</a> Flak Cannon main shard</h3> <p>Flak Cannon fires a special shard at the center. It always fires at crosshair, can bounce 3 times and deals additional damage at close range.</p> <p><strong>AUTProj_FlakShardMain.cpp</strong> - Increase BounceLimit to 3 in FlakShardMain constructor.</p> <ol><li><div class="language- extra-class"><pre><code> BounceLimit \= 3;
</code></pre></div></li></ol> <h4 id="adjusting-damage-based-on-how-much-in-the-face-the-shot-was"><a href="#adjusting-damage-based-on-how-much-in-the-face-the-shot-was" class="header-anchor">#</a> Adjusting damage based on how much in-the-face the shot was</h4> <p>Main Flak Shard deals bonus damage at very close range. Additionally it deals more damage when aiming at center of enemy.</p> <p><strong>AUTProj_FlakShardMain.h</strong> - Add properties for bonus damage and momentum. To check how far the projectile travelled we will use the same method as in UT3 - checking elapsed LifeSpan</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Momentum bonus for point blank shots \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float CenteredMomentumBonus;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Damage bonus for point blank shots \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float CenteredDamageBonus;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Timeout for point blank shots \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>float MaxBonusTime;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShardMain.cpp</strong> - Set default properties in constructor</p> <ol><li><div class="language- extra-class"><pre><code> CenteredMomentumBonus \= 90000 \* UT3\_TO\_UT4\_SCALE;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> CenteredDamageBonus \= 100.0;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MaxBonusTime \= 0.2;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShardMain.cpp</strong> - Override GetDamage() &amp; GetMomentum() to return adjusted valued</p> <ol><li><p>/**</p></li> <li><p>* Increase damage to UTPawns based on how centered this shard is on target.  If it is within the time MaxBonusTime time period.</p></li> <li><p>* e.g. point blank shot with the flak cannon you will do mega damage.  Once MaxBonusTime passes then this shard becomes a normal shard.</p></li> <li><p>*/</p></li> <li><p>float AUTProj_FlakShardMain::GetDamage(AActor* OtherActor, const FVector&amp; HitLocation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> const float CalculatedDamage \= Super::GetDamage(OtherActor, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // When hitting a pawn within bonus point blank time
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>AUTCharacter\* OtherCharacter \= Cast&lt;AUTCharacter\&gt;(OtherActor);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>const float BonusTime \= GetLifeSpan() \- InitialLifeSpan + MaxBonusTime;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>if (CalculatedDamage \&gt; 0.f &amp;&amp; OtherCharacter !\= NULL &amp;&amp; BonusTime \&gt; 0)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Apply bonus damage
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const float CharacterRadius \= OtherCharacter\-\&gt;GetSimpleCollisionRadius();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const float OffCenterDistance \= FMath::PointDistToLine(OtherActor\-\&gt;GetActorLocation(), GetVelocity().SafeNormal(), HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const float OffCenterMultiplier \= FMath::Max(0.f, 2.f \* (CharacterRadius \- OffCenterDistance)) / CharacterRadius;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const float BonusDamage \= CenteredDamageBonus \* BonusTime \* OffCenterMultiplier;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return CalculatedDamage + BonusDamage;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>return CalculatedDamage;
</code></pre></div></li> <li><p>}</p></li> <li><p>/**</p></li> <li><p>* Increase momentum imparted based on how recently this shard was fired</p></li> <li><p>*/</p></li> <li><p>float AUTProj_FlakShardMain::GetMomentum(AActor* OtherActor, const FVector&amp; HitLocation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code>// When hitting something within bonus point blank time
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>const float Momentum \= Super::GetMomentum(OtherActor, HitLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>const float BonusTime \= GetLifeSpan() \- InitialLifeSpan + MaxBonusTime;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>if (BonusTime \&gt; 0)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Apply bonus momentum
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return Momentum + CenteredMomentumBonus \* BonusTime;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>return Momentum;
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="making-flak-shell-spawn-additional-shards-on-explosion"><a href="#making-flak-shell-spawn-additional-shards-on-explosion" class="header-anchor">#</a> Making Flak Shell spawn additional shards on explosion</h3> <p>Flak Shell should spawn 5 shards on explosion. The shards should fly away from hit surface.</p> <p><strong>AUTProj_FlakShell.h</strong> - Add properties to FlakShell for number of shards to spawn, angle to spawn and class to use.</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Number of shards to spawn \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> int32 ShardSpawnCount;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Angle for spawning shards, relative to hit normal \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> float ShardSpawnAngle;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Shard class type \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Flak Cannon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TSubclassOf&lt;AUTProjectile\&gt; ShardClass;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShell.cpp</strong> - Set default properties in FlakShell constructor</p> <ol><li><div class="language- extra-class"><pre><code> ShardClass \= AUTProj\_FlakShard::StaticClass();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ShardSpawnCount \= 5;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> ShardSpawnAngle \= 85;
</code></pre></div></li></ol> <p><strong>AUTProj_FlakShell.cpp</strong> - Override Explode_Implementation() to spawn additional projectiles</p> <ol><li><p>void AUTProj_FlakShell::Explode_Implementation(const FVector&amp; HitLocation, const FVector&amp; HitNormal)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> // On explosion spawn additional flak shards
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (!bExploded &amp;&amp; Role \== ROLE\_Authority &amp;&amp; ShardClass &amp;&amp; ShardSpawnCount \&gt; 0)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// Setup spawn parameters
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	FActorSpawnParameters Params;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	Params.Instigator \= Instigator;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	Params.Owner \= Instigator;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.bNoCollisionFail \= true;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	for (int32 i \= 0; i &lt; ShardSpawnCount; ++i)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		// Randomize spawn direction along hit normal
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		const FRotator SpawnRotation \= FMath::VRandCone(HitNormal, FMath::DegreesToRadians(ShardSpawnAngle)).Rotation();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		// Spawn shard
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		GetWorld()\-\&gt;SpawnActor&lt;AUTProjectile\&gt;(ShardClass, HitLocation, SpawnRotation, Params);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>Super::Explode\_Implementation(HitLocation, HitNormal);
</code></pre></div></li> <li><p>}</p></li></ol> <h3 id="spawning-multiple-shards-at-once"><a href="#spawning-multiple-shards-at-once" class="header-anchor">#</a> Spawning multiple shards at once</h3> <p>Last but not least, we're going to add ability to spawn multiple projectiles at once from a weapon.</p> <p><strong>AUTWeapon_Boom.h</strong> - Add properties for number of projectiles to fire and class for additional projectiles</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Number of projectiles to fire.
</code></pre></div></li> <li><p>* When firing multiple projectiles at once, main projectile will be fired at crosshair.</p></li> <li><p>* Remaining projectiles will be fired in a circle pattern */</p></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TArray&lt;int32\&gt; MultiShotCount;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Projectile class to use when firing multiple projectiles at once.
</code></pre></div></li> <li><p>* This is only for additional projectiles, main projectile will use ProjClass.</p></li> <li><p>* If not specified, ProjClass will be used. */</p></li> <li><div class="language- extra-class"><pre><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TArray&lt; TSubclassOf&lt;AUTProjectile\&gt; \&gt; MultiShotProjClass;
</code></pre></div></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Override FireProjectile() to spawn multiple projectiles at once. In this snippet projectiles will be spawned using default weapon's spread.</p> <ol><li><p>AUTProjectile* AUTWeapon_Boom::FireProjectile()</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (GetUTOwner() \== NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	UE\_LOG(UT, Warning, TEXT(&quot;%s::FireProjectile(): Weapon is not owned (owner died during firing sequence)&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	return NULL;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> else if (Role \== ROLE\_Authority)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// try and fire a projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	checkSlow(ProjClass.IsValidIndex(CurrentFireMode) &amp;&amp; ProjClass\[CurrentFireMode\] !\= NULL);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// increment 3rd person muzzle flash count
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	UTOwner\-\&gt;IncrementFlashCount(CurrentFireMode);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Setup spawn parameters
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FActorSpawnParameters Params;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.Instigator \= UTOwner;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.Owner \= UTOwner;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.bNoCollisionFail \= true;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Get muzzle location and rotation
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const FVector SpawnLocation \= GetFireStartLoc();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const FRotator SpawnRotation \= GetAdjustedAim(SpawnLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Fire projectiles
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	AUTProjectile\* MainProjectile \= NULL;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	if (MultiShotCount.IsValidIndex(CurrentFireMode) &amp;&amp; MultiShotCount\[CurrentFireMode\] \&gt; 1)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		for (int32 i \= 0; i &lt; MultiShotCount\[CurrentFireMode\]; ++i)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			// Get firing location and rotation for this projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			const FVector MultiShotLocation \= GetFireStartLoc();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			const FRotator MultiShotRotation \= GetAdjustedAim(SpawnLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			// Get projectile class
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			TSubclassOf&lt;AUTProjectile\&gt; ProjectileClass \= ProjClass\[CurrentFireMode\];
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			if (i !\= 0 &amp;&amp; MultiShotProjClass.IsValidIndex(CurrentFireMode) &amp;&amp; MultiShotProjClass\[CurrentFireMode\] !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>				ProjectileClass \= MultiShotProjClass\[CurrentFireMode\];
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			// Spawn projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			AUTProjectile\* MultiShot \= GetWorld()\-\&gt;SpawnActor&lt;AUTProjectile\&gt;(ProjectileClass, MultiShotLocation, MultiShotRotation, Params);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			if (MainProjectile \== NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>				MainProjectile \= MultiShot;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	else
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		// Spawn projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		MainProjectile \= GetWorld()\-\&gt;SpawnActor&lt;AUTProjectile\&gt;(ProjClass\[CurrentFireMode\], SpawnLocation, SpawnRotation, Params);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return MainProjectile;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>else
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return NULL;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <p>This will spawn MultiShotCount projectiles on firing.</p> <p><strong>AUTWeap_FlakCannon.cpp</strong> - Add multishot default properties</p> <ol><li><div class="language- extra-class"><pre><code> MultiShotCount.SetNumZeroed(1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotCount\[0\] \= 9;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotProjClass.SetNumZeroed(1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotProjClass\[0\] \= AUTProj\_FlakShard::StaticClass();
</code></pre></div></li></ol> <h4 id="projectile-firing-pattern"><a href="#projectile-firing-pattern" class="header-anchor">#</a> Projectile firing pattern</h4> <p>Flak Cannon fires shards in distinct semi-random pattern. Main shard is fired at crosshair. Each additional projectile then is fired at equally spaced fragment of firing cone circle. Slight location &amp; rotation randomization is still applied but the shards are guaranteed to cover entire firing cone. This makes the weapon more predictable which is good for pro gaming. We're going to implement this pattern as default for multi-shot weapons.</p> <p><strong>AUTWeapon_Boom.h</strong> - Add property for angle of firing pattern and two functions to return firing location &amp; rotation of individual projectiles.</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Firing cone angle in degrees.
</code></pre></div></li> <li><p>* Applies to individual projectiles when firing multiple at once. */</p></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TArray&lt;FRotator\&gt; MultiShotAngle;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Returns projectile spawn location when firing multiple projectiles at once \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> FVector GetFireLocationForMultiShot(int32 MultiShotIndex, const FVector&amp; FireLocation, const FRotator&amp; FireRotation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>/\*\* Returns projectile spawn rotation when firing multiple projectiles at once \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>FRotator GetFireRotationForMultiShot(int32 MultiShotIndex, const FVector&amp; FireLocation, const FRotator&amp; FireRotation);
</code></pre></div></li></ol> <p><strong>AUTWeap_FlakCannon.cpp</strong> - Add multishot default properties</p> <ol><li><div class="language- extra-class"><pre><code> MultiShotAngle.SetNumZeroed(1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotAngle\[0\] \= FRotator(0, 3, 0);
</code></pre></div></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Implement GetFireLocationForMultiShot(). We will add randomization later.</p> <ol><li><p>FVector AUTWeapon_Boom::GetFireLocationForMultiShot_Implementation(int32 MultiShotIndex, const FVector&amp; FireLocation, const FRotator&amp; FireRotation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> // Main projectile fires straight from muzzle center
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> return FireLocation;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Implement GetFireRotationForMultiShot(). We will add randomization later.</p> <ol><li><p>FRotator AUTWeapon_Boom::GetFireRotationForMultiShot_Implementation(int32 MultiShotIndex, const FVector&amp; FireLocation, const FRotator&amp; FireRotation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (MultiShotIndex \&gt; 0 &amp;&amp; MultiShotAngle.IsValidIndex(CurrentFireMode))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// Each additional projectile can have own fragment of firing cone.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// This way there are no empty spots in firing cone due to randomness.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// While still randomish, the pattern is predictable, which is good for pro gaming.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// Get direction at fragment of firing cone
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const float Alpha \= (float)(MultiShotIndex \- 1) / (float)(MultiShotCount\[CurrentFireMode\] \- 1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const FRotator ConeSector \= FRotator(0, 0, 360.f \* Alpha);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FVector FireDirection \= ConeSector.RotateVector(MultiShotAngle\[CurrentFireMode\].Vector());
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Return firing cone rotated by player's firing rotation
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return FireRotation.RotateVector(FireDirection).Rotation();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Main projectile fires straight at crosshair
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>return FireRotation;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Modify FireProjectile() so it uses our functions</p> <ol><li><p>AUTProjectile* AUTWeapon_Boom::FireProjectile()</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (GetUTOwner() \== NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	UE\_LOG(UT, Warning, TEXT(&quot;%s::FireProjectile(): Weapon is not owned (owner died during firing sequence)&quot;));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	return NULL;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> else if (Role \== ROLE\_Authority)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// try and fire a projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	checkSlow(ProjClass.IsValidIndex(CurrentFireMode) &amp;&amp; ProjClass\[CurrentFireMode\] !\= NULL);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// increment 3rd person muzzle flash count
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	UTOwner\-\&gt;IncrementFlashCount(CurrentFireMode);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Setup spawn parameters
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FActorSpawnParameters Params;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.Instigator \= UTOwner;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.Owner \= UTOwner;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	Params.bNoCollisionFail \= true;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Get muzzle location and rotation
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const FVector SpawnLocation \= GetFireStartLoc();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const FRotator SpawnRotation \= GetAdjustedAim(SpawnLocation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Fire projectiles
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	AUTProjectile\* MainProjectile \= NULL;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	if (MultiShotCount.IsValidIndex(CurrentFireMode) &amp;&amp; MultiShotCount\[CurrentFireMode\] \&gt; 1)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		for (int32 i \= 0; i &lt; MultiShotCount\[CurrentFireMode\]; ++i)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			// Get firing location and rotation for this projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			const FVector MultiShotLocation \= GetFireLocationForMultiShot(i, SpawnLocation, SpawnRotation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			const FRotator MultiShotRotation \= GetFireRotationForMultiShot(i, SpawnLocation, SpawnRotation);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			// Get projectile class
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			TSubclassOf&lt;AUTProjectile\&gt; ProjectileClass \= ProjClass\[CurrentFireMode\];
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			if (i !\= 0 &amp;&amp; MultiShotProjClass.IsValidIndex(CurrentFireMode) &amp;&amp; MultiShotProjClass\[CurrentFireMode\] !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>				ProjectileClass \= MultiShotProjClass\[CurrentFireMode\];
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			// Spawn projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			AUTProjectile\* MultiShot \= GetWorld()\-\&gt;SpawnActor&lt;AUTProjectile\&gt;(ProjectileClass, MultiShotLocation, MultiShotRotation, Params);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			if (MainProjectile \== NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>				MainProjectile \= MultiShot;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	else
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		// Spawn projectile
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		MainProjectile \= GetWorld()\-\&gt;SpawnActor&lt;AUTProjectile\&gt;(ProjClass\[CurrentFireMode\], SpawnLocation, SpawnRotation, Params);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return MainProjectile;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>else
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return NULL;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <h5 id="projectile-firing-pattern-randomization"><a href="#projectile-firing-pattern-randomization" class="header-anchor">#</a> Projectile firing pattern randomization</h5> <p>Right now projectiles are fired in perfect circle pattern. We're going to randomize starting location and rotation.</p> <p><strong>AUTWeapon_Boom.h</strong> - Add properrties for location &amp; rotation randomization</p> <ol><li><div class="language- extra-class"><pre><code> /\*\* Firing location randomness, in unreal units.
</code></pre></div></li> <li><p>* Applies to individual projectiles when firing multiple at once */</p></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TArray&lt;FVector\&gt; MultiShotLocationSpread;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* Firing direction randomness, in degrees. 
</code></pre></div></li> <li><p>* Applies to individual projectiles when firing multiple at once */</p></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TArray&lt;float\&gt; MultiShotRotationSpread;
</code></pre></div></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Modify GetFireLocationForMultiShot() so it returns adjusted location.</p> <ol><li><p>FVector AUTWeapon_Boom::GetFireLocationForMultiShot_Implementation(int32 MultiShotIndex, const FVector&amp; FireLocation, const FRotator&amp; FireRotation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (MultiShotIndex \&gt; 0 &amp;&amp; MultiShotLocationSpread.IsValidIndex(CurrentFireMode))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// Randomise each projectile's spawn location if needed.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	return FireLocation + FireRotation.RotateVector(FMath::VRand() \* MultiShotLocationSpread\[CurrentFireMode\]);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Main projectile fires straight from muzzle center
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>return FireLocation;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Modify GetFireRotationForMultiShot() so it returns adjusted rotation.</p> <ol><li><p>FRotator AUTWeapon_Boom::GetFireRotationForMultiShot_Implementation(int32 MultiShotIndex, const FVector&amp; FireLocation, const FRotator&amp; FireRotation)</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (MultiShotIndex \&gt; 0 &amp;&amp; MultiShotAngle.IsValidIndex(CurrentFireMode))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// Each additional projectile can have own fragment of firing cone.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// This way there are no empty spots in firing cone due to randomness.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// While still randomish, the pattern is predictable, which is good for pro gaming.
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	// Get direction at fragment of firing cone
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const float Alpha \= (float)(MultiShotIndex \- 1) / (float)(MultiShotCount\[CurrentFireMode\] \- 1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	const FRotator ConeSector \= FRotator(0, 0, 360.f \* Alpha);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	FVector FireDirection \= ConeSector.RotateVector(MultiShotAngle\[CurrentFireMode\].Vector());
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Randomise each projectile's spawn rotation if needed 
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	if (MultiShotRotationSpread.IsValidIndex(CurrentFireMode))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		FireDirection \= FMath::VRandCone(FireDirection, FMath::DegreesToRadians(MultiShotRotationSpread\[CurrentFireMode\]));
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	// Return firing cone rotated by player's firing rotation
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	return FireRotation.RotateVector(FireDirection).Rotation();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>// Main projectile fires straight at crosshair
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>return FireRotation;
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTWeap_FlakCannon.cpp</strong> - Add firing pattern default properties</p> <ol><li><div class="language- extra-class"><pre><code> MultiShotLocationSpread.SetNumZeroed(1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotLocationSpread\[0\] \= FVector(0, 3, 3);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotRotationSpread.SetNumZeroed(1);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> MultiShotRotationSpread\[0\] \= 3;
</code></pre></div></li></ol> <h3 id="camera-shake"><a href="#camera-shake" class="header-anchor">#</a> Camera Shake</h3> <p>We can add camera shake as well to our base class. This way it can be used by all weapons.</p> <p><strong>AUTWeapon_Boom.h</strong> - Add camera shake properties and function</p> <ol start="2"><li><div class="language- extra-class"><pre><code> /\*\* delay between firing and camera shake being played \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TArray&lt;float\&gt; CameraShakeDelay;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> /\*\* how strong camera shake should be \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> TArray&lt;float\&gt; CameraShakeScale;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>/\*\* camera shake type \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>TArray&lt; TSubclassOf&lt;class UCameraShake\&gt; \&gt; CameraShakeType;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>/\*\* Plays camera shake immediately \*/
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category \= &quot;Weapon&quot;)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>void PlayCameraShake();
</code></pre></div></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Add PlayCameraShake() implementation</p> <ol><li><p>void AUTWeapon_Boom::PlayCameraShake_Implementation()</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> if (UTOwner !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	AUTPlayerController\* PC \= Cast&lt;AUTPlayerController\&gt;(UTOwner\-\&gt;Controller);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	if (PC !\= NULL)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		// Play camera shake
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		if (CameraShakeType.IsValidIndex(CurrentFireMode) &amp;&amp; CameraShakeType\[CurrentFireMode\] !\= NULL &amp;&amp; CameraShakeScale.IsValidIndex(CurrentFireMode))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>			PC\-\&gt;ClientPlayCameraShake(CameraShakeType\[CurrentFireMode\], CameraShakeScale\[CurrentFireMode\]);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>		}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTWeapon_Boom.cpp</strong> - Override PlayFiringEffects() so it calls our PlayCameraShake() function</p> <ol><li><p>void AUTWeapon_Boom::PlayFiringEffects()</p></li> <li><p>{</p></li> <li><div class="language- extra-class"><pre><code> Super::PlayFiringEffects();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> // Play camera shake after optional delay
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> if (CameraShakeDelay.IsValidIndex(CurrentFireMode) &amp;&amp; CameraShakeDelay\[CurrentFireMode\] \&gt; 0)
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	GetWorldTimerManager().SetTimer(this, &amp;AUTWeapon\_Boom::PlayCameraShake, CameraShakeDelay\[CurrentFireMode\], false);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> }
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>else
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	PlayCameraShake();
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>}
</code></pre></div></li> <li><p>}</p></li></ol> <p><strong>AUTWeap_FlakCannon.cpp</strong> - Add CameraShake assets &amp; default properties to FlakCannon constructor</p> <ol><li><div class="language- extra-class"><pre><code> struct FConstructorStatics
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> {
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	...
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	ConstructorHelpers::FClassFinder&lt;UCameraShake\&gt; CameraShakeType0;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	ConstructorHelpers::FClassFinder&lt;UCameraShake\&gt; CameraShakeType1;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 	FConstructorStatics()
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		...
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		, CameraShakeType0(TEXT(&quot;BlueprintGeneratedClass'/Game/RestrictedAssets/Blueprints/WIP/Nick/CameraAnims/Camerashake2.Camerashake2\_C'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code> 		, CameraShakeType1(TEXT(&quot;BlueprintGeneratedClass'/Game/RestrictedAssets/Blueprints/WIP/Nick/CameraAnims/Camerashake2.Camerashake2\_C'&quot;))
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	{
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>	}
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>};
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>...
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeType.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeType\[0\] \= ConstructorStatics.CameraShakeType0.Class;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeType\[1\] \= ConstructorStatics.CameraShakeType1.Class;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeDelay.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeDelay\[0\] \= 0.05f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeDelay\[1\] \= 0.05f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeScale.SetNumZeroed(2);
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeScale\[0\] \= 1.f;
</code></pre></div></li> <li><div class="language- extra-class"><pre><code>CameraShakeScale\[1\] \= 1.f;
</code></pre></div></li></ol> <h2 id="source-code"><a href="#source-code" class="header-anchor">#</a> Source Code</h2> <p>* <a href="https://github.com/roman-dzieciol/UnrealTournament/commit/1a148e6381233f654aa4a1b84b88e94496c6b0c8" target="_blank" rel="noopener noreferrer">https://github.com/roman-dzieciol/UnrealTournament/commit/1a148e6381233f654aa4a1b84b88e94496c6b0c8<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
* <a href="https://github.com/EpicGames/UnrealTournament/pull/26" target="_blank" rel="noopener noreferrer">https://github.com/EpicGames/UnrealTournament/pull/26<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>Retrieved from &quot;<a href="https://wiki.unrealengine.com/index.php?title=UT3_Weapons_Tutorial_-_Flak_Cannon&amp;oldid=10610" target="_blank" rel="noopener noreferrer">https://wiki.unrealengine.com/index.php?title=UT3_Weapons_Tutorial_-_Flak_Cannon&amp;oldid=10610<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&quot;</p> <p><a href="/Special:Categories" title="Special:Categories">Categories</a>:</p> <ul><li><a href="/Category:Unreal_Tournament" title="Category:Unreal Tournament">Unreal Tournament</a></li> <li><a href="/Category:UT_Content_Creation" title="Category:UT Content Creation">UT Content Creation</a></li></ul> <p><img src="https://tracking.unrealengine.com/track.png" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/wiki.unrealengine.com/assets/js/app.aaf63946.js" defer></script><script src="/wiki.unrealengine.com/assets/js/2.4f53495e.js" defer></script><script src="/wiki.unrealengine.com/assets/js/1125.ad8826c7.js" defer></script>
  </body>
</html>
