<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta charset="UTF-8" /><title>View source for C++ Camera Controlled Turrets - Epic Wiki</title>
<meta name="generator" content="MediaWiki 1.22.2" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="Epic Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.unrealengine.com/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Epic Wiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=epic&amp;*" />
<link rel="stylesheet" href="/extensions/EpicVideoSystem/CSS/VideoSystem.css" />
<link rel="stylesheet" href="/skins/epic/resources/screen.css?303" media="screen" />
<link rel="stylesheet" href="/skins/epic/resources/epic.css?303" media="screen" />
<link rel="stylesheet" href="/skins/epic/resources/prettify.css?303" media="screen" />
<link rel="stylesheet" href="/skins/epic/resources/jquery.qtip.css?303" media="screen" /><meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=epic&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: my_wiki:resourceloader:filter:minify-css:7:07b6a8ccf3fd62e770f192d0a6f8e123 */</style>

<script src="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=epic&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"C++_Camera_Controlled_Turrets","wgTitle":"C++ Camera Controlled Turrets","wgCurRevisionId":22488,"wgRevisionId":0,"wgArticleId":5181,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"C++_Camera_Controlled_Turrets","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"templateEditor":false,"templates":false,"preview":true,"previewDialog":false,"publish":true,"toc":false}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"epic","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: my_wiki:resourceloader:filter:minify-js:7:2197af7670c41256853f340e275ede1b */
}</script>
<script src="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=skins.epic.extras.js%7Cskins.epic.fancybox.js%7Cskins.epic.js%7Cskins.epic.qtip.js%7Cskins.epic.slimscroll.js&amp;only=scripts&amp;skin=epic&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/epic/csshover.min.htc")}</style><![endif]--><script type="text/javascript">
var experimentID = false;
var cxApi = null;
var variation = 0;
var fancyTitle = "";
var CE_SNAPSHOT_NAME = document.getElementsByTagName("title")[0].innerHTML;
$(document).ready(function(){
	if(experimentID != false)
	{
		$(head).append('<script src="//www.google-analytics.com/cx/api.js?experiment=' + experimentID + '" />' + '</scr' + 'ipt>');
		HandleExperiment();
	}
	else
	{
		CE_SNAPSHOT_NAME = (fancyTitle != "" ? fancyTitle : document.getElementsByTagName("title")[0].innerHTML);
		setTimeout(function () {
			var a = document.createElement("script");
			var b = document.getElementsByTagName("script")[0];
			a.src = document.location.protocol + "//script.crazyegg.com/pages/scripts/0028/4572.js?" + Math.floor(new Date().getTime() / 3600000);
			a.async = true; a.type = "text/javascript"; b.parentNode.insertBefore(a, b)
		}, 1);	
	}
});
function HandleExperiment()
{
	CE_SNAPSHOT_NAME = (fancyTitle != "" ? fancyTitle : document.getElementsByTagName("title")[0].innerHTML);
	if(cxApi != null)
	{
		variation = cxApi.chooseVariation();
		cxApi.setChosenVariation(variation, experimentID);
		if(variation != cxApi.ORIGINAL_VARIATION && variation != cxApi.NO_CHOSEN_VARIATION && variation != cxApi.NOT_PARTICIPATING)
		{
			//var URL = document.location.href + (document.location.search != '' ? '&var=' : '?var=') + variation;
			ga('send', 'event', 'A/B', 'ID: ' + experimentID, 'Variation: ' + variation, {'nonInteraction': 1});
			//document.location.href = URL; 
			CE_SNAPSHOT_NAME = document.getElementsByTagName("title")[0].innerHTML + ' (variation ' + variation + ')';
			var test = "";
		}
		else
		{
			ga('send', 'event', 'A/B', 'ID: ' + experimentID, 'Variation: ' + variation, {'nonInteraction': 1});
		}
		ToggleExperimentContent(variation);
		setTimeout(function () {
			var a = document.createElement("script");
			var b = document.getElementsByTagName("script")[0];
			a.src = document.location.protocol + "//script.crazyegg.com/pages/scripts/0028/4572.js?" + Math.floor(new Date().getTime() / 3600000);
			a.async = true; a.type = "text/javascript"; b.parentNode.insertBefore(a, b)
		}, 1);
	}
	else
	{
		setTimeout("HandleExperiment()", 500);
	}
}

function ToggleExperimentContent(variation)
{
	$('.AB').hide();
	$('#variation_' + variation).show();
}
</script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-C_Camera_Controlled_Turrets skin-epic action-edit vector-animateLayout">
		<!--<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>-->
		<!-- Google Tag Manager -->
		<noscript>
			<iframe src="//www.googletagmanager.com/ns.html?id=GTM-KWRD6D"
					height="0" width="0" style="display:none;visibility:hidden"></iframe>
		</noscript>
		<script>
		(function (w, d, s, l, i) {
		w[l] = w[l] || []; w[l].push({
		'gtm.start':
		new Date().getTime(), event: 'gtm.js'
		}); var f = d.getElementsByTagName(s)[0],
		j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
		'//www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
		})(window, document, 'script', 'dataLayer', 'GTM-KWRD6D');</script>
		<!-- End Google Tag Manager -->
		<div id="webThree">
		<div id="head"></div>
		<div id="pagedefault">		
                    <div id="pagenav">
                        <div>
                            <!-- Start of Other language links -->
                            <!-- End of Other language links -->
                            <div class="homelink_container">
                                <a href="https://wiki.unrealengine.com" title="UE4 Wiki Home" class="homelink">HOME</a>
                            </div>
                        </div>
                        <div style="clear:both;">
                        </div>
                    </div>	
		<div id="mw-navigation" style="max-width:972px;margin:1em auto 0 auto;">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="jumplink" onclick="$('#sidebar').toggle();">
					Navigation
				</div>
				<div id="sidebar">
					<!-- Start of jump page links -->
					<div class="largetitle">
						Quick Links
					</div>
					<div class="arrowlist">
						<!-- End of jump page links -->
						<!-- Start of related page links -->
						<!-- End of related page links -->								
						<div id="mw-panel">
							<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Community' aria-labelledby='p-Community-label'>
	<h3 id='p-Community-label'>Community</h3>
	<div class="body">
		<ul>
			<li id="n-UE4-Games"><a href="/Category:Games">UE4 Games</a></li>
			<li id="n-Dev-Blogs"><a href="/Developer_Blogs">Dev Blogs</a></li>
			<li id="n-Dev-Livestreams"><a href="/Developer_Livestreams">Dev Livestreams</a></li>
			<li id="n-Code-Sharing-Hub"><a href="/GitHub_Sharing_Hub">Code Sharing Hub</a></li>
			<li id="n-UE-User-Groups"><a href="/User_Group_Map">UE User Groups</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Learning_Resources' aria-labelledby='p-Learning_Resources-label'>
	<h3 id='p-Learning_Resources-label'>Learning Resources</h3>
	<div class="body">
		<ul>
			<li id="n-Tutorials"><a href="/Category:Tutorials">Tutorials</a></li>
			<li id="n-Example-Projects"><a href="/Category:Example_Projects">Example Projects</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Software_and_Tools' aria-labelledby='p-Software_and_Tools-label'>
	<h3 id='p-Software_and_Tools-label'>Software and Tools</h3>
	<div class="body">
		<ul>
			<li id="n-Plug-ins"><a href="/Category:Plug-ins">Plug-ins</a></li>
			<li id="n-Art:-3D"><a href="/3D_Art_Resources">Art: 3D</a></li>
			<li id="n-Art:-2D"><a href="/2D_Art_Resources">Art: 2D</a></li>
			<li id="n-Audio"><a href="/Audio_Resources">Audio</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Modding' aria-labelledby='p-Modding-label'>
	<h3 id='p-Modding-label'>Modding</h3>
	<div class="body">
		<ul>
			<li id="n-Modding-Resources"><a href="/Category:Modding_Resources">Modding Resources</a></li>
			<li id="n-Moddable-Games"><a href="/Category:Moddable_Games">Moddable Games</a></li>
			<li id="n-Unreal-Tournament"><a href="/Category:Unreal_Tournament">Unreal Tournament</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-Epic_Official' aria-labelledby='p-Epic_Official-label'>
	<h3 id='p-Epic_Official-label'>Epic Official</h3>
	<div class="body">
		<ul>
			<li id="n-Website"><a href="https://www.unrealengine.com" rel="nofollow">Website</a></li>
			<li id="n-Learning-Resources"><a href="https://docs.unrealengine.com/latest/INT/" rel="nofollow">Learning Resources</a></li>
			<li id="n-Forums"><a href="https://forums.unrealengine.com/" rel="nofollow">Forums</a></li>
			<li id="n-Blog"><a href="https://www.unrealengine.com/blog" rel="nofollow">Blog</a></li>
			<li id="n-YouTube"><a href="https://www.youtube.com/UnrealEngine" rel="nofollow">YouTube</a></li>
			<li id="n-Twitch"><a href="http://www.twitch.tv/unrealengine" rel="nofollow">Twitch</a></li>
			<li id="n-Twitter"><a href="https://twitter.com/UnrealEngine" rel="nofollow">Twitter</a></li>
			<li id="n-Facebook"><a href="https://www.facebook.com/UnrealEngine" rel="nofollow">Facebook</a></li>
			<li id="n-Instagram"><a href="https://instagram.com/unrealengine/" rel="nofollow">Instagram</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/C%2B%2B_Camera_Controlled_Turrets" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/C%2B%2B_Camera_Controlled_Turrets" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="/index.php?title=C%2B%2B_Camera_Controlled_Turrets&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
						</div>
					</div>
				</div>				
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/C%2B%2B_Camera_Controlled_Turrets"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="/index.php?title=Talk:C%2B%2B_Camera_Controlled_Turrets&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="/C%2B%2B_Camera_Controlled_Turrets" >View</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="/index.php?title=C%2B%2B_Camera_Controlled_Turrets&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/index.php?title=C%2B%2B_Camera_Controlled_Turrets&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">History</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-createaccount"><a href="/index.php?title=Special:UserLogin&amp;returnto=C%2B%2B+Camera+Controlled+Turrets&amp;returntoquery=action%3Dedit&amp;type=signup">Create account</a></li><li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=C%2B%2B+Camera+Controlled+Turrets&amp;returntoquery=action%3Dedit" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>	</ul>
</div>
				</div>
			</div>
		</div>
		<div id="maincol">
		<div class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- Start of crumbs links -->
			<div class="crumbs">
			<p>
							</p>
			</div>
			<!-- End of crumbs links -->
			<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for C++ Camera Controlled Turrets</span></h1>
			<div id="bodyContent">
				<div id="contentSub">← <a href="/C%2B%2B_Camera_Controlled_Turrets" title="C++ Camera Controlled Turrets">C++ Camera Controlled Turrets</a></div>
																<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in the group: <a href="/index.php?title=Epic_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Epic Wiki:Users (page does not exist)">Users</a>.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Rating|Type=Tutorial|Versions=4.12}}

[[Category:Tutorials]]
[[Category:Code]]

== Overview ==

This tutorial is aimed at people who want to do a little more C++ programming. Having some prior knowledge of C++ is not needed to follow this tutorial. It will take you from the beginning to end. The end result is having a player controlled ship which it's turrets will follow the direction of the camera.

So I've decided that since I've finally figured out how to make turrets work on battleships/spaceships that I should share my discovery and help anyone else who is having difficulties figuring it out with C++! I'm going to take you through the entire process from start to finish, including the set up needed to get everything working just right. So this tutorial may be a little bit long, but I promise you it's worth it!

== Requirements ==

Before you start this tutorial, you should have a few things prepared and ready.

# C++ empty project.
# Ship mesh
# Turret Chassis mesh
# Turret Barrel mesh

For a little clarification on the Turret meshes, you want two separate meshes to bring into the engine, the body of the turret (which we will refer to as the Chassis) and the barrels of the turret (which we will refer to as the Barrels).

Go on ahead and get all those three meshes imported into the project!

== Our Goals ==

So we are setting out with a few goals to accomplish in this tutorial.

# We want to set up the Ship and Turret base classes
# Extend the Ship and Turret base classes into blueprints
# Get the turrets to spawn on the Ship
# Make the turrets rotate and pitch properly
# Bonus: Get the turrets to fire!

== Getting Started ==

=== Set up the Ship Mesh ===

Before we go to much further, we want to make sure that your ship mesh is set up correctly! What we want to do is add some sockets to the ship so our code can spawn the turrets in correctly and at the right locations. So go to where your ship mesh is and double click it. This should bring up the mesh editor in the engine.

Now make sure that the Sockets button is highlighted in the top navbar, and then go to Window -> Socket Manager.

This will make a little window appear off to the right, with a green button named Create Socket.

Go ahead and create some sockets and place them where ever on the mesh you wish! Mine are set up as below.

{{Note|Make sure that you name the sockets consistantly and append a number at the end. This will enable our code to easily find any sockets on the ship and spawn the turrets onto them. I used TurretSkt0, TurretSkt1, etc.}}

[[File:ShipSockets.png]]

=== Set up the Turret Barrel Mesh ===

Just like the Ship Mesh and placing it's sockets, we want to do the same thing for the barrel mesh, but this time where putting the sockets at the end of the barrels. This is going to be used to help give an origin point of where we are going to spawn our projectiles.

{{Note|Again, make sure the sockets are named consistently and are appended by a number. For this example I named them Muzzle_1, Muzzle_2, etc.}}

[[File:TurretSockets.png]]

=== Creating The Base Classes ===

So let's get those base classes created! We will begin with the Ship Base Class.

So once your project is open in the editor, go to File -> New C++ Class.

You will be prompted with a screen of what to inherit. We want our parent class to be the Pawn.

[[File:ParentClass.png]]

Then we want to give the class a name, ShipBase is what I used. You can name it anything.

[[File:NameClass.png]]

It will only take a moment for the engine to add the code file and structure to your project, so sit tight!

Once that is done, go ahead and repeat this section for the Turret. I named the class TurretBase.

So now you should have two classes created and the files should be open in your IDE.

== Initializing the Ship and Turret Classes ==

Our two classes should look the same and have a few things in the code already like below.

ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
#include "TurretTutorial.h"
#include "ShipBase.h"


// Sets default values
AShipBase::AShipBase()
{
 	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

}

// Called when the game starts or when spawned
void AShipBase::BeginPlay()
{
	Super::BeginPlay();
	
}

// Called every frame
void AShipBase::Tick( float DeltaTime )
{
	Super::Tick( DeltaTime );

}

// Called to bind functionality to input
void AShipBase::SetupPlayerInputComponent(class UInputComponent* InputComponent)
{
	Super::SetupPlayerInputComponent(InputComponent);

}
&lt;/syntaxhighlight>

ShipBase.h
&lt;syntaxhighlight lang="cpp">
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "GameFramework/Pawn.h"
#include "ShipBase.generated.h"

UCLASS()
class TURRETTUTORIAL_API AShipBase : public APawn
{
	GENERATED_BODY()

public:
	// Sets default values for this pawn's properties
	AShipBase();

	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	
	// Called every frame
	virtual void Tick( float DeltaSeconds ) override;

	// Called to bind functionality to input
	virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;

	
	
};
&lt;/syntaxhighlight>

So the next step is to get our ShipBase and TurretBase classes to actually work so we can extend these base classes out into Blueprints and do some fun stuff with them! The main reason why we are creating a base class for the ship and turret and then extending it out into Blueprints is observing a thing called Object Oriented Programming. I wont go into the semantics of it, but the idea is that we have a common parent class of a Ship and a Turret. We then can create as many variations of these base classes in either Blueprints or Code. This creates flexibility and eliminates having a ton of duplicate code!

In short the ShipBase and TurretBase classes will have all the common properties shared among any ships and any turrets.

=== ShipBase Class ===

So let us get our ShipBase.h filled out! First we want to include our newly created TurretBase class. 

ShipBase.h
&lt;syntaxhighlight lang="cpp">
// TurretBase Include
#include "../Turrets/TurretBase.h"
&lt;/syntaxhighlight>

Now we want to get everything else set up, including our Mesh of our ship, then build up the camera and get a few more things sorted. Take a look at the rest of the code below.

ShipBase.h
&lt;syntaxhighlight lang="cpp">
UCLASS()
class TURRETTUTORIAL_API AShipBase : public APawn
{
	GENERATED_BODY()

public:

	/** StaticMesh component that will be the visuals for our flying ship */
	UPROPERTY(Category = Mesh, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	class UStaticMeshComponent* HullMesh;

	/** Spring arm that will offset the camera */
	UPROPERTY(Category = Camera, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	class USpringArmComponent* SpringArm;

	/** Camera component that will be our viewpoint */
	UPROPERTY(Category = Camera, VisibleDefaultsOnly, BlueprintReadOnly, meta = (AllowPrivateAccess = "true"))
	class UCameraComponent* Camera;
	
	// Sets default values for this actor's properties
	AShipBase(const FObjectInitializer&amp; ObjectInitializer);

	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	
	// Called every frame
	virtual void Tick( float DeltaSeconds ) override;

        /** Returns PlaneMesh subobject **/
	FORCEINLINE class UStaticMeshComponent* GetPlaneMesh() const { return HullMesh; }
	/** Returns SpringArm subobject **/
	FORCEINLINE class USpringArmComponent* GetSpringArm() const { return SpringArm; }
	/** Returns Camera subobject **/
	FORCEINLINE class UCameraComponent* GetCamera() const { return Camera; }

protected:

        // Camera variables so we can control our camera
	UPROPERTY(Category = Camera, EditDefaultsOnly)
		float SpringArmDistance;
	UPROPERTY(Category = Camera, EditDefaultsOnly)
		FVector SpringArmSocketOffset;
	UPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)
		float CameraMaxPitch;
	UPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)
		float CameraMinPitch;
	UPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)
		float CameraZoomAmount;
	UPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)
		float CameraZoomSpeed;
	UPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)
		float CameraMaxZoom;
	UPROPERTY(Category = Camera, BlueprintReadWrite, EditAnywhere)
		float CameraMinZoom;

	// Camera CURRENT variables
	float CurrentCameraZoomDistance;

        // Begin AActor overrides
	virtual void SetupPlayerInputComponent(class UInputComponent * InputComponent) override;
	// End AActor overrides

	void CameraYawInput(float Val);
	void CameraPitchInput(float Val);
	void CameraZoom(float Val);
	void CameraZoomIn();
	void CameraZoomOut();
&lt;/syntaxhighlight>

Now with the header file completed, we will now add to our ShipBase.cpp file. First were going to modify this original constructor of the class, which should look like this right now...

ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
// Sets default values
AShipBase::AShipBase()
{
 	// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

}
&lt;/syntaxhighlight>

And turn it into this...

ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
AShipBase::AShipBase(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)
{
	// Initialize all base values

	// Set camera control defaults
	SpringArmDistance = 1250.0f;
	SpringArmSocketOffset = FVector(0.f, 0.f, 380.f);
	CameraMaxPitch = 45.0f;
	CameraMinPitch = -45.0f;
	CameraMaxZoom = SpringArmDistance * 3;
	CameraMinZoom = 500.0f;
	CameraZoomAmount = 250.0f;
	CameraZoomSpeed = CameraZoomAmount / 3;

	// Create static mesh component
	HullMesh = CreateDefaultSubobject&lt;UStaticMeshComponent>(TEXT("HullMesh"));
	RootComponent = HullMesh;
	SpringArm = CreateDefaultSubobject&lt;USpringArmComponent>(TEXT("SpringArm"));
	SpringArm->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);

	// Create the spring arm component
	SpringArmDistance = 700.0f;	// Sets up default SpringArmDistance
	SpringArmSocketOffset = FVector(0.f, 0.f, 60.f);	//Sets up default SpringArm Offset

	
	SpringArm->TargetArmLength = SpringArmDistance;
	SpringArm->SocketOffset = SpringArmSocketOffset;
	SpringArm->bEnableCameraLag = false;
	SpringArm->CameraLagSpeed = 15.f;

	// Create camera component
	Camera = CreateDefaultSubobject&lt;UCameraComponent>(TEXT("Camera"));
	Camera->AttachToComponent(SpringArm, FAttachmentTransformRules::KeepRelativeTransform, USpringArmComponent::SocketName);
	Camera->bUsePawnControlRotation = false; // Don't rotate camera with the controller

	HullMesh->SetCollisionObjectType(ECC_Pawn);
	HullMesh->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);

	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;
}
&lt;/syntaxhighlight>

Whew! That was a big change. But were not done just yet, we now should add in our input controls for our camera! Remember you have to match this code in the input controls of the engine!

ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
void AShipBase::SetupPlayerInputComponent(class UInputComponent *InputComponent)
{
	check(InputComponent);
	InputComponent->BindAxis("CameraYaw", this, &amp;AShipBase::CameraYawInput);
	InputComponent->BindAxis("CameraPitch", this, &amp;AShipBase::CameraPitchInput);
	InputComponent->BindAction("MouseWheelUp", IE_Pressed, this, &amp;AShipBase::CameraZoomIn);
	InputComponent->BindAction("MouseWheelDown", IE_Pressed, this, &amp;AShipBase::CameraZoomOut);
}

void AShipBase::CameraYawInput(float Val)
{
	SpringArm->RelativeRotation.Yaw += Val;
}

void AShipBase::CameraPitchInput(float Val)
{
	float NewPitch = (Val * -1.0f) + SpringArm->RelativeRotation.Pitch;
	SpringArm->RelativeRotation.Pitch = FMath::Clamp(NewPitch, CameraMinPitch, CameraMaxPitch);
}

void AShipBase::CameraZoom(float Val)
{
	CurrentCameraZoomDistance = SpringArm->TargetArmLength;
	SpringArmDistance = CurrentCameraZoomDistance + (CameraZoomAmount * Val);
	float TargetArmDistance = FMath::Clamp(SpringArmDistance, CameraMinZoom, CameraMaxZoom);
	SpringArm->TargetArmLength = FMath::FInterpTo(CurrentCameraZoomDistance, TargetArmDistance, GetWorld()->GetDeltaSeconds(), CameraZoomSpeed);
}

void AShipBase::CameraZoomIn()
{
	CameraZoom(1.0f);
}

void AShipBase::CameraZoomOut()
{
	CameraZoom(-1.0f);
}
&lt;/syntaxhighlight>

Now were in business! With the initial set up of our ShipBase class, we now need to go on to getting our TurretBase class set up as well!

=== TurretBase Class ===

So similarly in the ShipBase.h, we want to get out TurretBase.h file up to snuff. So lets get our class filled out properly...

TurretBase.h
&lt;syntaxhighlight lang="cpp">
UCLASS()
class TURRETTUTORIAL_API ATurretBase : public APawn, public ITurretInterface
{
	GENERATED_BODY()
	
public:	
	// Public Variables
	FRotator TurretLocalRot;

	// Sets default values for this actor's properties
	ATurretBase(const FObjectInitializer&amp; ObjectInitializer);

	/** StaticMesh component that will be the visuals for the turret */
	UPROPERTY(Category = Mesh, EditDefaultsOnly, BlueprintReadWrite, meta = (AllowPrivateAccess = "true"))
		class UStaticMeshComponent* TurretHullMesh;

        /** StaticMesh component that will be the visuals for the barrels */
	UPROPERTY(Category = Mesh, EditDefaultsOnly, BlueprintReadWrite, meta = (AllowPrivateAccess = "true"))
		class UStaticMeshComponent* TurretBarrelMesh;

	// Called when the game starts or when spawned
	virtual void BeginPlay() override;
	
	// Called every frame
	virtual void Tick( float DeltaSeconds ) override;

	void TurretLookAt();

	// Spawns Munitions
	UPROPERTY(Category = BlueprintSpawn, EditDefaultsOnly, BlueprintReadOnly)
		TSubclassOf&lt;AMunitionsBase> MunitionsBP;
	TArray&lt;FName> MuzzleArray;
	void GetMuzzleSockets();
	void SpawnMunitions(FName _MuzzleSocketName);

	//ITurretInterface
	virtual void PrimaryFireControl() override;

	UPROPERTY(Category = Chasis, BlueprintReadWrite, VisibleAnywhere)
		float TurretYawSpeed;
	UPROPERTY(Category = Chasis, BlueprintReadWrite, VisibleAnywhere)
		float TurretMaxYaw;
	UPROPERTY(Category = Chasis, BlueprintReadWrite, VisibleAnywhere)
		float TurretMinYaw;

	UPROPERTY(Category = Barrel, BlueprintReadWrite, VisibleAnywhere)
		float TurretPitchSpeed;
	UPROPERTY(Category = Barrel, BlueprintReadWrite, VisibleAnywhere)
		float TurretMaxPitch;
	UPROPERTY(Category = Barrel, BlueprintReadWrite, VisibleAnywhere)
		float TurretMinPitch;

	UPROPERTY(Category = Control, BlueprintReadWrite, EditDefaultsOnly)
		bool IsOccupied;
	UPROPERTY(Category = Control, BlueprintReadOnly, VisibleAnywhere)
		bool IsTargeting;

private:
	bool IsFiring;
	float CurrentChasisRot;
	float CurrentBarrelRot;
	float CurrentYawMin;
	float CurrentYawMax;
	FRotator CurrentTurretRot;
	FRotator TurretYawRot;
	FRotator TurretPitchRot;
	
};
&lt;/syntaxhighlight>

So now we want to do the same thing with the base constructor class that was generated for us as we did in the ShipBase.cpp file. We want to turn it into this...

TurretBase.cpp
&lt;syntaxhighlight lang="cpp">
// Sets default values
ATurretBase::ATurretBase(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)
{

	// Create the static mesh component
	TurretHullMesh = CreateDefaultSubobject&lt;UStaticMeshComponent>(TEXT("TurretHullMesh"));
	TurretBarrelMesh = CreateDefaultSubobject&lt;UStaticMeshComponent>(TEXT("TurretBarrelMesh"));
	RootComponent = TurretHullMesh;
	TurretBarrelMesh->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);

	// Set default variables
	IsOccupied = false;
	IsFiring = false;
	TurretYawSpeed = 20.f;
	TurretMaxYaw = 180.f;
	TurretMinYaw = -180.f;
	TurretPitchSpeed = 20.f;
	TurretMaxPitch = 45.f;
	TurretMinPitch = -1.f;

	TurretLocalRot = FRotator(0.f, 0.f, 0.f);
	TurretYawRot = FRotator(0.f, 0.f, 0.f);
	TurretPitchRot = FRotator(0.f, 0.f, 0.f);

	CurrentYawMax = (TurretHullMesh->GetRelativeTransform().GetRotation().X) + TurretMaxYaw;
	CurrentYawMin = (TurretHullMesh->GetRelativeTransform().GetRotation().X) + TurretMinYaw;

	IsTargeting = false;

 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

}
&lt;/syntaxhighlight>

Next we want to prepare our Tick event. What we are doing here is simply calling a function every frame that will handle the turrets logic to look at our camera's focal point!

TurretBase.cpp
&lt;syntaxhighlight lang="cpp">
// Called every frame
void ATurretBase::Tick( float DeltaTime )
{
	TurretLookAt();
	Super::Tick( DeltaTime );
}
&lt;/syntaxhighlight>

With that complete lets actually just get in an empty class so we can compile. We will handle the TurretLookAt logic in just a bit. While we do that, lets get a few more skeleton functions out of the way.

TurretBase.cpp
&lt;syntaxhighlight lang="cpp">
void ATurretBase::TurretLookAt()
{

}

/* ITurretInterface */
void ATurretBase::PrimaryFireControl()
{

}

void ATurretBase::GetMuzzleSockets() 
{

}

void ATurretBase::SpawnMunitions(FName _MuzzleSocketName) 
{

}
&lt;/syntaxhighlight>

With that, compile! We should have the base classes started! The next step is to get them extended into Blueprints to begin getting some results.

== Extending The Base Classes ==

So now that were done getting the basics of the classes in, let's quickly extend those two classes into blueprints so we can set up the turret and the ship!

Let's do the ship first. It should be really straight forward and simple. Right click in the content browser and click Blueprint Class.

Now when it asks to pick a parent class, you want to go to the very bottom of the window, where it says All Classes, click that and then type in ShipBase (Or whatever you named it)

[[File:ExtendingShip.png]]

Click Create, then name the blueprint what ever you want. I named it BP_Ship. Do the same thing for the TurretBase.

Once the blueprints are created, there is not much else to do for the BP_Ship. But there is something you need to take care of in the BP_Turret. Open it up, and go to the Viewport tab on the turret, then adjust the barrel mesh so it sits correctly on your turrets Chasis. In the end you should have something like the following two images.

[[File:BP_Ship.png]]
[[File:BP_Turret.png]]

== Adding Turret Functionality ==

Now with all the previous work set up and running, now we can focus on adding functionality to our turrets!

=== Turret Spawn Logic ===

So in this section we are going to get the code in to spawn the turrets onto our ship! This can be done with a simple addition to our ShipBase class file. What we are going to do is create a set of functions in our Ship class that will handle finding the turret sockets, spawning the turrets to those turret sockets, and then have a function to delete the spawned turrets properly so when the ship dies in your game, it will do the proper deletion.

So go back to your IDE and add the code below.

ShipBase.h
&lt;syntaxhighlight lang="cpp">
        // Spawn Turrets
	UPROPERTY(Category = BlueprintSpawn, EditDefaultsOnly, BlueprintReadOnly)
		TSubclassOf&lt;ATurretBase> TurretBP;
	TArray&lt;FName> TurretArray;
	TArray&lt;ATurretBase*> SpawnedTurretArray;

	void GetTurretSockets();
	void SpawnTurret(FName _TurretSocketName);
        void DestroyTurrets();
&lt;/syntaxhighlight>

Now got to ShipBase.cpp and lets fill out those three functions!

ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
void AShipBase::GetTurretSockets() {
        // We store all the socket names into our own Turret Array
	TurretArray = HullMesh->GetAllSocketNames();
        // Then we iterate through that array and call our SpawnTurret() function and pass it our array's index
	for (int i = 0; i &lt; TurretArray.Num(); i++) {
		SpawnTurret(TurretArray[i]);
	}
}

/** Spawns the turrets onto the sockets of the ship */
void AShipBase::SpawnTurret(FName _TurretSocketName)
{
        // First we want to make sure these values are all zeroed out
	FVector SocketLocation;
	FTransform SocketTransform;
	SocketLocation = FVector(0, 0, 0);
	SocketLocation.Rotation() = FRotator(0, 0, 0);

        // Make sure the world exists first
	UWorld* const World = GetWorld();
	if (World &amp;&amp; TurretBP != NULL)
	{
                // Set the spawn parameters
		FActorSpawnParameters SpawnParams;
		SpawnParams.Owner = this;
		
                // This is where we instantiate our new Turret! RailGun_T can be whatever you want to name it 
		ATurretBase* RailGun_T = GetWorld()->SpawnActor&lt;ATurretBase>(TurretBP, SocketLocation, SocketLocation.Rotation());
                // Assign our newly spawned turret its rotation
		RailGun_T->TurretLocalRot = SocketLocation.Rotation();

                // Now we add that newly spawned turret to our array of pointers so we can reference it later
		SpawnedTurretArray.Add(RailGun_T);

                // Now we make sure our turret isn't null, and then attach it to our socket's location.
		if (RailGun_T != NULL) 
		{
			RailGun_T->AttachToComponent(this->RootComponent, FAttachmentTransformRules::KeepRelativeTransform, _TurretSocketName);
		}
	}
}

void AShipBase::DestroyTurrets()
{
        // Iterate over the turrets in the array we have them stored
	for (int i = 0; i &lt; SpawnedTurretArray.Num(); i++) {
		SpawnedTurretArray[i]->DetachFromControllerPendingDestroy();
		SpawnedTurretArray[i]->Destroy();
	}
}
&lt;/syntaxhighlight>

Now you just need to add our spawn function to the BeginPlay in ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
// Called when the game starts or when spawned
void AShipBase::BeginPlay()
{
	Super::BeginPlay();

	GetTurretSockets();
}
&lt;/syntaxhighlight>

Let us recap on what we did. First we went into the header file and created a few variables and three functions. The variables are important for a few reasons.
* TSubclassOf&lt;ATurretBase> TurretBP;
** This creates a pointer that we assign in our BP_Ship for any turret we want! We can create multiple of these pointers for when we have multiple different types of turrets.
* TArray&lt;FName> TurretArray;
** We did this to hold onto the sockets we find.
* TArray&lt;ATurretBase*> SpawnedTurretArray;
** We created this to hold onto the spawned turrets so we can easily reference them later.

Now for the functions, we have three.
# void GetTurretSockets();
#* To get the turret sockets on the ship.
# void SpawnTurret(FName _TurretSocketName);
#* To spawn a single turret, by passing it the socket we want it spawned to.
# void DestroyTurrets();
#* To delete all the turrets we spawned for proper deletion for when the ship is deleted (during game-play)

Now compile your code! Now if you go into the engine and double click your ship blueprint, in the details pane you should see a category called Blueprint Spawn. Inside that category is a picker, you want to click it and add in your Turret Blueprint.

[[File:BP_ShipDetails.png]]

Now set the Default Pawn Class to your ship blueprint. Click Play and you should have a ship that is spawning turrets!

[[File:BP_ShipSpawning.png]]

=== Turret Control ===

Now for the more complicated step in the logic department. Getting our turrets to look at our camera's focal point. This was the entire reason why your in this tutorial now aren't you?

Now before we go into the code I want to take a moment to explain what were going to try and do.

So what we want is for the turrets to look at wherever our cameras focal point is. So when we look right, the turrets should track our movement and attempt to point to where we are looking. In order to do this, they need to get our forward vector to know where exactly they are going to point. In order to figure out how much they need to rotate to get to our forward vector from the camera, they will need to take their forward vectors and normalize it against the cameras. Then all we do is take that normalized vector and apply it to our local rotation and voila! Our Turrets should now be looking at our camera's focal point!

It sounds pretty simple right? Well now it is! I'll be honest it took me awhile to figure this out on my own and get it working just right. So you remember that TurretLookAt() function we created? Well now it's time to fill that sucker out.

In the TurretBase.cpp file, go to where you have the skeleton of the function. 

&lt;syntaxhighlight lang="cpp">
void ATurretBase::TurretLookAt()
{
	// We want a pointer to hold our player controller.
	APlayerController* PC = Cast&lt;APlayerController>(Cast&lt;APawn>(GetAttachParentActor())->GetController());
	// Then we make sure our player controller exists.
	if (PC)
	{
		// Set the Focal Point Distance
		float FocalDistance = 10000.0f;
		// Get Camera Vector &amp; Rotator
		FVector CameraLocation = PC->PlayerCameraManager->GetCameraLocation();
		FRotator CameraRotation = PC->PlayerCameraManager->GetCameraRotation();
		// Get Turrets Vector &amp; Rotator
		FVector TurretLocation = GetActorLocation();
		FRotator TurretRotation = GetActorRotation();

		// Handle Turret Rotation
		FVector FocalPoint = CameraLocation + (CameraRotation.Vector() * FocalDistance);
		FVector TurretToFocal = FocalPoint - TurretLocation;
		FVector TurretToFocalLocal = TurretRotation.UnrotateVector(TurretToFocal);
		FRotator TurretFocalLookDirection = TurretToFocalLocal.Rotation();
		FRotator TurretYaw = FRotator(0, TurretFocalLookDirection.Yaw, 0);
		CurrentTurretRot = GetActorRotation();

		// We check to see if the turret is within it's movement range, if it is, we add the rotation and do one last addition check.
		if (FMath::IsWithin(CurrentTurretRot.Yaw, TurretMinYaw, TurretMaxYaw))
		{
			TurretHullMesh->AddRelativeRotation(TurretYaw);
			// Now we check to see if it's pretty close to our target, when it is we toggle a boolean to be used later!
			if (TurretYaw.Yaw > 0.f)
			{
				IsTargeting = false;
			}
		}
		else {
			IsTargeting = false;
		}

		// Now it's time to do the same for the turret's barrels pitch!
		FRotator TurretBarrelPitch = FRotator(TurretFocalLookDirection.Pitch, 0, 0);
		TurretBarrelPitch.Pitch = FMath::Clamp(TurretBarrelPitch.Pitch, TurretMinPitch, TurretMaxPitch);
		TurretBarrelMesh->SetRelativeRotation(TurretBarrelPitch);

		// Do the targeting check with the barrels as well!
		if (TurretBarrelPitch.Pitch == TurretFocalLookDirection.Pitch)
		{
			IsTargeting = true;
		}
		else
		{
			IsTargeting = false;
		}
	}
}
&lt;/syntaxhighlight>

Now with that filled out, we want to go to our Tick() function and add our function call to it!

TurretBase.cpp
&lt;syntaxhighlight lang="cpp">
// Called every frame
void ATurretBase::Tick( float DeltaTime )
{
	TurretLookAt();
	Super::Tick( DeltaTime );
}
&lt;/syntaxhighlight>

Compile and run the game! Now your turrets should rotate and the barrels should pitch! And that is how you get your turrets to follow your cameras focal point!

[[File:BP_TurretControl.png]]

=== Turret Firing ===

Now, how about we get those turrets to fire? Everybody likes a good BOOM to their code! Now this section will be a little less informative. It's a challenge out to you to actually get the some of the set up work done! You've done it before, now you should have the tools to get the Munitions ready!

For how I got my projectiles set up, was that I followed the same steps in creating a MunitionsBase Class, and then I got it set up to hold a spherical mesh. Once that was done I made sure I added it to a collision channel for the projectiles.

Once you have the projectile class created, extend it into a blueprint!

Now that we have a munitions object to use, lets go back to our TurretBase.cpp. You remember earlier making a few more skeletons functions that we haven't filled out yet. Those functions were PrimaryFireControl(), GetMuzzleSockets(), and then SpawnMunitions().

It follows the similar path as to spawning the turrets. We want to find the muzzle sockets on the barrel mesh, add it to an array, then spawn the projectiles at the muzzle locations and add an impulse to the projectile.

TurretBase.cpp
&lt;syntaxhighlight lang="cpp">
/* ITurretInterface */
// This acts as a gate for firing any projectiles. So if the turrets cannot see your cameras focal point they wont fire!
void ATurretBase::PrimaryFireControl()
{
	if (IsTargeting)
	{
		GetMuzzleSockets();
	}
}

// Same steps as to getting the sockets for the turrets!
void ATurretBase::GetMuzzleSockets() 
{
	MuzzleArray = TurretBarrelMesh->GetAllSocketNames();
	for (int i = 0; i &lt; MuzzleArray.Num(); i++) {
		SpawnMunitions(MuzzleArray[i]);
	}
}

// Almost the same as spawning the turrets, but this time we check to make sure the projectile blueprint exists
void ATurretBase::SpawnMunitions(FName _MuzzleSocketName) 
{
	if (MunitionsBP != NULL)
	{
		// Get the location and the rotation for the new projectile
		FVector SpawnLocation = TurretBarrelMesh->GetSocketLocation(_MuzzleSocketName);
		FRotator SpawnRotation = TurretBarrelMesh->GetSocketRotation(_MuzzleSocketName);

		// Making sure the world exists, if it does we spawn it!
		UWorld* const World = GetWorld();
		if (World &amp;&amp; MunitionsBP) {
			AMunitionsBase* Projectile = World->SpawnActor&lt;AMunitionsBase>(MunitionsBP, SpawnLocation, SpawnRotation);

			// We give the projectiles an owner! This can be used later for hit detection and the like!
			Projectile->OwningPlayer = GetController();
			Projectile->OwningActor = this->GetAttachParentActor();

			// This is completely option. I made a muzzle flash for fun. You can remove the below If statement if you want.
			if (MuzzleFX)
			{
				UParticleSystemComponent* MuzzleFlash = UGameplayStatics::SpawnEmitterAtLocation(this, MuzzleFX, SpawnLocation, SpawnRotation, true);
			}
		}
	}
}
&lt;/syntaxhighlight>

Now in order to make sure you can fire your turrets, we need to make sure we have a player input set up in the editor to control that. But one more step needs to be taken to tell the turrets that the player is firing! We can't just simply add the controls to the turrets themselves, we are going to take advantage of that Interface function, PrimaryFireControl()!

Now go to your ShipBase.cpp and add a input component.
&lt;syntaxhighlight lang="cpp">
InputComponent->BindAction("PrimaryFire", IE_Pressed, this, &amp;AShipBase::ShipPrimaryFire);
&lt;/syntaxhighlight>

Now we create the function! We are still in ShipBase.cpp. What were going to do here is loop through the SpawnedTurretArray and with the interface, tell them to execute the function PrimaryFireControl(). One purpose of Interfaces is to give us a way to call functions in another class or object when we don't want to hold onto the instantiated class in caller.

ShipBase.cpp
&lt;syntaxhighlight lang="cpp">
void AShipBase::ShipPrimaryFire() {
	for (int i = 0; i &lt; SpawnedTurretArray.Num(); i++) {
		ITurretInterface* TheInterface = Cast&lt;ITurretInterface>(SpawnedTurretArray[i]);
		if (TheInterface)
		{
			TheInterface->PrimaryFireControl();
		}
	}
}
&lt;/syntaxhighlight>

[[File:TurretFire.png]]

Now before we continue, there is one last thing we need to do! You need to add a blank C++ class through the editor, you should name these files TurretInterface. Fill these files out like so.

TurretInterface.cpp
&lt;syntaxhighlight lang="cpp">
#include "TurretTutorial.h"
#include "TurretInterface.h"

UTurretInterface::UTurretInterface(const FObjectInitializer&amp; ObjectInitializer)
	: Super(ObjectInitializer)
{

}

// This is required for compiling, would also let you know if somehow you called
// the base event/function rather the override version
void ITurretInterface::PrimaryFireControl()
{

}
&lt;/syntaxhighlight>

TurretInterface.h
&lt;syntaxhighlight lang="cpp">
#pragma once

#include "TurretInterface.generated.h"

UINTERFACE(MinimalAPI)
class UTurretInterface : public UInterface
{
	GENERATED_UINTERFACE_BODY()
};

class ITurretInterface
{
	GENERATED_IINTERFACE_BODY()

public:
	virtual void PrimaryFireControl() = 0;
};
&lt;/syntaxhighlight>

Now, with this you should be able to compile your project. These two files are primarily to set up the class, to be accessible globally but more importantly, allow the project to compile! Now let me spend just a moment to explain why the interface is useful and how it pertains to our application here. Interfaces in C++ allow you to set up game wide event triggers directly in C++ or the level blueprint. Now I wont spend the time explaining on how to open the C++ Interfaces to blueprints in this tutorial, but I may cover it in my second tutorial when I extend this out to support C++ Networking.

You can set up Interfaces like the one we just did for many things, for example, creating a special event such as a capital ship exploding and then having a multitude of different actors respond to it.

== Conclusion ==

There you have it! You now have a ship that can spawn turrets that will look to where your camera is pointing and also fire! Your just a couple steps away from creating a ship to ship combat game! This is just one out of a few ways of accomplishing this, and I do not claim this the most efficient but it is the solution I came up with. I'm particularly proud of it and find it a big achievement.

I do hope you found this tutorial helpful! If you have any questions or suggestions, feel free to PM me on the Unreal Engine Forums! It is after all my first tutorial and would love some feedback!

IntVoid

[[User:IntVoid|IntVoid]] ([[User talk:IntVoid|talk]])
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="/Template:Note" title="Template:Note">Template:Note</a> (<a href="/index.php?title=Template:Note&amp;action=edit" title="Template:Note">view source</a>) </li><li><a href="/Template:Rating" title="Template:Rating">Template:Rating</a> (<a href="/index.php?title=Template:Rating&amp;action=edit" title="Template:Rating">view source</a>) (protected)</li></ul></div><p id="mw-returnto">Return to <a href="/C%2B%2B_Camera_Controlled_Turrets" title="C++ Camera Controlled Turrets">C++ Camera Controlled Turrets</a>.</p>
</div>												<div class="printfooter">
				Retrieved from "<a href="https://wiki.unrealengine.com/C%2B%2B_Camera_Controlled_Turrets">https://wiki.unrealengine.com/C%2B%2B_Camera_Controlled_Turrets</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		</div>
		</div>
		
		<div id="footer">
			<div id="brand">

			</div>
			<div id="legal">
				<div id="copyright">
					&copy; 2004-2015, Epic Games, Inc. All rights reserved. Unreal and its logo are Epic's trademarks or registered trademarks in the US and elsewhere.
				</div>
				<div id="terms">
					<a target="_blank" href="http://epicgames.com/tou">TERMS OF USE</a> | <a target="_blank" href="http://epicgames.com/privacynotice">PRIVACY POLICY</a>
				</div>
			</div>
		</div>
	</div>
		<!--<div id="footer" role="contentinfo">
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<div name="copyright">&#169; 2004-2014, Epic Games, Inc. All rights reserved. Epic Games, Unreal, Unreal Engine, Unreal Tournament, and their respective logos are Epic's trademarks or registered trademarks in the US and elsewhere.</div>
					</li>
					<li id="footer-termsofuseico">
						<div name="termsofuse"><a href="http://epicgames.com/tou" target="_blank">Terms of Use</a></div>
					</li>
					<li id="footer-privacynoticeico">
						<div name="privacynotice"><a href="http://epicgames.com/privacynotice" target="_blank">Privacy Policy</a></div>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>-->
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="/extensions/EpicSearchSystem/Javascript/Search.js?303"></script>
<script src="https://wiki.unrealengine.com/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=epic&amp;*"></script>
<!-- Served in 0.055 secs. -->		<img src="https://tracking.unrealengine.com/track.png" width="1" height="1">
		<!--<script type="text/javascript">
			setTimeout(function () {
				var a = document.createElement("script");
				var b = document.getElementsByTagName("script")[0];
				a.src = document.location.protocol + "//script.crazyegg.com/pages/scripts/0028/4572.js?" + Math.floor(new Date().getTime() / 3600000);
				a.async = true; a.type = "text/javascript"; b.parentNode.insertBefore(a, b)
			}, 1);
		</script>-->
	</body>
</html>

		