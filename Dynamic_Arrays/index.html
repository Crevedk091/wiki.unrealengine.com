<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>wiki.unrealengine.com</title>
    <meta name="description" content="A static site pulled from the internet archive">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css" as="style"><link rel="preload" href="/wiki.unrealengine.com/assets/js/app.aaf63946.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/2.4f53495e.js" as="script"><link rel="preload" href="/wiki.unrealengine.com/assets/js/461.1395d50a.js" as="script">
    <link rel="stylesheet" href="/wiki.unrealengine.com/assets/css/0.styles.b0e83839.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wiki.unrealengine.com/" class="home-link router-link-active"><!----> <span class="site-name">wiki.unrealengine.com</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Dynamic Arrays - Epic Wiki</p> <h1 id="dynamic-arrays"><a href="#dynamic-arrays" class="header-anchor">#</a> Dynamic Arrays</h1> <h2 id="contents"><a href="#contents" class="header-anchor">#</a> Contents</h2> <ul><li><a href="#Overview">1 Overview</a> <ul><li><a href="#Example_1">1.1 Example 1</a></li> <li><a href="#Example_2">1.2 Example 2</a></li> <li><a href="#Summary">1.3 Summary</a></li></ul></li> <li><a href="#Available_Types">2 Available Types</a> <ul><li><a href="#C.2B.2B_Type">2.1 C++ Type</a></li> <li><a href="#UE4_C.2B.2B_Type">2.2 UE4 C++ Type</a></li> <li><a href="#Pointer_to_UObject_Class">2.3 Pointer to UObject Class</a></li> <li><a href="#Pointer_to_AActor_Class">2.4 Pointer to AActor Class</a></li> <li><a href="#Pointer_to_Blueprint_Class">2.5 Pointer to Blueprint Class</a></li> <li><a href="#UE4_C.2B.2B_Enums">2.6 UE4 C++ Enums</a></li></ul></li> <li><a href="#Arrays_of_USTRUCTS.28.29_or_Pointers_to_UStructs">3 Arrays of USTRUCTS() or Pointers to UStructs</a> <ul><li><a href="#Sample_USTRUCT.28.29">3.1 Sample USTRUCT()</a></li> <li><a href="#Array_of_USTRUCTS.28.29">3.2 Array of USTRUCTS()</a></li> <li><a href="#The_Pointer_Version">3.3 The Pointer Version</a></li></ul></li> <li><a href="#Blueprint-Accessible_Dynamic_Arrays">4 Blueprint-Accessible Dynamic Arrays</a></li> <li><a href="#Core_Functions">5 Core Functions</a> <ul><li><a href="#.Add.28.29">5.1 .Add()</a></li> <li><a href="#.Remove.28.29">5.2 .Remove()</a></li> <li><a href="#.RemoveAt.28.29">5.3 .RemoveAt()</a></li> <li><a href="#.Num.28.29">5.4 .Num()</a></li></ul></li> <li><a href="#For_Loops">6 For Loops</a> <ul><li><a href="#Basic">6.1 Basic</a></li> <li><a href="#For_AActor.2A">6.2 For AActor*</a></li> <li><a href="#Using_Iterator">6.3 Using Iterator</a></li> <li><a href="#Iterator_AActor.2A_Example">6.4 Iterator AActor* Example</a></li> <li><a href="#Abbreviated_C.2B.2B11_Syntax">6.5 Abbreviated C++11 Syntax</a></li></ul></li> <li><a href="#Index_Safety_Check_To_Prevent_Crashes">7 Index Safety Check To Prevent Crashes</a> <ul><li><a href="#.IsValidIndex.28.29">7.1 .IsValidIndex()</a></li></ul></li> <li><a href="#Awesome_Functions">8 Awesome Functions</a> <ul><li><a href="#.Empty.28.29">8.1 .Empty()</a></li> <li><a href="#.Append.28.29">8.2 .Append()</a></li></ul></li> <li><a href="#Min.2FMax_of_Array_.284.3_and_higher.29">9 Min/Max of Array (4.3 and higher)</a></li> <li><a href="#Multi_Dimensional_Arrays">10 Multi Dimensional Arrays</a> <ul><li><a href="#.H">10.1 .H</a></li> <li><a href="#.CPP">10.2 .CPP</a></li> <li><a href="#Full_2D_Array_Code_Sample">10.3 Full 2D Array Code Sample</a></li></ul></li> <li><a href="#.5BEpic_Docs.5D_TArray_Optimization_Techniques">11 [Epic Docs] TArray Optimization Techniques</a></li> <li><a href="#Summary_2">12 Summary</a></li></ul> <h2 id="overview"><a href="#overview" class="header-anchor">#</a> Overview</h2> <p><em>Original Author:</em> <a href="/User:Rama" title="User:Rama">Rama</a> (<a href="/User_talk:Rama" title="User talk:Rama">talk</a>)</p> <p>Dear Community,</p> <p>Here is my introduction to UE4 C++ Dynamic Arrays!</p> <p>They're awesome!</p> <h3 id="example-1"><a href="#example-1" class="header-anchor">#</a> Example 1</h3> <p>You can use dynamic arrays to store references to every ACharacter that crosses a certain point in your level, and then, after at least 5 ACharacters have crossed the point, you can iterate over all the actors and perform an action.</p> <p>So in this way, you could make it a game-ending condition that if 5 bunny-rabbits reach their home, then the game ends in success.</p> <p>During runtime you never know how long it will take for the bunny-rabbits to reach home, but via code you can track how many have reached home, whenever they do, and the iterate over all of them to make them perform some kind of victory dance as the level ends.</p> <p>But you also never know which bunny-rabbits will be doing the dancing!</p> <p>thus the word &quot;dynamic&quot;</p> <p><strong>Dynamic arrays enable you to track dynamically changing game conditions from the UE4 C++</strong></p> <h3 id="example-2"><a href="#example-2" class="header-anchor">#</a> Example 2</h3> <p>You could make a dynamic array that is accessible to blueprints so your team members working in blueprints can add information to the dynamic array, which you as the programmer will then use in c++ during runtime.</p> <p>But you as the programmer do not know how much data they will add!</p> <p>So you could give the level designers a dynamic array to edit in blueprints, and they will fill it with 3 or 10 or 100 level names.</p> <p>Then you can, in the C++, iterate over all of the level names and display them, <strong>without ever knowing in advance how many levels the designers added!</strong></p> <p>And the level designers can add more any time!</p> <h3 id="summary"><a href="#summary" class="header-anchor">#</a> Summary</h3> <p><strong>Dynamic arrays are one of the most essential tools</strong> for any game-logic that you want to do,</p> <p>where the actions of the player, the in-game AI, and the rest of your team cannot be known in advance,</p> <p>but need to be tracked, organized, and facilitated via UE4 C++ code systems.</p> <h2 id="available-types"><a href="#available-types" class="header-anchor">#</a> Available Types</h2> <ul><li>Any C++ type</li> <li>Any UE4 C++ type, such as FLinearColor</li> <li>Pointer to a UObject or an AActor extending class</li> <li>Pointer to Blueprint Classes</li> <li>UE4++ Enums</li> <li>USTRUCTS() or USTRUCT() pointers</li></ul> <h3 id="c-type"><a href="#c-type" class="header-anchor">#</a> C++ Type</h3> <p>TArray&lt;uint8&gt; BinaryArray;</p> <h3 id="ue4-c-type"><a href="#ue4-c-type" class="header-anchor">#</a> UE4 C++ Type</h3> <p>TArray&lt;FRotator&gt; StarLocations;</p> <h3 id="pointer-to-uobject-class"><a href="#pointer-to-uobject-class" class="header-anchor">#</a> Pointer to UObject Class</h3> <p>TArray&lt;USkeletalMeshComponent*&gt; Weapons;</p> <h3 id="pointer-to-aactor-class"><a href="#pointer-to-aactor-class" class="header-anchor">#</a> Pointer to AActor Class</h3> <p>TArray&lt;ACharacter*&gt; FrogsThatAreHopping;</p> <h3 id="pointer-to-blueprint-class"><a href="#pointer-to-blueprint-class" class="header-anchor">#</a> Pointer to Blueprint Class</h3> <p>TArray&lt;UClass*&gt; FlowerBlueprints;</p> <h3 id="ue4-c-enums"><a href="#ue4-c-enums" class="header-anchor">#</a> UE4 C++ Enums</h3> <p>TArray<a href="EKeys::Type%5C">EKeys::Type\</a> GameControlKeys;</p> <h2 id="arrays-of-ustructs-or-pointers-to-ustructs"><a href="#arrays-of-ustructs-or-pointers-to-ustructs" class="header-anchor">#</a> Arrays of USTRUCTS() or Pointers to UStructs</h2> <p>Let's say you have defined this USTRUCT()</p> <h3 id="sample-ustruct"><a href="#sample-ustruct" class="header-anchor">#</a> Sample USTRUCT()</h3> <p>USTRUCT()
struct FFlowerStruct
{
GENERATED_USTRUCT_BODY()
 
UPROPERTY()
int32 NumPetals;
 
UPROPERTY()
FLinearColor Color;
 
UPROPERTY()
FVector Scale3D;
 
void SetFlowerColor(const FLinearColor&amp; NewColor)
{
Color = NewColor;
}
 
FFlowerStruct()
{
NumPetals 	= 5;
Scale3D 		= FVector(1,1,1);
Color 			= FLinearColor(1,0,0,1);
}
};</p> <h3 id="array-of-ustructs"><a href="#array-of-ustructs" class="header-anchor">#</a> Array of USTRUCTS()</h3> <p>You can make an array of FFlowerStructs as follows!</p> <p>TArray&lt;FFlowerStruct&gt; Flowers;</p> <h3 id="the-pointer-version"><a href="#the-pointer-version" class="header-anchor">#</a> The Pointer Version</h3> <p>TArray&lt;FFlowerStruct*&gt; FlowerPtrs;</p> <h2 id="blueprint-accessible-dynamic-arrays"><a href="#blueprint-accessible-dynamic-arrays" class="header-anchor">#</a> Blueprint-Accessible Dynamic Arrays</h2> <p>/** Add entries in BP Defaults, or during Runtime! Iterate over them using the For Each Loop BP Node */
UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=&quot;Flowers&quot;)
TArray&lt;FName&gt; FlowerNames;</p> <h2 id="core-functions"><a href="#core-functions" class="header-anchor">#</a> Core Functions</h2> <h3 id="add"><a href="#add" class="header-anchor">#</a> .Add()</h3> <p>TArray&lt;FVector&gt; StarLocations;
StarLocations.Add(FVector(0,0,2000000));</p> <h3 id="remove"><a href="#remove" class="header-anchor">#</a> .Remove()</h3> <p>//Defined in the .h file:
//  TArray&lt;ACharacter*&gt; FrogsThatAreHopping;
//  ACharacter* FrogThatIsTired;
 
FrogsThatAreHopping.Remove(FrogThatIsTired);</p> <h3 id="removeat"><a href="#removeat" class="header-anchor">#</a> .RemoveAt()</h3> <p>//Remove first frog from the array
if(FrogsThatAreHopping.Num() &gt; 0)
{
FrogsThatAreHopping.RemoveAt(0);
}</p> <h3 id="num"><a href="#num" class="header-anchor">#</a> .Num()</h3> <p>Returns number of elements in the array (can be used when you need the length of the array).</p> <p>ClientMessage(&quot;Total Flower Count&quot;);
ClientMessage(FString::FromInt(Flowers.Num()));</p> <h2 id="for-loops"><a href="#for-loops" class="header-anchor">#</a> For Loops</h2> <h3 id="basic"><a href="#basic" class="header-anchor">#</a> Basic</h3> <p>// defined in .h TArray<FVector> StarLocations;
 
//Print Star Locations
for(int32 b = 0; b &lt; StarLocations.Num(); b++)
{
ClientMessage(StarLocations[b].ToString());
}</FVector></p> <h3 id="for-aactor"><a href="#for-aactor" class="header-anchor">#</a> For AActor*</h3> <p>I am including very rigorous <strong>pointer safety</strong> and <strong>AActor validity</strong> checks,</p> <p>because you dont want your whole game to crash to desktop, ever 😃</p> <p>//defined in the .h : TArray&lt;AFlower*&gt; Flowers;
 
//Print out each flower's UE4 Name
 
AFlower* CurFlower = NULL;
for(int32 b = 0; b &lt; Flowers.Num(); b++)
{
CurFlower = Flowers[b];
if(!CurFlower) continue;
if(!CurFlower-&gt;IsValidLowLevel()) continue;
//~~~~~~~~~~~~~~~~~~~~~~
 
ClientMessage(CurFlower-&gt;GetName());
}</p> <h3 id="using-iterator"><a href="#using-iterator" class="header-anchor">#</a> Using Iterator</h3> <p>Posted originally by Solid Snake, thanks Solid Snake!</p> <p>for (auto Iter(TArray.CreateIterator()); Iter; Iter++)
{
// *Iter to access what this iterator is pointing to.
}</p> <h3 id="iterator-aactor-example"><a href="#iterator-aactor-example" class="header-anchor">#</a> Iterator AActor* Example</h3> <p>//defined in the .h : TArray&lt;AFlower*&gt; Flowers;
 
//Print out each flower's UE4 Name
for (auto Itr(Flowers.CreateIterator()); Itr; Itr++)
{
if(!(*Itr)-&gt;IsValidLowLevel()) continue;
//~~~~~~~~~~~~~~~~~~~~~~
 
ClientMessage((*Itr)-&gt;GetName());
}</p> <h3 id="abbreviated-c-11-syntax"><a href="#abbreviated-c-11-syntax" class="header-anchor">#</a> Abbreviated C++11 Syntax</h3> <p>This one is great when you don't need to know the index as you are iterating! <a href="/User:Rama" title="User:Rama">Rama</a> (<a href="/User_talk:Rama" title="User talk:Rama">talk</a>)</p> <p>this:</p> <p>for(int32 b; b &lt; StarLocations.Num(); b++)
{
ClientMessage(StarLocations[b].ToString());
}</p> <p>becomes this:</p> <p>for(const FVector&amp; EachLocation : StarLocations)
{
ClientMessage(EachLocation.ToString());
}</p> <p>If you want to change the value in the loop, and not just read it, then remove the const 😃</p> <h2 id="index-safety-check-to-prevent-crashes"><a href="#index-safety-check-to-prevent-crashes" class="header-anchor">#</a> Index Safety Check To Prevent Crashes</h2> <h3 id="isvalidindex"><a href="#isvalidindex" class="header-anchor">#</a> .IsValidIndex()</h3> <p>//defined in .h
//TArray<float> RandomPercentValues;
 
//Pick a random Percent Value!
float AMyPlayerController::GetRandomPercenttValue() const
{
//Negative array indicies are always invalid
//		and will always cause a crash if you try to use one.
 
//Use IsValidIndex to verify the index is in range
//		***before*** you try to access the array!
 
const int32 RandomIndex = FMath::RandRange(-50,10000);
 
//Safety Check
if( ! RandomPercentValues.IsValidIndex(RandomIndex)) return -1;
//~~~~~~~~~~~~~~~~~~~~~~~
 
return RandomPercentValues[RandomIndex];
}</float></p> <h2 id="awesome-functions"><a href="#awesome-functions" class="header-anchor">#</a> Awesome Functions</h2> <h3 id="empty"><a href="#empty" class="header-anchor">#</a> .Empty()</h3> <p>Empty array of all current contents</p> <p>//It's nighttime, no more hopping;
FrogsThatAreHopping.Empty();</p> <h3 id="append"><a href="#append" class="header-anchor">#</a> .Append()</h3> <p>Add the entire contents of one array to the end of another!</p> <p>TArray&lt;FVector&gt; StarLocations;
TArray&lt;FVector&gt; CloudLocations;
TArray&lt;FVector&gt; StarAndCloudLocations;
 
StarLocations.Add(0,0,200000);
CloudLocations.Add(50,25,11000);
CloudLocations.Add(50,25,22200);
 
StarAndCloudLocations.Append(StarLocations);
StarAndCloudLocations.Append(CloudLocations);
 
//Print out all Locations
for(int32 b; b &lt; StarAndCloudLocations.Num(); b++)
{
ClientMessage(StarAndCloudLocations[b].ToString());
}</p> <h2 id="min-max-of-array-4-3-and-higher"><a href="#min-max-of-array-4-3-and-higher" class="header-anchor">#</a> Min/Max of Array (4.3 and higher)</h2> <p>I offered two Math Library functions to Epic which are now part of the Engine in 4.3, allowing you to get the Min/Max of a Dynamic Array of any datatype for which the operator&lt; is defined!</p> <p>Full details here:</p> <p><strong><a href="/Min/Max_of_An_Array_of_Any_DataType,_Including_Ones_That_You_Create" title="Min/Max of An Array of Any DataType, Including Ones That You Create">Min Max of Array</a></strong></p> <h2 id="multi-dimensional-arrays"><a href="#multi-dimensional-arrays" class="header-anchor">#</a> Multi Dimensional Arrays</h2> <p>To make a 2 or higher dimensional array,</p> <p>wrap the array in a UStruct, and then make an Array of the UStructs</p> <h3 id="h"><a href="#h" class="header-anchor">#</a> .H</h3> <p>USTRUCT()
struct FFlowerField
{
GENERATED_USTRUCT_BODY()
 
UPROPERTY()
TArray&lt;FFlowerStruct&gt; Flowers;
 
FFlowerField()
{
}
};
 
//All Flower Fields on The Island
TArray&lt;FFlowerField&gt; FlowerFields;</p> <h3 id="cpp"><a href="#cpp" class="header-anchor">#</a> .CPP</h3> <p>Then to Access a single Flower</p> <p>//Is there at least 1 Flower Field?
if(FlowerFields.Num() &gt; 0)
{
//Does the first field have at least 3 flowers? (could use .Num() too)
if(FlowerFields[0].Flowers.IsValidIndex(2))
{
//Number of petals on the 3rd flower in 1st field
ClientMessage(FString::FromInt(FlowerFields[0].Flowers[2].NumPetals));
}
}</p> <h3 id="full-2d-array-code-sample"><a href="#full-2d-array-code-sample" class="header-anchor">#</a> Full 2D Array Code Sample</h3> <p>I have two extensive code samples for how to make 2D arrays that are BP-friendly and can be replicated!</p> <p><a href="https://forums.unrealengine.com/showthread.php?47-SaxonRahs-Tutorial-Thread-Random-Maze-Generation-amp-Solving&amp;p=27139&amp;viewfull=1#post27139" target="_blank" rel="noopener noreferrer">My Fully Coded 2D Array Example<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://forums.unrealengine.com/showthread.php?60398-Replicating-a-2D-dynamic-array&amp;p=232520&amp;viewfull=1#post232520" target="_blank" rel="noopener noreferrer">Replicating BP-Friendly 2D Array<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="epic-docs-tarray-optimization-techniques"><a href="#epic-docs-tarray-optimization-techniques" class="header-anchor">#</a> [Epic Docs] TArray Optimization Techniques</h2> <p>Epic has posted an awesome article on ways you can optimize your use of TArray!</p> <p><a href="https://www.unrealengine.com/blog/optimizing-tarray-usage-for-performance" target="_blank" rel="noopener noreferrer"><strong>TArray Optimizations for Performance</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="summary-2"><a href="#summary-2" class="header-anchor">#</a> Summary</h2> <p>I hope you have enjoyed my description of UE4 C++ Dynamic Arrays!</p> <p>Enjoy!</p> <p><a href="/User:Rama" title="User:Rama">Rama</a> (<a href="/User_talk:Rama" title="User talk:Rama">talk</a>)</p> <p>Retrieved from &quot;<a href="https://wiki.unrealengine.com/index.php?title=Dynamic_Arrays&amp;oldid=14756" target="_blank" rel="noopener noreferrer">https://wiki.unrealengine.com/index.php?title=Dynamic_Arrays&amp;oldid=14756<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&quot;</p> <p><a href="/Special:Categories" title="Special:Categories">Category</a>:</p> <ul><li><a href="/Category:Code" title="Category:Code">Code</a></li></ul> <p><img src="https://tracking.unrealengine.com/track.png" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/wiki.unrealengine.com/assets/js/app.aaf63946.js" defer></script><script src="/wiki.unrealengine.com/assets/js/2.4f53495e.js" defer></script><script src="/wiki.unrealengine.com/assets/js/461.1395d50a.js" defer></script>
  </body>
</html>
